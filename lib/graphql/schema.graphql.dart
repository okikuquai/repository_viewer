class Input$AbortQueuedMigrationsInput {
  factory Input$AbortQueuedMigrationsInput({
    required String ownerId,
    String? clientMutationId,
  }) =>
      Input$AbortQueuedMigrationsInput._({
        r'ownerId': ownerId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AbortQueuedMigrationsInput._(this._$data);

  factory Input$AbortQueuedMigrationsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AbortQueuedMigrationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get ownerId => (_$data['ownerId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AbortQueuedMigrationsInput<Input$AbortQueuedMigrationsInput>
      get copyWith => CopyWith$Input$AbortQueuedMigrationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AbortQueuedMigrationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ownerId = ownerId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$ownerId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AbortQueuedMigrationsInput<TRes> {
  factory CopyWith$Input$AbortQueuedMigrationsInput(
    Input$AbortQueuedMigrationsInput instance,
    TRes Function(Input$AbortQueuedMigrationsInput) then,
  ) = _CopyWithImpl$Input$AbortQueuedMigrationsInput;

  factory CopyWith$Input$AbortQueuedMigrationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AbortQueuedMigrationsInput;

  TRes call({
    String? ownerId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AbortQueuedMigrationsInput<TRes>
    implements CopyWith$Input$AbortQueuedMigrationsInput<TRes> {
  _CopyWithImpl$Input$AbortQueuedMigrationsInput(
    this._instance,
    this._then,
  );

  final Input$AbortQueuedMigrationsInput _instance;

  final TRes Function(Input$AbortQueuedMigrationsInput) _then;

  static const _undefined = {};

  TRes call({
    Object? ownerId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AbortQueuedMigrationsInput._({
        ..._instance._$data,
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AbortQueuedMigrationsInput<TRes>
    implements CopyWith$Input$AbortQueuedMigrationsInput<TRes> {
  _CopyWithStubImpl$Input$AbortQueuedMigrationsInput(this._res);

  TRes _res;

  call({
    String? ownerId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AcceptEnterpriseAdministratorInvitationInput {
  factory Input$AcceptEnterpriseAdministratorInvitationInput({
    required String invitationId,
    String? clientMutationId,
  }) =>
      Input$AcceptEnterpriseAdministratorInvitationInput._({
        r'invitationId': invitationId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AcceptEnterpriseAdministratorInvitationInput._(this._$data);

  factory Input$AcceptEnterpriseAdministratorInvitationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$invitationId = data['invitationId'];
    result$data['invitationId'] = (l$invitationId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AcceptEnterpriseAdministratorInvitationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get invitationId => (_$data['invitationId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$invitationId = invitationId;
    result$data['invitationId'] = l$invitationId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<
          Input$AcceptEnterpriseAdministratorInvitationInput>
      get copyWith =>
          CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AcceptEnterpriseAdministratorInvitationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$invitationId = invitationId;
    final lOther$invitationId = other.invitationId;
    if (l$invitationId != lOther$invitationId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$invitationId = invitationId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$invitationId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<
    TRes> {
  factory CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput(
    Input$AcceptEnterpriseAdministratorInvitationInput instance,
    TRes Function(Input$AcceptEnterpriseAdministratorInvitationInput) then,
  ) = _CopyWithImpl$Input$AcceptEnterpriseAdministratorInvitationInput;

  factory CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$AcceptEnterpriseAdministratorInvitationInput;

  TRes call({
    String? invitationId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AcceptEnterpriseAdministratorInvitationInput<TRes>
    implements
        CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<TRes> {
  _CopyWithImpl$Input$AcceptEnterpriseAdministratorInvitationInput(
    this._instance,
    this._then,
  );

  final Input$AcceptEnterpriseAdministratorInvitationInput _instance;

  final TRes Function(Input$AcceptEnterpriseAdministratorInvitationInput) _then;

  static const _undefined = {};

  TRes call({
    Object? invitationId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AcceptEnterpriseAdministratorInvitationInput._({
        ..._instance._$data,
        if (invitationId != _undefined && invitationId != null)
          'invitationId': (invitationId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AcceptEnterpriseAdministratorInvitationInput<TRes>
    implements
        CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<TRes> {
  _CopyWithStubImpl$Input$AcceptEnterpriseAdministratorInvitationInput(
      this._res);

  TRes _res;

  call({
    String? invitationId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AcceptTopicSuggestionInput {
  factory Input$AcceptTopicSuggestionInput({
    required String repositoryId,
    required String name,
    String? clientMutationId,
  }) =>
      Input$AcceptTopicSuggestionInput._({
        r'repositoryId': repositoryId,
        r'name': name,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AcceptTopicSuggestionInput._(this._$data);

  factory Input$AcceptTopicSuggestionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AcceptTopicSuggestionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get name => (_$data['name'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AcceptTopicSuggestionInput<Input$AcceptTopicSuggestionInput>
      get copyWith => CopyWith$Input$AcceptTopicSuggestionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AcceptTopicSuggestionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$name,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AcceptTopicSuggestionInput<TRes> {
  factory CopyWith$Input$AcceptTopicSuggestionInput(
    Input$AcceptTopicSuggestionInput instance,
    TRes Function(Input$AcceptTopicSuggestionInput) then,
  ) = _CopyWithImpl$Input$AcceptTopicSuggestionInput;

  factory CopyWith$Input$AcceptTopicSuggestionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AcceptTopicSuggestionInput;

  TRes call({
    String? repositoryId,
    String? name,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AcceptTopicSuggestionInput<TRes>
    implements CopyWith$Input$AcceptTopicSuggestionInput<TRes> {
  _CopyWithImpl$Input$AcceptTopicSuggestionInput(
    this._instance,
    this._then,
  );

  final Input$AcceptTopicSuggestionInput _instance;

  final TRes Function(Input$AcceptTopicSuggestionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AcceptTopicSuggestionInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AcceptTopicSuggestionInput<TRes>
    implements CopyWith$Input$AcceptTopicSuggestionInput<TRes> {
  _CopyWithStubImpl$Input$AcceptTopicSuggestionInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? name,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddAssigneesToAssignableInput {
  factory Input$AddAssigneesToAssignableInput({
    required String assignableId,
    required List<String> assigneeIds,
    String? clientMutationId,
  }) =>
      Input$AddAssigneesToAssignableInput._({
        r'assignableId': assignableId,
        r'assigneeIds': assigneeIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddAssigneesToAssignableInput._(this._$data);

  factory Input$AddAssigneesToAssignableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$assignableId = data['assignableId'];
    result$data['assignableId'] = (l$assignableId as String);
    final l$assigneeIds = data['assigneeIds'];
    result$data['assigneeIds'] =
        (l$assigneeIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddAssigneesToAssignableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get assignableId => (_$data['assignableId'] as String);
  List<String> get assigneeIds => (_$data['assigneeIds'] as List<String>);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$assignableId = assignableId;
    result$data['assignableId'] = l$assignableId;
    final l$assigneeIds = assigneeIds;
    result$data['assigneeIds'] = l$assigneeIds.map((e) => e).toList();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddAssigneesToAssignableInput<
          Input$AddAssigneesToAssignableInput>
      get copyWith => CopyWith$Input$AddAssigneesToAssignableInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddAssigneesToAssignableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$assignableId = assignableId;
    final lOther$assignableId = other.assignableId;
    if (l$assignableId != lOther$assignableId) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (l$assigneeIds.length != lOther$assigneeIds.length) {
      return false;
    }
    for (int i = 0; i < l$assigneeIds.length; i++) {
      final l$assigneeIds$entry = l$assigneeIds[i];
      final lOther$assigneeIds$entry = lOther$assigneeIds[i];
      if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
        return false;
      }
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assignableId = assignableId;
    final l$assigneeIds = assigneeIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$assignableId,
      Object.hashAll(l$assigneeIds.map((v) => v)),
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddAssigneesToAssignableInput<TRes> {
  factory CopyWith$Input$AddAssigneesToAssignableInput(
    Input$AddAssigneesToAssignableInput instance,
    TRes Function(Input$AddAssigneesToAssignableInput) then,
  ) = _CopyWithImpl$Input$AddAssigneesToAssignableInput;

  factory CopyWith$Input$AddAssigneesToAssignableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddAssigneesToAssignableInput;

  TRes call({
    String? assignableId,
    List<String>? assigneeIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddAssigneesToAssignableInput<TRes>
    implements CopyWith$Input$AddAssigneesToAssignableInput<TRes> {
  _CopyWithImpl$Input$AddAssigneesToAssignableInput(
    this._instance,
    this._then,
  );

  final Input$AddAssigneesToAssignableInput _instance;

  final TRes Function(Input$AddAssigneesToAssignableInput) _then;

  static const _undefined = {};

  TRes call({
    Object? assignableId = _undefined,
    Object? assigneeIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddAssigneesToAssignableInput._({
        ..._instance._$data,
        if (assignableId != _undefined && assignableId != null)
          'assignableId': (assignableId as String),
        if (assigneeIds != _undefined && assigneeIds != null)
          'assigneeIds': (assigneeIds as List<String>),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddAssigneesToAssignableInput<TRes>
    implements CopyWith$Input$AddAssigneesToAssignableInput<TRes> {
  _CopyWithStubImpl$Input$AddAssigneesToAssignableInput(this._res);

  TRes _res;

  call({
    String? assignableId,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddCommentInput {
  factory Input$AddCommentInput({
    required String subjectId,
    required String body,
    String? clientMutationId,
  }) =>
      Input$AddCommentInput._({
        r'subjectId': subjectId,
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddCommentInput._(this._$data);

  factory Input$AddCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get subjectId => (_$data['subjectId'] as String);
  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddCommentInput<Input$AddCommentInput> get copyWith =>
      CopyWith$Input$AddCommentInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddCommentInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subjectId = subjectId;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$subjectId,
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddCommentInput<TRes> {
  factory CopyWith$Input$AddCommentInput(
    Input$AddCommentInput instance,
    TRes Function(Input$AddCommentInput) then,
  ) = _CopyWithImpl$Input$AddCommentInput;

  factory CopyWith$Input$AddCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddCommentInput;

  TRes call({
    String? subjectId,
    String? body,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddCommentInput<TRes>
    implements CopyWith$Input$AddCommentInput<TRes> {
  _CopyWithImpl$Input$AddCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddCommentInput _instance;

  final TRes Function(Input$AddCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? subjectId = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddCommentInput._({
        ..._instance._$data,
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddCommentInput<TRes>
    implements CopyWith$Input$AddCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddCommentInput(this._res);

  TRes _res;

  call({
    String? subjectId,
    String? body,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddDiscussionCommentInput {
  factory Input$AddDiscussionCommentInput({
    required String discussionId,
    String? replyToId,
    required String body,
    String? clientMutationId,
  }) =>
      Input$AddDiscussionCommentInput._({
        r'discussionId': discussionId,
        if (replyToId != null) r'replyToId': replyToId,
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddDiscussionCommentInput._(this._$data);

  factory Input$AddDiscussionCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    if (data.containsKey('replyToId')) {
      final l$replyToId = data['replyToId'];
      result$data['replyToId'] = (l$replyToId as String?);
    }
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get discussionId => (_$data['discussionId'] as String);
  String? get replyToId => (_$data['replyToId'] as String?);
  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    if (_$data.containsKey('replyToId')) {
      final l$replyToId = replyToId;
      result$data['replyToId'] = l$replyToId;
    }
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddDiscussionCommentInput<Input$AddDiscussionCommentInput>
      get copyWith => CopyWith$Input$AddDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    final l$replyToId = replyToId;
    final lOther$replyToId = other.replyToId;
    if (_$data.containsKey('replyToId') !=
        other._$data.containsKey('replyToId')) {
      return false;
    }
    if (l$replyToId != lOther$replyToId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$discussionId = discussionId;
    final l$replyToId = replyToId;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$discussionId,
      _$data.containsKey('replyToId') ? l$replyToId : const {},
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddDiscussionCommentInput<TRes> {
  factory CopyWith$Input$AddDiscussionCommentInput(
    Input$AddDiscussionCommentInput instance,
    TRes Function(Input$AddDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$AddDiscussionCommentInput;

  factory CopyWith$Input$AddDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddDiscussionCommentInput;

  TRes call({
    String? discussionId,
    String? replyToId,
    String? body,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddDiscussionCommentInput<TRes>
    implements CopyWith$Input$AddDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$AddDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddDiscussionCommentInput _instance;

  final TRes Function(Input$AddDiscussionCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? discussionId = _undefined,
    Object? replyToId = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddDiscussionCommentInput._({
        ..._instance._$data,
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
        if (replyToId != _undefined) 'replyToId': (replyToId as String?),
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddDiscussionCommentInput<TRes>
    implements CopyWith$Input$AddDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? discussionId,
    String? replyToId,
    String? body,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddDiscussionPollVoteInput {
  factory Input$AddDiscussionPollVoteInput({
    required String pollOptionId,
    String? clientMutationId,
  }) =>
      Input$AddDiscussionPollVoteInput._({
        r'pollOptionId': pollOptionId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddDiscussionPollVoteInput._(this._$data);

  factory Input$AddDiscussionPollVoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pollOptionId = data['pollOptionId'];
    result$data['pollOptionId'] = (l$pollOptionId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddDiscussionPollVoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pollOptionId => (_$data['pollOptionId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pollOptionId = pollOptionId;
    result$data['pollOptionId'] = l$pollOptionId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddDiscussionPollVoteInput<Input$AddDiscussionPollVoteInput>
      get copyWith => CopyWith$Input$AddDiscussionPollVoteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddDiscussionPollVoteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pollOptionId = pollOptionId;
    final lOther$pollOptionId = other.pollOptionId;
    if (l$pollOptionId != lOther$pollOptionId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pollOptionId = pollOptionId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pollOptionId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddDiscussionPollVoteInput<TRes> {
  factory CopyWith$Input$AddDiscussionPollVoteInput(
    Input$AddDiscussionPollVoteInput instance,
    TRes Function(Input$AddDiscussionPollVoteInput) then,
  ) = _CopyWithImpl$Input$AddDiscussionPollVoteInput;

  factory CopyWith$Input$AddDiscussionPollVoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddDiscussionPollVoteInput;

  TRes call({
    String? pollOptionId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddDiscussionPollVoteInput<TRes>
    implements CopyWith$Input$AddDiscussionPollVoteInput<TRes> {
  _CopyWithImpl$Input$AddDiscussionPollVoteInput(
    this._instance,
    this._then,
  );

  final Input$AddDiscussionPollVoteInput _instance;

  final TRes Function(Input$AddDiscussionPollVoteInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pollOptionId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddDiscussionPollVoteInput._({
        ..._instance._$data,
        if (pollOptionId != _undefined && pollOptionId != null)
          'pollOptionId': (pollOptionId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddDiscussionPollVoteInput<TRes>
    implements CopyWith$Input$AddDiscussionPollVoteInput<TRes> {
  _CopyWithStubImpl$Input$AddDiscussionPollVoteInput(this._res);

  TRes _res;

  call({
    String? pollOptionId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddEnterpriseSupportEntitlementInput {
  factory Input$AddEnterpriseSupportEntitlementInput({
    required String enterpriseId,
    required String login,
    String? clientMutationId,
  }) =>
      Input$AddEnterpriseSupportEntitlementInput._({
        r'enterpriseId': enterpriseId,
        r'login': login,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddEnterpriseSupportEntitlementInput._(this._$data);

  factory Input$AddEnterpriseSupportEntitlementInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddEnterpriseSupportEntitlementInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddEnterpriseSupportEntitlementInput<
          Input$AddEnterpriseSupportEntitlementInput>
      get copyWith => CopyWith$Input$AddEnterpriseSupportEntitlementInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddEnterpriseSupportEntitlementInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$login,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddEnterpriseSupportEntitlementInput<TRes> {
  factory CopyWith$Input$AddEnterpriseSupportEntitlementInput(
    Input$AddEnterpriseSupportEntitlementInput instance,
    TRes Function(Input$AddEnterpriseSupportEntitlementInput) then,
  ) = _CopyWithImpl$Input$AddEnterpriseSupportEntitlementInput;

  factory CopyWith$Input$AddEnterpriseSupportEntitlementInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddEnterpriseSupportEntitlementInput;

  TRes call({
    String? enterpriseId,
    String? login,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$AddEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithImpl$Input$AddEnterpriseSupportEntitlementInput(
    this._instance,
    this._then,
  );

  final Input$AddEnterpriseSupportEntitlementInput _instance;

  final TRes Function(Input$AddEnterpriseSupportEntitlementInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddEnterpriseSupportEntitlementInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$AddEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithStubImpl$Input$AddEnterpriseSupportEntitlementInput(this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? login,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddLabelsToLabelableInput {
  factory Input$AddLabelsToLabelableInput({
    required String labelableId,
    required List<String> labelIds,
    String? clientMutationId,
  }) =>
      Input$AddLabelsToLabelableInput._({
        r'labelableId': labelableId,
        r'labelIds': labelIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddLabelsToLabelableInput._(this._$data);

  factory Input$AddLabelsToLabelableInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$labelableId = data['labelableId'];
    result$data['labelableId'] = (l$labelableId as String);
    final l$labelIds = data['labelIds'];
    result$data['labelIds'] =
        (l$labelIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddLabelsToLabelableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get labelableId => (_$data['labelableId'] as String);
  List<String> get labelIds => (_$data['labelIds'] as List<String>);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$labelableId = labelableId;
    result$data['labelableId'] = l$labelableId;
    final l$labelIds = labelIds;
    result$data['labelIds'] = l$labelIds.map((e) => e).toList();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddLabelsToLabelableInput<Input$AddLabelsToLabelableInput>
      get copyWith => CopyWith$Input$AddLabelsToLabelableInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddLabelsToLabelableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$labelableId = labelableId;
    final lOther$labelableId = other.labelableId;
    if (l$labelableId != lOther$labelableId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (l$labelIds.length != lOther$labelIds.length) {
      return false;
    }
    for (int i = 0; i < l$labelIds.length; i++) {
      final l$labelIds$entry = l$labelIds[i];
      final lOther$labelIds$entry = lOther$labelIds[i];
      if (l$labelIds$entry != lOther$labelIds$entry) {
        return false;
      }
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$labelableId = labelableId;
    final l$labelIds = labelIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$labelableId,
      Object.hashAll(l$labelIds.map((v) => v)),
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddLabelsToLabelableInput<TRes> {
  factory CopyWith$Input$AddLabelsToLabelableInput(
    Input$AddLabelsToLabelableInput instance,
    TRes Function(Input$AddLabelsToLabelableInput) then,
  ) = _CopyWithImpl$Input$AddLabelsToLabelableInput;

  factory CopyWith$Input$AddLabelsToLabelableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddLabelsToLabelableInput;

  TRes call({
    String? labelableId,
    List<String>? labelIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddLabelsToLabelableInput<TRes>
    implements CopyWith$Input$AddLabelsToLabelableInput<TRes> {
  _CopyWithImpl$Input$AddLabelsToLabelableInput(
    this._instance,
    this._then,
  );

  final Input$AddLabelsToLabelableInput _instance;

  final TRes Function(Input$AddLabelsToLabelableInput) _then;

  static const _undefined = {};

  TRes call({
    Object? labelableId = _undefined,
    Object? labelIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddLabelsToLabelableInput._({
        ..._instance._$data,
        if (labelableId != _undefined && labelableId != null)
          'labelableId': (labelableId as String),
        if (labelIds != _undefined && labelIds != null)
          'labelIds': (labelIds as List<String>),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddLabelsToLabelableInput<TRes>
    implements CopyWith$Input$AddLabelsToLabelableInput<TRes> {
  _CopyWithStubImpl$Input$AddLabelsToLabelableInput(this._res);

  TRes _res;

  call({
    String? labelableId,
    List<String>? labelIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddProjectCardInput {
  factory Input$AddProjectCardInput({
    required String projectColumnId,
    String? contentId,
    String? note,
    String? clientMutationId,
  }) =>
      Input$AddProjectCardInput._({
        r'projectColumnId': projectColumnId,
        if (contentId != null) r'contentId': contentId,
        if (note != null) r'note': note,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddProjectCardInput._(this._$data);

  factory Input$AddProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectColumnId = data['projectColumnId'];
    result$data['projectColumnId'] = (l$projectColumnId as String);
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = (l$contentId as String?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectColumnId => (_$data['projectColumnId'] as String);
  String? get contentId => (_$data['contentId'] as String?);
  String? get note => (_$data['note'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectColumnId = projectColumnId;
    result$data['projectColumnId'] = l$projectColumnId;
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddProjectCardInput<Input$AddProjectCardInput> get copyWith =>
      CopyWith$Input$AddProjectCardInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddProjectCardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectColumnId = projectColumnId;
    final lOther$projectColumnId = other.projectColumnId;
    if (l$projectColumnId != lOther$projectColumnId) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectColumnId = projectColumnId;
    final l$contentId = contentId;
    final l$note = note;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectColumnId,
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddProjectCardInput<TRes> {
  factory CopyWith$Input$AddProjectCardInput(
    Input$AddProjectCardInput instance,
    TRes Function(Input$AddProjectCardInput) then,
  ) = _CopyWithImpl$Input$AddProjectCardInput;

  factory CopyWith$Input$AddProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectCardInput;

  TRes call({
    String? projectColumnId,
    String? contentId,
    String? note,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddProjectCardInput<TRes>
    implements CopyWith$Input$AddProjectCardInput<TRes> {
  _CopyWithImpl$Input$AddProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectCardInput _instance;

  final TRes Function(Input$AddProjectCardInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectColumnId = _undefined,
    Object? contentId = _undefined,
    Object? note = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddProjectCardInput._({
        ..._instance._$data,
        if (projectColumnId != _undefined && projectColumnId != null)
          'projectColumnId': (projectColumnId as String),
        if (contentId != _undefined) 'contentId': (contentId as String?),
        if (note != _undefined) 'note': (note as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddProjectCardInput<TRes>
    implements CopyWith$Input$AddProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectCardInput(this._res);

  TRes _res;

  call({
    String? projectColumnId,
    String? contentId,
    String? note,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddProjectColumnInput {
  factory Input$AddProjectColumnInput({
    required String projectId,
    required String name,
    String? clientMutationId,
  }) =>
      Input$AddProjectColumnInput._({
        r'projectId': projectId,
        r'name': name,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddProjectColumnInput._(this._$data);

  factory Input$AddProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get name => (_$data['name'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddProjectColumnInput<Input$AddProjectColumnInput>
      get copyWith => CopyWith$Input$AddProjectColumnInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddProjectColumnInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$name = name;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$name,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddProjectColumnInput<TRes> {
  factory CopyWith$Input$AddProjectColumnInput(
    Input$AddProjectColumnInput instance,
    TRes Function(Input$AddProjectColumnInput) then,
  ) = _CopyWithImpl$Input$AddProjectColumnInput;

  factory CopyWith$Input$AddProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectColumnInput;

  TRes call({
    String? projectId,
    String? name,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddProjectColumnInput<TRes>
    implements CopyWith$Input$AddProjectColumnInput<TRes> {
  _CopyWithImpl$Input$AddProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectColumnInput _instance;

  final TRes Function(Input$AddProjectColumnInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? name = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddProjectColumnInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddProjectColumnInput<TRes>
    implements CopyWith$Input$AddProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectColumnInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? name,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddProjectDraftIssueInput {
  factory Input$AddProjectDraftIssueInput({
    String? projectId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      Input$AddProjectDraftIssueInput._({
        if (projectId != null) r'projectId': projectId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddProjectDraftIssueInput._(this._$data);

  factory Input$AddProjectDraftIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('projectId')) {
      final l$projectId = data['projectId'];
      result$data['projectId'] = (l$projectId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddProjectDraftIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get projectId => (_$data['projectId'] as String?);
  String? get title => (_$data['title'] as String?);
  String? get body => (_$data['body'] as String?);
  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('projectId')) {
      final l$projectId = projectId;
      result$data['projectId'] = l$projectId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddProjectDraftIssueInput<Input$AddProjectDraftIssueInput>
      get copyWith => CopyWith$Input$AddProjectDraftIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddProjectDraftIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (_$data.containsKey('projectId') !=
        other._$data.containsKey('projectId')) {
      return false;
    }
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$title = title;
    final l$body = body;
    final l$assigneeIds = assigneeIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('projectId') ? l$projectId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddProjectDraftIssueInput<TRes> {
  factory CopyWith$Input$AddProjectDraftIssueInput(
    Input$AddProjectDraftIssueInput instance,
    TRes Function(Input$AddProjectDraftIssueInput) then,
  ) = _CopyWithImpl$Input$AddProjectDraftIssueInput;

  factory CopyWith$Input$AddProjectDraftIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectDraftIssueInput;

  TRes call({
    String? projectId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddProjectDraftIssueInput<TRes>
    implements CopyWith$Input$AddProjectDraftIssueInput<TRes> {
  _CopyWithImpl$Input$AddProjectDraftIssueInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectDraftIssueInput _instance;

  final TRes Function(Input$AddProjectDraftIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? assigneeIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddProjectDraftIssueInput._({
        ..._instance._$data,
        if (projectId != _undefined) 'projectId': (projectId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddProjectDraftIssueInput<TRes>
    implements CopyWith$Input$AddProjectDraftIssueInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectDraftIssueInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddProjectNextItemInput {
  factory Input$AddProjectNextItemInput({
    String? projectId,
    String? contentId,
    String? clientMutationId,
  }) =>
      Input$AddProjectNextItemInput._({
        if (projectId != null) r'projectId': projectId,
        if (contentId != null) r'contentId': contentId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddProjectNextItemInput._(this._$data);

  factory Input$AddProjectNextItemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('projectId')) {
      final l$projectId = data['projectId'];
      result$data['projectId'] = (l$projectId as String?);
    }
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = (l$contentId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddProjectNextItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get projectId => (_$data['projectId'] as String?);
  String? get contentId => (_$data['contentId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('projectId')) {
      final l$projectId = projectId;
      result$data['projectId'] = l$projectId;
    }
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddProjectNextItemInput<Input$AddProjectNextItemInput>
      get copyWith => CopyWith$Input$AddProjectNextItemInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddProjectNextItemInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (_$data.containsKey('projectId') !=
        other._$data.containsKey('projectId')) {
      return false;
    }
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$contentId = contentId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('projectId') ? l$projectId : const {},
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddProjectNextItemInput<TRes> {
  factory CopyWith$Input$AddProjectNextItemInput(
    Input$AddProjectNextItemInput instance,
    TRes Function(Input$AddProjectNextItemInput) then,
  ) = _CopyWithImpl$Input$AddProjectNextItemInput;

  factory CopyWith$Input$AddProjectNextItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectNextItemInput;

  TRes call({
    String? projectId,
    String? contentId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddProjectNextItemInput<TRes>
    implements CopyWith$Input$AddProjectNextItemInput<TRes> {
  _CopyWithImpl$Input$AddProjectNextItemInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectNextItemInput _instance;

  final TRes Function(Input$AddProjectNextItemInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? contentId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddProjectNextItemInput._({
        ..._instance._$data,
        if (projectId != _undefined) 'projectId': (projectId as String?),
        if (contentId != _undefined) 'contentId': (contentId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddProjectNextItemInput<TRes>
    implements CopyWith$Input$AddProjectNextItemInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectNextItemInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? contentId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddProjectV2DraftIssueInput {
  factory Input$AddProjectV2DraftIssueInput({
    required String projectId,
    required String title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      Input$AddProjectV2DraftIssueInput._({
        r'projectId': projectId,
        r'title': title,
        if (body != null) r'body': body,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddProjectV2DraftIssueInput._(this._$data);

  factory Input$AddProjectV2DraftIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddProjectV2DraftIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get title => (_$data['title'] as String);
  String? get body => (_$data['body'] as String?);
  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddProjectV2DraftIssueInput<Input$AddProjectV2DraftIssueInput>
      get copyWith => CopyWith$Input$AddProjectV2DraftIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddProjectV2DraftIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$title = title;
    final l$body = body;
    final l$assigneeIds = assigneeIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$title,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddProjectV2DraftIssueInput<TRes> {
  factory CopyWith$Input$AddProjectV2DraftIssueInput(
    Input$AddProjectV2DraftIssueInput instance,
    TRes Function(Input$AddProjectV2DraftIssueInput) then,
  ) = _CopyWithImpl$Input$AddProjectV2DraftIssueInput;

  factory CopyWith$Input$AddProjectV2DraftIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectV2DraftIssueInput;

  TRes call({
    String? projectId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$AddProjectV2DraftIssueInput<TRes> {
  _CopyWithImpl$Input$AddProjectV2DraftIssueInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectV2DraftIssueInput _instance;

  final TRes Function(Input$AddProjectV2DraftIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? assigneeIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddProjectV2DraftIssueInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (body != _undefined) 'body': (body as String?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$AddProjectV2DraftIssueInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectV2DraftIssueInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddProjectV2ItemByIdInput {
  factory Input$AddProjectV2ItemByIdInput({
    required String projectId,
    required String contentId,
    String? clientMutationId,
  }) =>
      Input$AddProjectV2ItemByIdInput._({
        r'projectId': projectId,
        r'contentId': contentId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddProjectV2ItemByIdInput._(this._$data);

  factory Input$AddProjectV2ItemByIdInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$contentId = data['contentId'];
    result$data['contentId'] = (l$contentId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddProjectV2ItemByIdInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get contentId => (_$data['contentId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$contentId = contentId;
    result$data['contentId'] = l$contentId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddProjectV2ItemByIdInput<Input$AddProjectV2ItemByIdInput>
      get copyWith => CopyWith$Input$AddProjectV2ItemByIdInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddProjectV2ItemByIdInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$contentId = contentId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$contentId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddProjectV2ItemByIdInput<TRes> {
  factory CopyWith$Input$AddProjectV2ItemByIdInput(
    Input$AddProjectV2ItemByIdInput instance,
    TRes Function(Input$AddProjectV2ItemByIdInput) then,
  ) = _CopyWithImpl$Input$AddProjectV2ItemByIdInput;

  factory CopyWith$Input$AddProjectV2ItemByIdInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectV2ItemByIdInput;

  TRes call({
    String? projectId,
    String? contentId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddProjectV2ItemByIdInput<TRes>
    implements CopyWith$Input$AddProjectV2ItemByIdInput<TRes> {
  _CopyWithImpl$Input$AddProjectV2ItemByIdInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectV2ItemByIdInput _instance;

  final TRes Function(Input$AddProjectV2ItemByIdInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? contentId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddProjectV2ItemByIdInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (contentId != _undefined && contentId != null)
          'contentId': (contentId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddProjectV2ItemByIdInput<TRes>
    implements CopyWith$Input$AddProjectV2ItemByIdInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectV2ItemByIdInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? contentId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddPullRequestReviewCommentInput {
  factory Input$AddPullRequestReviewCommentInput({
    String? pullRequestId,
    String? pullRequestReviewId,
    String? commitOID,
    required String body,
    String? path,
    int? position,
    String? inReplyTo,
    String? clientMutationId,
  }) =>
      Input$AddPullRequestReviewCommentInput._({
        if (pullRequestId != null) r'pullRequestId': pullRequestId,
        if (pullRequestReviewId != null)
          r'pullRequestReviewId': pullRequestReviewId,
        if (commitOID != null) r'commitOID': commitOID,
        r'body': body,
        if (path != null) r'path': path,
        if (position != null) r'position': position,
        if (inReplyTo != null) r'inReplyTo': inReplyTo,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddPullRequestReviewCommentInput._(this._$data);

  factory Input$AddPullRequestReviewCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('pullRequestId')) {
      final l$pullRequestId = data['pullRequestId'];
      result$data['pullRequestId'] = (l$pullRequestId as String?);
    }
    if (data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = data['pullRequestReviewId'];
      result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String?);
    }
    if (data.containsKey('commitOID')) {
      final l$commitOID = data['commitOID'];
      result$data['commitOID'] = (l$commitOID as String?);
    }
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = (l$path as String?);
    }
    if (data.containsKey('position')) {
      final l$position = data['position'];
      result$data['position'] = (l$position as int?);
    }
    if (data.containsKey('inReplyTo')) {
      final l$inReplyTo = data['inReplyTo'];
      result$data['inReplyTo'] = (l$inReplyTo as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddPullRequestReviewCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get pullRequestId => (_$data['pullRequestId'] as String?);
  String? get pullRequestReviewId => (_$data['pullRequestReviewId'] as String?);
  String? get commitOID => (_$data['commitOID'] as String?);
  String get body => (_$data['body'] as String);
  String? get path => (_$data['path'] as String?);
  int? get position => (_$data['position'] as int?);
  String? get inReplyTo => (_$data['inReplyTo'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('pullRequestId')) {
      final l$pullRequestId = pullRequestId;
      result$data['pullRequestId'] = l$pullRequestId;
    }
    if (_$data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = pullRequestReviewId;
      result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    }
    if (_$data.containsKey('commitOID')) {
      final l$commitOID = commitOID;
      result$data['commitOID'] = l$commitOID;
    }
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path;
    }
    if (_$data.containsKey('position')) {
      final l$position = position;
      result$data['position'] = l$position;
    }
    if (_$data.containsKey('inReplyTo')) {
      final l$inReplyTo = inReplyTo;
      result$data['inReplyTo'] = l$inReplyTo;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddPullRequestReviewCommentInput<
          Input$AddPullRequestReviewCommentInput>
      get copyWith => CopyWith$Input$AddPullRequestReviewCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddPullRequestReviewCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (_$data.containsKey('pullRequestId') !=
        other._$data.containsKey('pullRequestId')) {
      return false;
    }
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (_$data.containsKey('pullRequestReviewId') !=
        other._$data.containsKey('pullRequestReviewId')) {
      return false;
    }
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$commitOID = commitOID;
    final lOther$commitOID = other.commitOID;
    if (_$data.containsKey('commitOID') !=
        other._$data.containsKey('commitOID')) {
      return false;
    }
    if (l$commitOID != lOther$commitOID) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (_$data.containsKey('position') !=
        other._$data.containsKey('position')) {
      return false;
    }
    if (l$position != lOther$position) {
      return false;
    }
    final l$inReplyTo = inReplyTo;
    final lOther$inReplyTo = other.inReplyTo;
    if (_$data.containsKey('inReplyTo') !=
        other._$data.containsKey('inReplyTo')) {
      return false;
    }
    if (l$inReplyTo != lOther$inReplyTo) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$commitOID = commitOID;
    final l$body = body;
    final l$path = path;
    final l$position = position;
    final l$inReplyTo = inReplyTo;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('pullRequestId') ? l$pullRequestId : const {},
      _$data.containsKey('pullRequestReviewId')
          ? l$pullRequestReviewId
          : const {},
      _$data.containsKey('commitOID') ? l$commitOID : const {},
      l$body,
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('position') ? l$position : const {},
      _$data.containsKey('inReplyTo') ? l$inReplyTo : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddPullRequestReviewCommentInput<TRes> {
  factory CopyWith$Input$AddPullRequestReviewCommentInput(
    Input$AddPullRequestReviewCommentInput instance,
    TRes Function(Input$AddPullRequestReviewCommentInput) then,
  ) = _CopyWithImpl$Input$AddPullRequestReviewCommentInput;

  factory CopyWith$Input$AddPullRequestReviewCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddPullRequestReviewCommentInput;

  TRes call({
    String? pullRequestId,
    String? pullRequestReviewId,
    String? commitOID,
    String? body,
    String? path,
    int? position,
    String? inReplyTo,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddPullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewCommentInput<TRes> {
  _CopyWithImpl$Input$AddPullRequestReviewCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddPullRequestReviewCommentInput _instance;

  final TRes Function(Input$AddPullRequestReviewCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? pullRequestReviewId = _undefined,
    Object? commitOID = _undefined,
    Object? body = _undefined,
    Object? path = _undefined,
    Object? position = _undefined,
    Object? inReplyTo = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddPullRequestReviewCommentInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined)
          'pullRequestId': (pullRequestId as String?),
        if (pullRequestReviewId != _undefined)
          'pullRequestReviewId': (pullRequestReviewId as String?),
        if (commitOID != _undefined) 'commitOID': (commitOID as String?),
        if (body != _undefined && body != null) 'body': (body as String),
        if (path != _undefined) 'path': (path as String?),
        if (position != _undefined) 'position': (position as int?),
        if (inReplyTo != _undefined) 'inReplyTo': (inReplyTo as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddPullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddPullRequestReviewCommentInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? pullRequestReviewId,
    String? commitOID,
    String? body,
    String? path,
    int? position,
    String? inReplyTo,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddPullRequestReviewInput {
  factory Input$AddPullRequestReviewInput({
    required String pullRequestId,
    String? commitOID,
    String? body,
    Enum$PullRequestReviewEvent? event,
    List<Input$DraftPullRequestReviewComment?>? comments,
    List<Input$DraftPullRequestReviewThread?>? threads,
    String? clientMutationId,
  }) =>
      Input$AddPullRequestReviewInput._({
        r'pullRequestId': pullRequestId,
        if (commitOID != null) r'commitOID': commitOID,
        if (body != null) r'body': body,
        if (event != null) r'event': event,
        if (comments != null) r'comments': comments,
        if (threads != null) r'threads': threads,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddPullRequestReviewInput._(this._$data);

  factory Input$AddPullRequestReviewInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('commitOID')) {
      final l$commitOID = data['commitOID'];
      result$data['commitOID'] = (l$commitOID as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('event')) {
      final l$event = data['event'];
      result$data['event'] = l$event == null
          ? null
          : fromJson$Enum$PullRequestReviewEvent((l$event as String));
    }
    if (data.containsKey('comments')) {
      final l$comments = data['comments'];
      result$data['comments'] = (l$comments as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$DraftPullRequestReviewComment.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('threads')) {
      final l$threads = data['threads'];
      result$data['threads'] = (l$threads as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$DraftPullRequestReviewThread.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddPullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String? get commitOID => (_$data['commitOID'] as String?);
  String? get body => (_$data['body'] as String?);
  Enum$PullRequestReviewEvent? get event =>
      (_$data['event'] as Enum$PullRequestReviewEvent?);
  List<Input$DraftPullRequestReviewComment?>? get comments =>
      (_$data['comments'] as List<Input$DraftPullRequestReviewComment?>?);
  List<Input$DraftPullRequestReviewThread?>? get threads =>
      (_$data['threads'] as List<Input$DraftPullRequestReviewThread?>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('commitOID')) {
      final l$commitOID = commitOID;
      result$data['commitOID'] = l$commitOID;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('event')) {
      final l$event = event;
      result$data['event'] =
          l$event == null ? null : toJson$Enum$PullRequestReviewEvent(l$event);
    }
    if (_$data.containsKey('comments')) {
      final l$comments = comments;
      result$data['comments'] = l$comments?.map((e) => e?.toJson()).toList();
    }
    if (_$data.containsKey('threads')) {
      final l$threads = threads;
      result$data['threads'] = l$threads?.map((e) => e?.toJson()).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddPullRequestReviewInput<Input$AddPullRequestReviewInput>
      get copyWith => CopyWith$Input$AddPullRequestReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddPullRequestReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$commitOID = commitOID;
    final lOther$commitOID = other.commitOID;
    if (_$data.containsKey('commitOID') !=
        other._$data.containsKey('commitOID')) {
      return false;
    }
    if (l$commitOID != lOther$commitOID) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (_$data.containsKey('event') != other._$data.containsKey('event')) {
      return false;
    }
    if (l$event != lOther$event) {
      return false;
    }
    final l$comments = comments;
    final lOther$comments = other.comments;
    if (_$data.containsKey('comments') !=
        other._$data.containsKey('comments')) {
      return false;
    }
    if (l$comments != null && lOther$comments != null) {
      if (l$comments.length != lOther$comments.length) {
        return false;
      }
      for (int i = 0; i < l$comments.length; i++) {
        final l$comments$entry = l$comments[i];
        final lOther$comments$entry = lOther$comments[i];
        if (l$comments$entry != lOther$comments$entry) {
          return false;
        }
      }
    } else if (l$comments != lOther$comments) {
      return false;
    }
    final l$threads = threads;
    final lOther$threads = other.threads;
    if (_$data.containsKey('threads') != other._$data.containsKey('threads')) {
      return false;
    }
    if (l$threads != null && lOther$threads != null) {
      if (l$threads.length != lOther$threads.length) {
        return false;
      }
      for (int i = 0; i < l$threads.length; i++) {
        final l$threads$entry = l$threads[i];
        final lOther$threads$entry = lOther$threads[i];
        if (l$threads$entry != lOther$threads$entry) {
          return false;
        }
      }
    } else if (l$threads != lOther$threads) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$commitOID = commitOID;
    final l$body = body;
    final l$event = event;
    final l$comments = comments;
    final l$threads = threads;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      _$data.containsKey('commitOID') ? l$commitOID : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('event') ? l$event : const {},
      _$data.containsKey('comments')
          ? l$comments == null
              ? null
              : Object.hashAll(l$comments.map((v) => v))
          : const {},
      _$data.containsKey('threads')
          ? l$threads == null
              ? null
              : Object.hashAll(l$threads.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddPullRequestReviewInput<TRes> {
  factory CopyWith$Input$AddPullRequestReviewInput(
    Input$AddPullRequestReviewInput instance,
    TRes Function(Input$AddPullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$AddPullRequestReviewInput;

  factory CopyWith$Input$AddPullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddPullRequestReviewInput;

  TRes call({
    String? pullRequestId,
    String? commitOID,
    String? body,
    Enum$PullRequestReviewEvent? event,
    List<Input$DraftPullRequestReviewComment?>? comments,
    List<Input$DraftPullRequestReviewThread?>? threads,
    String? clientMutationId,
  });
  TRes comments(
      Iterable<Input$DraftPullRequestReviewComment?>? Function(
              Iterable<
                  CopyWith$Input$DraftPullRequestReviewComment<
                      Input$DraftPullRequestReviewComment>?>?)
          _fn);
  TRes threads(
      Iterable<Input$DraftPullRequestReviewThread?>? Function(
              Iterable<
                  CopyWith$Input$DraftPullRequestReviewThread<
                      Input$DraftPullRequestReviewThread>?>?)
          _fn);
}

class _CopyWithImpl$Input$AddPullRequestReviewInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$AddPullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$AddPullRequestReviewInput _instance;

  final TRes Function(Input$AddPullRequestReviewInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? commitOID = _undefined,
    Object? body = _undefined,
    Object? event = _undefined,
    Object? comments = _undefined,
    Object? threads = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddPullRequestReviewInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (commitOID != _undefined) 'commitOID': (commitOID as String?),
        if (body != _undefined) 'body': (body as String?),
        if (event != _undefined)
          'event': (event as Enum$PullRequestReviewEvent?),
        if (comments != _undefined)
          'comments': (comments as List<Input$DraftPullRequestReviewComment?>?),
        if (threads != _undefined)
          'threads': (threads as List<Input$DraftPullRequestReviewThread?>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
  TRes comments(
          Iterable<Input$DraftPullRequestReviewComment?>? Function(
                  Iterable<
                      CopyWith$Input$DraftPullRequestReviewComment<
                          Input$DraftPullRequestReviewComment>?>?)
              _fn) =>
      call(
          comments: _fn(_instance.comments?.map((e) => e == null
              ? null
              : CopyWith$Input$DraftPullRequestReviewComment(
                  e,
                  (i) => i,
                )))?.toList());
  TRes threads(
          Iterable<Input$DraftPullRequestReviewThread?>? Function(
                  Iterable<
                      CopyWith$Input$DraftPullRequestReviewThread<
                          Input$DraftPullRequestReviewThread>?>?)
              _fn) =>
      call(
          threads: _fn(_instance.threads?.map((e) => e == null
              ? null
              : CopyWith$Input$DraftPullRequestReviewThread(
                  e,
                  (i) => i,
                )))?.toList());
}

class _CopyWithStubImpl$Input$AddPullRequestReviewInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$AddPullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? commitOID,
    String? body,
    Enum$PullRequestReviewEvent? event,
    List<Input$DraftPullRequestReviewComment?>? comments,
    List<Input$DraftPullRequestReviewThread?>? threads,
    String? clientMutationId,
  }) =>
      _res;
  comments(_fn) => _res;
  threads(_fn) => _res;
}

class Input$AddPullRequestReviewThreadInput {
  factory Input$AddPullRequestReviewThreadInput({
    required String path,
    required String body,
    String? pullRequestId,
    String? pullRequestReviewId,
    required int line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    String? clientMutationId,
  }) =>
      Input$AddPullRequestReviewThreadInput._({
        r'path': path,
        r'body': body,
        if (pullRequestId != null) r'pullRequestId': pullRequestId,
        if (pullRequestReviewId != null)
          r'pullRequestReviewId': pullRequestReviewId,
        r'line': line,
        if (side != null) r'side': side,
        if (startLine != null) r'startLine': startLine,
        if (startSide != null) r'startSide': startSide,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddPullRequestReviewThreadInput._(this._$data);

  factory Input$AddPullRequestReviewThreadInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('pullRequestId')) {
      final l$pullRequestId = data['pullRequestId'];
      result$data['pullRequestId'] = (l$pullRequestId as String?);
    }
    if (data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = data['pullRequestReviewId'];
      result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String?);
    }
    final l$line = data['line'];
    result$data['line'] = (l$line as int);
    if (data.containsKey('side')) {
      final l$side = data['side'];
      result$data['side'] =
          l$side == null ? null : fromJson$Enum$DiffSide((l$side as String));
    }
    if (data.containsKey('startLine')) {
      final l$startLine = data['startLine'];
      result$data['startLine'] = (l$startLine as int?);
    }
    if (data.containsKey('startSide')) {
      final l$startSide = data['startSide'];
      result$data['startSide'] = l$startSide == null
          ? null
          : fromJson$Enum$DiffSide((l$startSide as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddPullRequestReviewThreadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  String get body => (_$data['body'] as String);
  String? get pullRequestId => (_$data['pullRequestId'] as String?);
  String? get pullRequestReviewId => (_$data['pullRequestReviewId'] as String?);
  int get line => (_$data['line'] as int);
  Enum$DiffSide? get side => (_$data['side'] as Enum$DiffSide?);
  int? get startLine => (_$data['startLine'] as int?);
  Enum$DiffSide? get startSide => (_$data['startSide'] as Enum$DiffSide?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('pullRequestId')) {
      final l$pullRequestId = pullRequestId;
      result$data['pullRequestId'] = l$pullRequestId;
    }
    if (_$data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = pullRequestReviewId;
      result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    }
    final l$line = line;
    result$data['line'] = l$line;
    if (_$data.containsKey('side')) {
      final l$side = side;
      result$data['side'] =
          l$side == null ? null : toJson$Enum$DiffSide(l$side);
    }
    if (_$data.containsKey('startLine')) {
      final l$startLine = startLine;
      result$data['startLine'] = l$startLine;
    }
    if (_$data.containsKey('startSide')) {
      final l$startSide = startSide;
      result$data['startSide'] =
          l$startSide == null ? null : toJson$Enum$DiffSide(l$startSide);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddPullRequestReviewThreadInput<
          Input$AddPullRequestReviewThreadInput>
      get copyWith => CopyWith$Input$AddPullRequestReviewThreadInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddPullRequestReviewThreadInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (_$data.containsKey('pullRequestId') !=
        other._$data.containsKey('pullRequestId')) {
      return false;
    }
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (_$data.containsKey('pullRequestReviewId') !=
        other._$data.containsKey('pullRequestReviewId')) {
      return false;
    }
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$line = line;
    final lOther$line = other.line;
    if (l$line != lOther$line) {
      return false;
    }
    final l$side = side;
    final lOther$side = other.side;
    if (_$data.containsKey('side') != other._$data.containsKey('side')) {
      return false;
    }
    if (l$side != lOther$side) {
      return false;
    }
    final l$startLine = startLine;
    final lOther$startLine = other.startLine;
    if (_$data.containsKey('startLine') !=
        other._$data.containsKey('startLine')) {
      return false;
    }
    if (l$startLine != lOther$startLine) {
      return false;
    }
    final l$startSide = startSide;
    final lOther$startSide = other.startSide;
    if (_$data.containsKey('startSide') !=
        other._$data.containsKey('startSide')) {
      return false;
    }
    if (l$startSide != lOther$startSide) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$body = body;
    final l$pullRequestId = pullRequestId;
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$line = line;
    final l$side = side;
    final l$startLine = startLine;
    final l$startSide = startSide;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$path,
      l$body,
      _$data.containsKey('pullRequestId') ? l$pullRequestId : const {},
      _$data.containsKey('pullRequestReviewId')
          ? l$pullRequestReviewId
          : const {},
      l$line,
      _$data.containsKey('side') ? l$side : const {},
      _$data.containsKey('startLine') ? l$startLine : const {},
      _$data.containsKey('startSide') ? l$startSide : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddPullRequestReviewThreadInput<TRes> {
  factory CopyWith$Input$AddPullRequestReviewThreadInput(
    Input$AddPullRequestReviewThreadInput instance,
    TRes Function(Input$AddPullRequestReviewThreadInput) then,
  ) = _CopyWithImpl$Input$AddPullRequestReviewThreadInput;

  factory CopyWith$Input$AddPullRequestReviewThreadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddPullRequestReviewThreadInput;

  TRes call({
    String? path,
    String? body,
    String? pullRequestId,
    String? pullRequestReviewId,
    int? line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddPullRequestReviewThreadInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewThreadInput<TRes> {
  _CopyWithImpl$Input$AddPullRequestReviewThreadInput(
    this._instance,
    this._then,
  );

  final Input$AddPullRequestReviewThreadInput _instance;

  final TRes Function(Input$AddPullRequestReviewThreadInput) _then;

  static const _undefined = {};

  TRes call({
    Object? path = _undefined,
    Object? body = _undefined,
    Object? pullRequestId = _undefined,
    Object? pullRequestReviewId = _undefined,
    Object? line = _undefined,
    Object? side = _undefined,
    Object? startLine = _undefined,
    Object? startSide = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddPullRequestReviewThreadInput._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (pullRequestId != _undefined)
          'pullRequestId': (pullRequestId as String?),
        if (pullRequestReviewId != _undefined)
          'pullRequestReviewId': (pullRequestReviewId as String?),
        if (line != _undefined && line != null) 'line': (line as int),
        if (side != _undefined) 'side': (side as Enum$DiffSide?),
        if (startLine != _undefined) 'startLine': (startLine as int?),
        if (startSide != _undefined) 'startSide': (startSide as Enum$DiffSide?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddPullRequestReviewThreadInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewThreadInput<TRes> {
  _CopyWithStubImpl$Input$AddPullRequestReviewThreadInput(this._res);

  TRes _res;

  call({
    String? path,
    String? body,
    String? pullRequestId,
    String? pullRequestReviewId,
    int? line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddReactionInput {
  factory Input$AddReactionInput({
    required String subjectId,
    required Enum$ReactionContent content,
    String? clientMutationId,
  }) =>
      Input$AddReactionInput._({
        r'subjectId': subjectId,
        r'content': content,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddReactionInput._(this._$data);

  factory Input$AddReactionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    final l$content = data['content'];
    result$data['content'] =
        fromJson$Enum$ReactionContent((l$content as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddReactionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get subjectId => (_$data['subjectId'] as String);
  Enum$ReactionContent get content =>
      (_$data['content'] as Enum$ReactionContent);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    final l$content = content;
    result$data['content'] = toJson$Enum$ReactionContent(l$content);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddReactionInput<Input$AddReactionInput> get copyWith =>
      CopyWith$Input$AddReactionInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddReactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subjectId = subjectId;
    final l$content = content;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$subjectId,
      l$content,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddReactionInput<TRes> {
  factory CopyWith$Input$AddReactionInput(
    Input$AddReactionInput instance,
    TRes Function(Input$AddReactionInput) then,
  ) = _CopyWithImpl$Input$AddReactionInput;

  factory CopyWith$Input$AddReactionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddReactionInput;

  TRes call({
    String? subjectId,
    Enum$ReactionContent? content,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddReactionInput<TRes>
    implements CopyWith$Input$AddReactionInput<TRes> {
  _CopyWithImpl$Input$AddReactionInput(
    this._instance,
    this._then,
  );

  final Input$AddReactionInput _instance;

  final TRes Function(Input$AddReactionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? subjectId = _undefined,
    Object? content = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddReactionInput._({
        ..._instance._$data,
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
        if (content != _undefined && content != null)
          'content': (content as Enum$ReactionContent),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddReactionInput<TRes>
    implements CopyWith$Input$AddReactionInput<TRes> {
  _CopyWithStubImpl$Input$AddReactionInput(this._res);

  TRes _res;

  call({
    String? subjectId,
    Enum$ReactionContent? content,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddStarInput {
  factory Input$AddStarInput({
    required String starrableId,
    String? clientMutationId,
  }) =>
      Input$AddStarInput._({
        r'starrableId': starrableId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddStarInput._(this._$data);

  factory Input$AddStarInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$starrableId = data['starrableId'];
    result$data['starrableId'] = (l$starrableId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddStarInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get starrableId => (_$data['starrableId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$starrableId = starrableId;
    result$data['starrableId'] = l$starrableId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddStarInput<Input$AddStarInput> get copyWith =>
      CopyWith$Input$AddStarInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddStarInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$starrableId = starrableId;
    final lOther$starrableId = other.starrableId;
    if (l$starrableId != lOther$starrableId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$starrableId = starrableId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$starrableId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddStarInput<TRes> {
  factory CopyWith$Input$AddStarInput(
    Input$AddStarInput instance,
    TRes Function(Input$AddStarInput) then,
  ) = _CopyWithImpl$Input$AddStarInput;

  factory CopyWith$Input$AddStarInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddStarInput;

  TRes call({
    String? starrableId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddStarInput<TRes>
    implements CopyWith$Input$AddStarInput<TRes> {
  _CopyWithImpl$Input$AddStarInput(
    this._instance,
    this._then,
  );

  final Input$AddStarInput _instance;

  final TRes Function(Input$AddStarInput) _then;

  static const _undefined = {};

  TRes call({
    Object? starrableId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddStarInput._({
        ..._instance._$data,
        if (starrableId != _undefined && starrableId != null)
          'starrableId': (starrableId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddStarInput<TRes>
    implements CopyWith$Input$AddStarInput<TRes> {
  _CopyWithStubImpl$Input$AddStarInput(this._res);

  TRes _res;

  call({
    String? starrableId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddUpvoteInput {
  factory Input$AddUpvoteInput({
    required String subjectId,
    String? clientMutationId,
  }) =>
      Input$AddUpvoteInput._({
        r'subjectId': subjectId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddUpvoteInput._(this._$data);

  factory Input$AddUpvoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddUpvoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get subjectId => (_$data['subjectId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddUpvoteInput<Input$AddUpvoteInput> get copyWith =>
      CopyWith$Input$AddUpvoteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddUpvoteInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subjectId = subjectId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$subjectId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddUpvoteInput<TRes> {
  factory CopyWith$Input$AddUpvoteInput(
    Input$AddUpvoteInput instance,
    TRes Function(Input$AddUpvoteInput) then,
  ) = _CopyWithImpl$Input$AddUpvoteInput;

  factory CopyWith$Input$AddUpvoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddUpvoteInput;

  TRes call({
    String? subjectId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddUpvoteInput<TRes>
    implements CopyWith$Input$AddUpvoteInput<TRes> {
  _CopyWithImpl$Input$AddUpvoteInput(
    this._instance,
    this._then,
  );

  final Input$AddUpvoteInput _instance;

  final TRes Function(Input$AddUpvoteInput) _then;

  static const _undefined = {};

  TRes call({
    Object? subjectId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddUpvoteInput._({
        ..._instance._$data,
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddUpvoteInput<TRes>
    implements CopyWith$Input$AddUpvoteInput<TRes> {
  _CopyWithStubImpl$Input$AddUpvoteInput(this._res);

  TRes _res;

  call({
    String? subjectId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddVerifiableDomainInput {
  factory Input$AddVerifiableDomainInput({
    required String ownerId,
    required String domain,
    String? clientMutationId,
  }) =>
      Input$AddVerifiableDomainInput._({
        r'ownerId': ownerId,
        r'domain': domain,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddVerifiableDomainInput._(this._$data);

  factory Input$AddVerifiableDomainInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$domain = data['domain'];
    result$data['domain'] = (l$domain as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get ownerId => (_$data['ownerId'] as String);
  String get domain => (_$data['domain'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$domain = domain;
    result$data['domain'] = l$domain;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddVerifiableDomainInput<Input$AddVerifiableDomainInput>
      get copyWith => CopyWith$Input$AddVerifiableDomainInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddVerifiableDomainInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$domain = domain;
    final lOther$domain = other.domain;
    if (l$domain != lOther$domain) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ownerId = ownerId;
    final l$domain = domain;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$ownerId,
      l$domain,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddVerifiableDomainInput<TRes> {
  factory CopyWith$Input$AddVerifiableDomainInput(
    Input$AddVerifiableDomainInput instance,
    TRes Function(Input$AddVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$AddVerifiableDomainInput;

  factory CopyWith$Input$AddVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddVerifiableDomainInput;

  TRes call({
    String? ownerId,
    String? domain,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddVerifiableDomainInput<TRes>
    implements CopyWith$Input$AddVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$AddVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$AddVerifiableDomainInput _instance;

  final TRes Function(Input$AddVerifiableDomainInput) _then;

  static const _undefined = {};

  TRes call({
    Object? ownerId = _undefined,
    Object? domain = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddVerifiableDomainInput._({
        ..._instance._$data,
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (domain != _undefined && domain != null)
          'domain': (domain as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddVerifiableDomainInput<TRes>
    implements CopyWith$Input$AddVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$AddVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? ownerId,
    String? domain,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ApproveDeploymentsInput {
  factory Input$ApproveDeploymentsInput({
    required String workflowRunId,
    required List<String> environmentIds,
    String? comment,
    String? clientMutationId,
  }) =>
      Input$ApproveDeploymentsInput._({
        r'workflowRunId': workflowRunId,
        r'environmentIds': environmentIds,
        if (comment != null) r'comment': comment,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ApproveDeploymentsInput._(this._$data);

  factory Input$ApproveDeploymentsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$workflowRunId = data['workflowRunId'];
    result$data['workflowRunId'] = (l$workflowRunId as String);
    final l$environmentIds = data['environmentIds'];
    result$data['environmentIds'] =
        (l$environmentIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ApproveDeploymentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get workflowRunId => (_$data['workflowRunId'] as String);
  List<String> get environmentIds => (_$data['environmentIds'] as List<String>);
  String? get comment => (_$data['comment'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$workflowRunId = workflowRunId;
    result$data['workflowRunId'] = l$workflowRunId;
    final l$environmentIds = environmentIds;
    result$data['environmentIds'] = l$environmentIds.map((e) => e).toList();
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ApproveDeploymentsInput<Input$ApproveDeploymentsInput>
      get copyWith => CopyWith$Input$ApproveDeploymentsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApproveDeploymentsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$workflowRunId = workflowRunId;
    final lOther$workflowRunId = other.workflowRunId;
    if (l$workflowRunId != lOther$workflowRunId) {
      return false;
    }
    final l$environmentIds = environmentIds;
    final lOther$environmentIds = other.environmentIds;
    if (l$environmentIds.length != lOther$environmentIds.length) {
      return false;
    }
    for (int i = 0; i < l$environmentIds.length; i++) {
      final l$environmentIds$entry = l$environmentIds[i];
      final lOther$environmentIds$entry = lOther$environmentIds[i];
      if (l$environmentIds$entry != lOther$environmentIds$entry) {
        return false;
      }
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$workflowRunId = workflowRunId;
    final l$environmentIds = environmentIds;
    final l$comment = comment;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$workflowRunId,
      Object.hashAll(l$environmentIds.map((v) => v)),
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApproveDeploymentsInput<TRes> {
  factory CopyWith$Input$ApproveDeploymentsInput(
    Input$ApproveDeploymentsInput instance,
    TRes Function(Input$ApproveDeploymentsInput) then,
  ) = _CopyWithImpl$Input$ApproveDeploymentsInput;

  factory CopyWith$Input$ApproveDeploymentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApproveDeploymentsInput;

  TRes call({
    String? workflowRunId,
    List<String>? environmentIds,
    String? comment,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ApproveDeploymentsInput<TRes>
    implements CopyWith$Input$ApproveDeploymentsInput<TRes> {
  _CopyWithImpl$Input$ApproveDeploymentsInput(
    this._instance,
    this._then,
  );

  final Input$ApproveDeploymentsInput _instance;

  final TRes Function(Input$ApproveDeploymentsInput) _then;

  static const _undefined = {};

  TRes call({
    Object? workflowRunId = _undefined,
    Object? environmentIds = _undefined,
    Object? comment = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ApproveDeploymentsInput._({
        ..._instance._$data,
        if (workflowRunId != _undefined && workflowRunId != null)
          'workflowRunId': (workflowRunId as String),
        if (environmentIds != _undefined && environmentIds != null)
          'environmentIds': (environmentIds as List<String>),
        if (comment != _undefined) 'comment': (comment as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ApproveDeploymentsInput<TRes>
    implements CopyWith$Input$ApproveDeploymentsInput<TRes> {
  _CopyWithStubImpl$Input$ApproveDeploymentsInput(this._res);

  TRes _res;

  call({
    String? workflowRunId,
    List<String>? environmentIds,
    String? comment,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ApproveVerifiableDomainInput {
  factory Input$ApproveVerifiableDomainInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$ApproveVerifiableDomainInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ApproveVerifiableDomainInput._(this._$data);

  factory Input$ApproveVerifiableDomainInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ApproveVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ApproveVerifiableDomainInput<
          Input$ApproveVerifiableDomainInput>
      get copyWith => CopyWith$Input$ApproveVerifiableDomainInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApproveVerifiableDomainInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApproveVerifiableDomainInput<TRes> {
  factory CopyWith$Input$ApproveVerifiableDomainInput(
    Input$ApproveVerifiableDomainInput instance,
    TRes Function(Input$ApproveVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$ApproveVerifiableDomainInput;

  factory CopyWith$Input$ApproveVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApproveVerifiableDomainInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ApproveVerifiableDomainInput<TRes>
    implements CopyWith$Input$ApproveVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$ApproveVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$ApproveVerifiableDomainInput _instance;

  final TRes Function(Input$ApproveVerifiableDomainInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ApproveVerifiableDomainInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ApproveVerifiableDomainInput<TRes>
    implements CopyWith$Input$ApproveVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$ApproveVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ArchiveProjectV2ItemInput {
  factory Input$ArchiveProjectV2ItemInput({
    required String projectId,
    required String itemId,
    String? clientMutationId,
  }) =>
      Input$ArchiveProjectV2ItemInput._({
        r'projectId': projectId,
        r'itemId': itemId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ArchiveProjectV2ItemInput._(this._$data);

  factory Input$ArchiveProjectV2ItemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ArchiveProjectV2ItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get itemId => (_$data['itemId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ArchiveProjectV2ItemInput<Input$ArchiveProjectV2ItemInput>
      get copyWith => CopyWith$Input$ArchiveProjectV2ItemInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ArchiveProjectV2ItemInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$itemId = itemId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$itemId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ArchiveProjectV2ItemInput<TRes> {
  factory CopyWith$Input$ArchiveProjectV2ItemInput(
    Input$ArchiveProjectV2ItemInput instance,
    TRes Function(Input$ArchiveProjectV2ItemInput) then,
  ) = _CopyWithImpl$Input$ArchiveProjectV2ItemInput;

  factory CopyWith$Input$ArchiveProjectV2ItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArchiveProjectV2ItemInput;

  TRes call({
    String? projectId,
    String? itemId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ArchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$ArchiveProjectV2ItemInput<TRes> {
  _CopyWithImpl$Input$ArchiveProjectV2ItemInput(
    this._instance,
    this._then,
  );

  final Input$ArchiveProjectV2ItemInput _instance;

  final TRes Function(Input$ArchiveProjectV2ItemInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? itemId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ArchiveProjectV2ItemInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ArchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$ArchiveProjectV2ItemInput<TRes> {
  _CopyWithStubImpl$Input$ArchiveProjectV2ItemInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? itemId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ArchiveRepositoryInput {
  factory Input$ArchiveRepositoryInput({
    required String repositoryId,
    String? clientMutationId,
  }) =>
      Input$ArchiveRepositoryInput._({
        r'repositoryId': repositoryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ArchiveRepositoryInput._(this._$data);

  factory Input$ArchiveRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ArchiveRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ArchiveRepositoryInput<Input$ArchiveRepositoryInput>
      get copyWith => CopyWith$Input$ArchiveRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ArchiveRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ArchiveRepositoryInput<TRes> {
  factory CopyWith$Input$ArchiveRepositoryInput(
    Input$ArchiveRepositoryInput instance,
    TRes Function(Input$ArchiveRepositoryInput) then,
  ) = _CopyWithImpl$Input$ArchiveRepositoryInput;

  factory CopyWith$Input$ArchiveRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArchiveRepositoryInput;

  TRes call({
    String? repositoryId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ArchiveRepositoryInput<TRes>
    implements CopyWith$Input$ArchiveRepositoryInput<TRes> {
  _CopyWithImpl$Input$ArchiveRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$ArchiveRepositoryInput _instance;

  final TRes Function(Input$ArchiveRepositoryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ArchiveRepositoryInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ArchiveRepositoryInput<TRes>
    implements CopyWith$Input$ArchiveRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$ArchiveRepositoryInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AuditLogOrder {
  factory Input$AuditLogOrder({
    Enum$AuditLogOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      Input$AuditLogOrder._({
        if (field != null) r'field': field,
        if (direction != null) r'direction': direction,
      });

  Input$AuditLogOrder._(this._$data);

  factory Input$AuditLogOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$AuditLogOrderField((l$field as String));
    }
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    return Input$AuditLogOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$AuditLogOrderField? get field =>
      (_$data['field'] as Enum$AuditLogOrderField?);
  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] =
          l$field == null ? null : toJson$Enum$AuditLogOrderField(l$field);
    }
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    return result$data;
  }

  CopyWith$Input$AuditLogOrder<Input$AuditLogOrder> get copyWith =>
      CopyWith$Input$AuditLogOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AuditLogOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      _$data.containsKey('field') ? l$field : const {},
      _$data.containsKey('direction') ? l$direction : const {},
    ]);
  }
}

abstract class CopyWith$Input$AuditLogOrder<TRes> {
  factory CopyWith$Input$AuditLogOrder(
    Input$AuditLogOrder instance,
    TRes Function(Input$AuditLogOrder) then,
  ) = _CopyWithImpl$Input$AuditLogOrder;

  factory CopyWith$Input$AuditLogOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$AuditLogOrder;

  TRes call({
    Enum$AuditLogOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$AuditLogOrder<TRes>
    implements CopyWith$Input$AuditLogOrder<TRes> {
  _CopyWithImpl$Input$AuditLogOrder(
    this._instance,
    this._then,
  );

  final Input$AuditLogOrder _instance;

  final TRes Function(Input$AuditLogOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$AuditLogOrder._({
        ..._instance._$data,
        if (field != _undefined) 'field': (field as Enum$AuditLogOrderField?),
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
      }));
}

class _CopyWithStubImpl$Input$AuditLogOrder<TRes>
    implements CopyWith$Input$AuditLogOrder<TRes> {
  _CopyWithStubImpl$Input$AuditLogOrder(this._res);

  TRes _res;

  call({
    Enum$AuditLogOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$CancelEnterpriseAdminInvitationInput {
  factory Input$CancelEnterpriseAdminInvitationInput({
    required String invitationId,
    String? clientMutationId,
  }) =>
      Input$CancelEnterpriseAdminInvitationInput._({
        r'invitationId': invitationId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CancelEnterpriseAdminInvitationInput._(this._$data);

  factory Input$CancelEnterpriseAdminInvitationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$invitationId = data['invitationId'];
    result$data['invitationId'] = (l$invitationId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CancelEnterpriseAdminInvitationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get invitationId => (_$data['invitationId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$invitationId = invitationId;
    result$data['invitationId'] = l$invitationId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CancelEnterpriseAdminInvitationInput<
          Input$CancelEnterpriseAdminInvitationInput>
      get copyWith => CopyWith$Input$CancelEnterpriseAdminInvitationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CancelEnterpriseAdminInvitationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$invitationId = invitationId;
    final lOther$invitationId = other.invitationId;
    if (l$invitationId != lOther$invitationId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$invitationId = invitationId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$invitationId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CancelEnterpriseAdminInvitationInput<TRes> {
  factory CopyWith$Input$CancelEnterpriseAdminInvitationInput(
    Input$CancelEnterpriseAdminInvitationInput instance,
    TRes Function(Input$CancelEnterpriseAdminInvitationInput) then,
  ) = _CopyWithImpl$Input$CancelEnterpriseAdminInvitationInput;

  factory CopyWith$Input$CancelEnterpriseAdminInvitationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CancelEnterpriseAdminInvitationInput;

  TRes call({
    String? invitationId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CancelEnterpriseAdminInvitationInput<TRes>
    implements CopyWith$Input$CancelEnterpriseAdminInvitationInput<TRes> {
  _CopyWithImpl$Input$CancelEnterpriseAdminInvitationInput(
    this._instance,
    this._then,
  );

  final Input$CancelEnterpriseAdminInvitationInput _instance;

  final TRes Function(Input$CancelEnterpriseAdminInvitationInput) _then;

  static const _undefined = {};

  TRes call({
    Object? invitationId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CancelEnterpriseAdminInvitationInput._({
        ..._instance._$data,
        if (invitationId != _undefined && invitationId != null)
          'invitationId': (invitationId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CancelEnterpriseAdminInvitationInput<TRes>
    implements CopyWith$Input$CancelEnterpriseAdminInvitationInput<TRes> {
  _CopyWithStubImpl$Input$CancelEnterpriseAdminInvitationInput(this._res);

  TRes _res;

  call({
    String? invitationId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CancelSponsorshipInput {
  factory Input$CancelSponsorshipInput({
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? clientMutationId,
  }) =>
      Input$CancelSponsorshipInput._({
        if (sponsorId != null) r'sponsorId': sponsorId,
        if (sponsorLogin != null) r'sponsorLogin': sponsorLogin,
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CancelSponsorshipInput._(this._$data);

  factory Input$CancelSponsorshipInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('sponsorId')) {
      final l$sponsorId = data['sponsorId'];
      result$data['sponsorId'] = (l$sponsorId as String?);
    }
    if (data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = data['sponsorLogin'];
      result$data['sponsorLogin'] = (l$sponsorLogin as String?);
    }
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CancelSponsorshipInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get sponsorId => (_$data['sponsorId'] as String?);
  String? get sponsorLogin => (_$data['sponsorLogin'] as String?);
  String? get sponsorableId => (_$data['sponsorableId'] as String?);
  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('sponsorId')) {
      final l$sponsorId = sponsorId;
      result$data['sponsorId'] = l$sponsorId;
    }
    if (_$data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = sponsorLogin;
      result$data['sponsorLogin'] = l$sponsorLogin;
    }
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CancelSponsorshipInput<Input$CancelSponsorshipInput>
      get copyWith => CopyWith$Input$CancelSponsorshipInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CancelSponsorshipInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$sponsorId = sponsorId;
    final lOther$sponsorId = other.sponsorId;
    if (_$data.containsKey('sponsorId') !=
        other._$data.containsKey('sponsorId')) {
      return false;
    }
    if (l$sponsorId != lOther$sponsorId) {
      return false;
    }
    final l$sponsorLogin = sponsorLogin;
    final lOther$sponsorLogin = other.sponsorLogin;
    if (_$data.containsKey('sponsorLogin') !=
        other._$data.containsKey('sponsorLogin')) {
      return false;
    }
    if (l$sponsorLogin != lOther$sponsorLogin) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sponsorId = sponsorId;
    final l$sponsorLogin = sponsorLogin;
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('sponsorId') ? l$sponsorId : const {},
      _$data.containsKey('sponsorLogin') ? l$sponsorLogin : const {},
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CancelSponsorshipInput<TRes> {
  factory CopyWith$Input$CancelSponsorshipInput(
    Input$CancelSponsorshipInput instance,
    TRes Function(Input$CancelSponsorshipInput) then,
  ) = _CopyWithImpl$Input$CancelSponsorshipInput;

  factory CopyWith$Input$CancelSponsorshipInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CancelSponsorshipInput;

  TRes call({
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CancelSponsorshipInput<TRes>
    implements CopyWith$Input$CancelSponsorshipInput<TRes> {
  _CopyWithImpl$Input$CancelSponsorshipInput(
    this._instance,
    this._then,
  );

  final Input$CancelSponsorshipInput _instance;

  final TRes Function(Input$CancelSponsorshipInput) _then;

  static const _undefined = {};

  TRes call({
    Object? sponsorId = _undefined,
    Object? sponsorLogin = _undefined,
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CancelSponsorshipInput._({
        ..._instance._$data,
        if (sponsorId != _undefined) 'sponsorId': (sponsorId as String?),
        if (sponsorLogin != _undefined)
          'sponsorLogin': (sponsorLogin as String?),
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CancelSponsorshipInput<TRes>
    implements CopyWith$Input$CancelSponsorshipInput<TRes> {
  _CopyWithStubImpl$Input$CancelSponsorshipInput(this._res);

  TRes _res;

  call({
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ChangeUserStatusInput {
  factory Input$ChangeUserStatusInput({
    String? emoji,
    String? message,
    String? organizationId,
    bool? limitedAvailability,
    String? expiresAt,
    String? clientMutationId,
  }) =>
      Input$ChangeUserStatusInput._({
        if (emoji != null) r'emoji': emoji,
        if (message != null) r'message': message,
        if (organizationId != null) r'organizationId': organizationId,
        if (limitedAvailability != null)
          r'limitedAvailability': limitedAvailability,
        if (expiresAt != null) r'expiresAt': expiresAt,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ChangeUserStatusInput._(this._$data);

  factory Input$ChangeUserStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('emoji')) {
      final l$emoji = data['emoji'];
      result$data['emoji'] = (l$emoji as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    if (data.containsKey('organizationId')) {
      final l$organizationId = data['organizationId'];
      result$data['organizationId'] = (l$organizationId as String?);
    }
    if (data.containsKey('limitedAvailability')) {
      final l$limitedAvailability = data['limitedAvailability'];
      result$data['limitedAvailability'] = (l$limitedAvailability as bool?);
    }
    if (data.containsKey('expiresAt')) {
      final l$expiresAt = data['expiresAt'];
      result$data['expiresAt'] = (l$expiresAt as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ChangeUserStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get emoji => (_$data['emoji'] as String?);
  String? get message => (_$data['message'] as String?);
  String? get organizationId => (_$data['organizationId'] as String?);
  bool? get limitedAvailability => (_$data['limitedAvailability'] as bool?);
  String? get expiresAt => (_$data['expiresAt'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('emoji')) {
      final l$emoji = emoji;
      result$data['emoji'] = l$emoji;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('organizationId')) {
      final l$organizationId = organizationId;
      result$data['organizationId'] = l$organizationId;
    }
    if (_$data.containsKey('limitedAvailability')) {
      final l$limitedAvailability = limitedAvailability;
      result$data['limitedAvailability'] = l$limitedAvailability;
    }
    if (_$data.containsKey('expiresAt')) {
      final l$expiresAt = expiresAt;
      result$data['expiresAt'] = l$expiresAt;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ChangeUserStatusInput<Input$ChangeUserStatusInput>
      get copyWith => CopyWith$Input$ChangeUserStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeUserStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$emoji = emoji;
    final lOther$emoji = other.emoji;
    if (_$data.containsKey('emoji') != other._$data.containsKey('emoji')) {
      return false;
    }
    if (l$emoji != lOther$emoji) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (_$data.containsKey('organizationId') !=
        other._$data.containsKey('organizationId')) {
      return false;
    }
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$limitedAvailability = limitedAvailability;
    final lOther$limitedAvailability = other.limitedAvailability;
    if (_$data.containsKey('limitedAvailability') !=
        other._$data.containsKey('limitedAvailability')) {
      return false;
    }
    if (l$limitedAvailability != lOther$limitedAvailability) {
      return false;
    }
    final l$expiresAt = expiresAt;
    final lOther$expiresAt = other.expiresAt;
    if (_$data.containsKey('expiresAt') !=
        other._$data.containsKey('expiresAt')) {
      return false;
    }
    if (l$expiresAt != lOther$expiresAt) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$emoji = emoji;
    final l$message = message;
    final l$organizationId = organizationId;
    final l$limitedAvailability = limitedAvailability;
    final l$expiresAt = expiresAt;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('emoji') ? l$emoji : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('organizationId') ? l$organizationId : const {},
      _$data.containsKey('limitedAvailability')
          ? l$limitedAvailability
          : const {},
      _$data.containsKey('expiresAt') ? l$expiresAt : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChangeUserStatusInput<TRes> {
  factory CopyWith$Input$ChangeUserStatusInput(
    Input$ChangeUserStatusInput instance,
    TRes Function(Input$ChangeUserStatusInput) then,
  ) = _CopyWithImpl$Input$ChangeUserStatusInput;

  factory CopyWith$Input$ChangeUserStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeUserStatusInput;

  TRes call({
    String? emoji,
    String? message,
    String? organizationId,
    bool? limitedAvailability,
    String? expiresAt,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ChangeUserStatusInput<TRes>
    implements CopyWith$Input$ChangeUserStatusInput<TRes> {
  _CopyWithImpl$Input$ChangeUserStatusInput(
    this._instance,
    this._then,
  );

  final Input$ChangeUserStatusInput _instance;

  final TRes Function(Input$ChangeUserStatusInput) _then;

  static const _undefined = {};

  TRes call({
    Object? emoji = _undefined,
    Object? message = _undefined,
    Object? organizationId = _undefined,
    Object? limitedAvailability = _undefined,
    Object? expiresAt = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ChangeUserStatusInput._({
        ..._instance._$data,
        if (emoji != _undefined) 'emoji': (emoji as String?),
        if (message != _undefined) 'message': (message as String?),
        if (organizationId != _undefined)
          'organizationId': (organizationId as String?),
        if (limitedAvailability != _undefined)
          'limitedAvailability': (limitedAvailability as bool?),
        if (expiresAt != _undefined) 'expiresAt': (expiresAt as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ChangeUserStatusInput<TRes>
    implements CopyWith$Input$ChangeUserStatusInput<TRes> {
  _CopyWithStubImpl$Input$ChangeUserStatusInput(this._res);

  TRes _res;

  call({
    String? emoji,
    String? message,
    String? organizationId,
    bool? limitedAvailability,
    String? expiresAt,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CheckAnnotationData {
  factory Input$CheckAnnotationData({
    required String path,
    required Input$CheckAnnotationRange location,
    required Enum$CheckAnnotationLevel annotationLevel,
    required String message,
    String? title,
    String? rawDetails,
  }) =>
      Input$CheckAnnotationData._({
        r'path': path,
        r'location': location,
        r'annotationLevel': annotationLevel,
        r'message': message,
        if (title != null) r'title': title,
        if (rawDetails != null) r'rawDetails': rawDetails,
      });

  Input$CheckAnnotationData._(this._$data);

  factory Input$CheckAnnotationData.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    final l$location = data['location'];
    result$data['location'] = Input$CheckAnnotationRange.fromJson(
        (l$location as Map<String, dynamic>));
    final l$annotationLevel = data['annotationLevel'];
    result$data['annotationLevel'] =
        fromJson$Enum$CheckAnnotationLevel((l$annotationLevel as String));
    final l$message = data['message'];
    result$data['message'] = (l$message as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('rawDetails')) {
      final l$rawDetails = data['rawDetails'];
      result$data['rawDetails'] = (l$rawDetails as String?);
    }
    return Input$CheckAnnotationData._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  Input$CheckAnnotationRange get location =>
      (_$data['location'] as Input$CheckAnnotationRange);
  Enum$CheckAnnotationLevel get annotationLevel =>
      (_$data['annotationLevel'] as Enum$CheckAnnotationLevel);
  String get message => (_$data['message'] as String);
  String? get title => (_$data['title'] as String?);
  String? get rawDetails => (_$data['rawDetails'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    final l$location = location;
    result$data['location'] = l$location.toJson();
    final l$annotationLevel = annotationLevel;
    result$data['annotationLevel'] =
        toJson$Enum$CheckAnnotationLevel(l$annotationLevel);
    final l$message = message;
    result$data['message'] = l$message;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('rawDetails')) {
      final l$rawDetails = rawDetails;
      result$data['rawDetails'] = l$rawDetails;
    }
    return result$data;
  }

  CopyWith$Input$CheckAnnotationData<Input$CheckAnnotationData> get copyWith =>
      CopyWith$Input$CheckAnnotationData(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckAnnotationData) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (l$location != lOther$location) {
      return false;
    }
    final l$annotationLevel = annotationLevel;
    final lOther$annotationLevel = other.annotationLevel;
    if (l$annotationLevel != lOther$annotationLevel) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$rawDetails = rawDetails;
    final lOther$rawDetails = other.rawDetails;
    if (_$data.containsKey('rawDetails') !=
        other._$data.containsKey('rawDetails')) {
      return false;
    }
    if (l$rawDetails != lOther$rawDetails) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$location = location;
    final l$annotationLevel = annotationLevel;
    final l$message = message;
    final l$title = title;
    final l$rawDetails = rawDetails;
    return Object.hashAll([
      l$path,
      l$location,
      l$annotationLevel,
      l$message,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('rawDetails') ? l$rawDetails : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckAnnotationData<TRes> {
  factory CopyWith$Input$CheckAnnotationData(
    Input$CheckAnnotationData instance,
    TRes Function(Input$CheckAnnotationData) then,
  ) = _CopyWithImpl$Input$CheckAnnotationData;

  factory CopyWith$Input$CheckAnnotationData.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckAnnotationData;

  TRes call({
    String? path,
    Input$CheckAnnotationRange? location,
    Enum$CheckAnnotationLevel? annotationLevel,
    String? message,
    String? title,
    String? rawDetails,
  });
  CopyWith$Input$CheckAnnotationRange<TRes> get location;
}

class _CopyWithImpl$Input$CheckAnnotationData<TRes>
    implements CopyWith$Input$CheckAnnotationData<TRes> {
  _CopyWithImpl$Input$CheckAnnotationData(
    this._instance,
    this._then,
  );

  final Input$CheckAnnotationData _instance;

  final TRes Function(Input$CheckAnnotationData) _then;

  static const _undefined = {};

  TRes call({
    Object? path = _undefined,
    Object? location = _undefined,
    Object? annotationLevel = _undefined,
    Object? message = _undefined,
    Object? title = _undefined,
    Object? rawDetails = _undefined,
  }) =>
      _then(Input$CheckAnnotationData._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (location != _undefined && location != null)
          'location': (location as Input$CheckAnnotationRange),
        if (annotationLevel != _undefined && annotationLevel != null)
          'annotationLevel': (annotationLevel as Enum$CheckAnnotationLevel),
        if (message != _undefined && message != null)
          'message': (message as String),
        if (title != _undefined) 'title': (title as String?),
        if (rawDetails != _undefined) 'rawDetails': (rawDetails as String?),
      }));
  CopyWith$Input$CheckAnnotationRange<TRes> get location {
    final local$location = _instance.location;
    return CopyWith$Input$CheckAnnotationRange(
        local$location, (e) => call(location: e));
  }
}

class _CopyWithStubImpl$Input$CheckAnnotationData<TRes>
    implements CopyWith$Input$CheckAnnotationData<TRes> {
  _CopyWithStubImpl$Input$CheckAnnotationData(this._res);

  TRes _res;

  call({
    String? path,
    Input$CheckAnnotationRange? location,
    Enum$CheckAnnotationLevel? annotationLevel,
    String? message,
    String? title,
    String? rawDetails,
  }) =>
      _res;
  CopyWith$Input$CheckAnnotationRange<TRes> get location =>
      CopyWith$Input$CheckAnnotationRange.stub(_res);
}

class Input$CheckAnnotationRange {
  factory Input$CheckAnnotationRange({
    required int startLine,
    int? startColumn,
    required int endLine,
    int? endColumn,
  }) =>
      Input$CheckAnnotationRange._({
        r'startLine': startLine,
        if (startColumn != null) r'startColumn': startColumn,
        r'endLine': endLine,
        if (endColumn != null) r'endColumn': endColumn,
      });

  Input$CheckAnnotationRange._(this._$data);

  factory Input$CheckAnnotationRange.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$startLine = data['startLine'];
    result$data['startLine'] = (l$startLine as int);
    if (data.containsKey('startColumn')) {
      final l$startColumn = data['startColumn'];
      result$data['startColumn'] = (l$startColumn as int?);
    }
    final l$endLine = data['endLine'];
    result$data['endLine'] = (l$endLine as int);
    if (data.containsKey('endColumn')) {
      final l$endColumn = data['endColumn'];
      result$data['endColumn'] = (l$endColumn as int?);
    }
    return Input$CheckAnnotationRange._(result$data);
  }

  Map<String, dynamic> _$data;

  int get startLine => (_$data['startLine'] as int);
  int? get startColumn => (_$data['startColumn'] as int?);
  int get endLine => (_$data['endLine'] as int);
  int? get endColumn => (_$data['endColumn'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$startLine = startLine;
    result$data['startLine'] = l$startLine;
    if (_$data.containsKey('startColumn')) {
      final l$startColumn = startColumn;
      result$data['startColumn'] = l$startColumn;
    }
    final l$endLine = endLine;
    result$data['endLine'] = l$endLine;
    if (_$data.containsKey('endColumn')) {
      final l$endColumn = endColumn;
      result$data['endColumn'] = l$endColumn;
    }
    return result$data;
  }

  CopyWith$Input$CheckAnnotationRange<Input$CheckAnnotationRange>
      get copyWith => CopyWith$Input$CheckAnnotationRange(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckAnnotationRange) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$startLine = startLine;
    final lOther$startLine = other.startLine;
    if (l$startLine != lOther$startLine) {
      return false;
    }
    final l$startColumn = startColumn;
    final lOther$startColumn = other.startColumn;
    if (_$data.containsKey('startColumn') !=
        other._$data.containsKey('startColumn')) {
      return false;
    }
    if (l$startColumn != lOther$startColumn) {
      return false;
    }
    final l$endLine = endLine;
    final lOther$endLine = other.endLine;
    if (l$endLine != lOther$endLine) {
      return false;
    }
    final l$endColumn = endColumn;
    final lOther$endColumn = other.endColumn;
    if (_$data.containsKey('endColumn') !=
        other._$data.containsKey('endColumn')) {
      return false;
    }
    if (l$endColumn != lOther$endColumn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$startLine = startLine;
    final l$startColumn = startColumn;
    final l$endLine = endLine;
    final l$endColumn = endColumn;
    return Object.hashAll([
      l$startLine,
      _$data.containsKey('startColumn') ? l$startColumn : const {},
      l$endLine,
      _$data.containsKey('endColumn') ? l$endColumn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckAnnotationRange<TRes> {
  factory CopyWith$Input$CheckAnnotationRange(
    Input$CheckAnnotationRange instance,
    TRes Function(Input$CheckAnnotationRange) then,
  ) = _CopyWithImpl$Input$CheckAnnotationRange;

  factory CopyWith$Input$CheckAnnotationRange.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckAnnotationRange;

  TRes call({
    int? startLine,
    int? startColumn,
    int? endLine,
    int? endColumn,
  });
}

class _CopyWithImpl$Input$CheckAnnotationRange<TRes>
    implements CopyWith$Input$CheckAnnotationRange<TRes> {
  _CopyWithImpl$Input$CheckAnnotationRange(
    this._instance,
    this._then,
  );

  final Input$CheckAnnotationRange _instance;

  final TRes Function(Input$CheckAnnotationRange) _then;

  static const _undefined = {};

  TRes call({
    Object? startLine = _undefined,
    Object? startColumn = _undefined,
    Object? endLine = _undefined,
    Object? endColumn = _undefined,
  }) =>
      _then(Input$CheckAnnotationRange._({
        ..._instance._$data,
        if (startLine != _undefined && startLine != null)
          'startLine': (startLine as int),
        if (startColumn != _undefined) 'startColumn': (startColumn as int?),
        if (endLine != _undefined && endLine != null)
          'endLine': (endLine as int),
        if (endColumn != _undefined) 'endColumn': (endColumn as int?),
      }));
}

class _CopyWithStubImpl$Input$CheckAnnotationRange<TRes>
    implements CopyWith$Input$CheckAnnotationRange<TRes> {
  _CopyWithStubImpl$Input$CheckAnnotationRange(this._res);

  TRes _res;

  call({
    int? startLine,
    int? startColumn,
    int? endLine,
    int? endColumn,
  }) =>
      _res;
}

class Input$CheckRunAction {
  factory Input$CheckRunAction({
    required String label,
    required String description,
    required String identifier,
  }) =>
      Input$CheckRunAction._({
        r'label': label,
        r'description': description,
        r'identifier': identifier,
      });

  Input$CheckRunAction._(this._$data);

  factory Input$CheckRunAction.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$label = data['label'];
    result$data['label'] = (l$label as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$identifier = data['identifier'];
    result$data['identifier'] = (l$identifier as String);
    return Input$CheckRunAction._(result$data);
  }

  Map<String, dynamic> _$data;

  String get label => (_$data['label'] as String);
  String get description => (_$data['description'] as String);
  String get identifier => (_$data['identifier'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$label = label;
    result$data['label'] = l$label;
    final l$description = description;
    result$data['description'] = l$description;
    final l$identifier = identifier;
    result$data['identifier'] = l$identifier;
    return result$data;
  }

  CopyWith$Input$CheckRunAction<Input$CheckRunAction> get copyWith =>
      CopyWith$Input$CheckRunAction(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckRunAction) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$label = label;
    final lOther$label = other.label;
    if (l$label != lOther$label) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$identifier = identifier;
    final lOther$identifier = other.identifier;
    if (l$identifier != lOther$identifier) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$label = label;
    final l$description = description;
    final l$identifier = identifier;
    return Object.hashAll([
      l$label,
      l$description,
      l$identifier,
    ]);
  }
}

abstract class CopyWith$Input$CheckRunAction<TRes> {
  factory CopyWith$Input$CheckRunAction(
    Input$CheckRunAction instance,
    TRes Function(Input$CheckRunAction) then,
  ) = _CopyWithImpl$Input$CheckRunAction;

  factory CopyWith$Input$CheckRunAction.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunAction;

  TRes call({
    String? label,
    String? description,
    String? identifier,
  });
}

class _CopyWithImpl$Input$CheckRunAction<TRes>
    implements CopyWith$Input$CheckRunAction<TRes> {
  _CopyWithImpl$Input$CheckRunAction(
    this._instance,
    this._then,
  );

  final Input$CheckRunAction _instance;

  final TRes Function(Input$CheckRunAction) _then;

  static const _undefined = {};

  TRes call({
    Object? label = _undefined,
    Object? description = _undefined,
    Object? identifier = _undefined,
  }) =>
      _then(Input$CheckRunAction._({
        ..._instance._$data,
        if (label != _undefined && label != null) 'label': (label as String),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (identifier != _undefined && identifier != null)
          'identifier': (identifier as String),
      }));
}

class _CopyWithStubImpl$Input$CheckRunAction<TRes>
    implements CopyWith$Input$CheckRunAction<TRes> {
  _CopyWithStubImpl$Input$CheckRunAction(this._res);

  TRes _res;

  call({
    String? label,
    String? description,
    String? identifier,
  }) =>
      _res;
}

class Input$CheckRunFilter {
  factory Input$CheckRunFilter({
    Enum$CheckRunType? checkType,
    int? appId,
    String? checkName,
    Enum$CheckStatusState? status,
    List<Enum$CheckStatusState>? statuses,
    List<Enum$CheckConclusionState>? conclusions,
  }) =>
      Input$CheckRunFilter._({
        if (checkType != null) r'checkType': checkType,
        if (appId != null) r'appId': appId,
        if (checkName != null) r'checkName': checkName,
        if (status != null) r'status': status,
        if (statuses != null) r'statuses': statuses,
        if (conclusions != null) r'conclusions': conclusions,
      });

  Input$CheckRunFilter._(this._$data);

  factory Input$CheckRunFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('checkType')) {
      final l$checkType = data['checkType'];
      result$data['checkType'] = l$checkType == null
          ? null
          : fromJson$Enum$CheckRunType((l$checkType as String));
    }
    if (data.containsKey('appId')) {
      final l$appId = data['appId'];
      result$data['appId'] = (l$appId as int?);
    }
    if (data.containsKey('checkName')) {
      final l$checkName = data['checkName'];
      result$data['checkName'] = (l$checkName as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$CheckStatusState((l$status as String));
    }
    if (data.containsKey('statuses')) {
      final l$statuses = data['statuses'];
      result$data['statuses'] = (l$statuses as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CheckStatusState((e as String)))
          .toList();
    }
    if (data.containsKey('conclusions')) {
      final l$conclusions = data['conclusions'];
      result$data['conclusions'] = (l$conclusions as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CheckConclusionState((e as String)))
          .toList();
    }
    return Input$CheckRunFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CheckRunType? get checkType =>
      (_$data['checkType'] as Enum$CheckRunType?);
  int? get appId => (_$data['appId'] as int?);
  String? get checkName => (_$data['checkName'] as String?);
  Enum$CheckStatusState? get status =>
      (_$data['status'] as Enum$CheckStatusState?);
  List<Enum$CheckStatusState>? get statuses =>
      (_$data['statuses'] as List<Enum$CheckStatusState>?);
  List<Enum$CheckConclusionState>? get conclusions =>
      (_$data['conclusions'] as List<Enum$CheckConclusionState>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('checkType')) {
      final l$checkType = checkType;
      result$data['checkType'] =
          l$checkType == null ? null : toJson$Enum$CheckRunType(l$checkType);
    }
    if (_$data.containsKey('appId')) {
      final l$appId = appId;
      result$data['appId'] = l$appId;
    }
    if (_$data.containsKey('checkName')) {
      final l$checkName = checkName;
      result$data['checkName'] = l$checkName;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$CheckStatusState(l$status);
    }
    if (_$data.containsKey('statuses')) {
      final l$statuses = statuses;
      result$data['statuses'] =
          l$statuses?.map((e) => toJson$Enum$CheckStatusState(e)).toList();
    }
    if (_$data.containsKey('conclusions')) {
      final l$conclusions = conclusions;
      result$data['conclusions'] = l$conclusions
          ?.map((e) => toJson$Enum$CheckConclusionState(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$CheckRunFilter<Input$CheckRunFilter> get copyWith =>
      CopyWith$Input$CheckRunFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckRunFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$checkType = checkType;
    final lOther$checkType = other.checkType;
    if (_$data.containsKey('checkType') !=
        other._$data.containsKey('checkType')) {
      return false;
    }
    if (l$checkType != lOther$checkType) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (_$data.containsKey('appId') != other._$data.containsKey('appId')) {
      return false;
    }
    if (l$appId != lOther$appId) {
      return false;
    }
    final l$checkName = checkName;
    final lOther$checkName = other.checkName;
    if (_$data.containsKey('checkName') !=
        other._$data.containsKey('checkName')) {
      return false;
    }
    if (l$checkName != lOther$checkName) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$statuses = statuses;
    final lOther$statuses = other.statuses;
    if (_$data.containsKey('statuses') !=
        other._$data.containsKey('statuses')) {
      return false;
    }
    if (l$statuses != null && lOther$statuses != null) {
      if (l$statuses.length != lOther$statuses.length) {
        return false;
      }
      for (int i = 0; i < l$statuses.length; i++) {
        final l$statuses$entry = l$statuses[i];
        final lOther$statuses$entry = lOther$statuses[i];
        if (l$statuses$entry != lOther$statuses$entry) {
          return false;
        }
      }
    } else if (l$statuses != lOther$statuses) {
      return false;
    }
    final l$conclusions = conclusions;
    final lOther$conclusions = other.conclusions;
    if (_$data.containsKey('conclusions') !=
        other._$data.containsKey('conclusions')) {
      return false;
    }
    if (l$conclusions != null && lOther$conclusions != null) {
      if (l$conclusions.length != lOther$conclusions.length) {
        return false;
      }
      for (int i = 0; i < l$conclusions.length; i++) {
        final l$conclusions$entry = l$conclusions[i];
        final lOther$conclusions$entry = lOther$conclusions[i];
        if (l$conclusions$entry != lOther$conclusions$entry) {
          return false;
        }
      }
    } else if (l$conclusions != lOther$conclusions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$checkType = checkType;
    final l$appId = appId;
    final l$checkName = checkName;
    final l$status = status;
    final l$statuses = statuses;
    final l$conclusions = conclusions;
    return Object.hashAll([
      _$data.containsKey('checkType') ? l$checkType : const {},
      _$data.containsKey('appId') ? l$appId : const {},
      _$data.containsKey('checkName') ? l$checkName : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('statuses')
          ? l$statuses == null
              ? null
              : Object.hashAll(l$statuses.map((v) => v))
          : const {},
      _$data.containsKey('conclusions')
          ? l$conclusions == null
              ? null
              : Object.hashAll(l$conclusions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckRunFilter<TRes> {
  factory CopyWith$Input$CheckRunFilter(
    Input$CheckRunFilter instance,
    TRes Function(Input$CheckRunFilter) then,
  ) = _CopyWithImpl$Input$CheckRunFilter;

  factory CopyWith$Input$CheckRunFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunFilter;

  TRes call({
    Enum$CheckRunType? checkType,
    int? appId,
    String? checkName,
    Enum$CheckStatusState? status,
    List<Enum$CheckStatusState>? statuses,
    List<Enum$CheckConclusionState>? conclusions,
  });
}

class _CopyWithImpl$Input$CheckRunFilter<TRes>
    implements CopyWith$Input$CheckRunFilter<TRes> {
  _CopyWithImpl$Input$CheckRunFilter(
    this._instance,
    this._then,
  );

  final Input$CheckRunFilter _instance;

  final TRes Function(Input$CheckRunFilter) _then;

  static const _undefined = {};

  TRes call({
    Object? checkType = _undefined,
    Object? appId = _undefined,
    Object? checkName = _undefined,
    Object? status = _undefined,
    Object? statuses = _undefined,
    Object? conclusions = _undefined,
  }) =>
      _then(Input$CheckRunFilter._({
        ..._instance._$data,
        if (checkType != _undefined)
          'checkType': (checkType as Enum$CheckRunType?),
        if (appId != _undefined) 'appId': (appId as int?),
        if (checkName != _undefined) 'checkName': (checkName as String?),
        if (status != _undefined) 'status': (status as Enum$CheckStatusState?),
        if (statuses != _undefined)
          'statuses': (statuses as List<Enum$CheckStatusState>?),
        if (conclusions != _undefined)
          'conclusions': (conclusions as List<Enum$CheckConclusionState>?),
      }));
}

class _CopyWithStubImpl$Input$CheckRunFilter<TRes>
    implements CopyWith$Input$CheckRunFilter<TRes> {
  _CopyWithStubImpl$Input$CheckRunFilter(this._res);

  TRes _res;

  call({
    Enum$CheckRunType? checkType,
    int? appId,
    String? checkName,
    Enum$CheckStatusState? status,
    List<Enum$CheckStatusState>? statuses,
    List<Enum$CheckConclusionState>? conclusions,
  }) =>
      _res;
}

class Input$CheckRunOutput {
  factory Input$CheckRunOutput({
    required String title,
    required String summary,
    String? text,
    List<Input$CheckAnnotationData>? annotations,
    List<Input$CheckRunOutputImage>? images,
  }) =>
      Input$CheckRunOutput._({
        r'title': title,
        r'summary': summary,
        if (text != null) r'text': text,
        if (annotations != null) r'annotations': annotations,
        if (images != null) r'images': images,
      });

  Input$CheckRunOutput._(this._$data);

  factory Input$CheckRunOutput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    final l$summary = data['summary'];
    result$data['summary'] = (l$summary as String);
    if (data.containsKey('text')) {
      final l$text = data['text'];
      result$data['text'] = (l$text as String?);
    }
    if (data.containsKey('annotations')) {
      final l$annotations = data['annotations'];
      result$data['annotations'] = (l$annotations as List<dynamic>?)
          ?.map((e) =>
              Input$CheckAnnotationData.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('images')) {
      final l$images = data['images'];
      result$data['images'] = (l$images as List<dynamic>?)
          ?.map((e) =>
              Input$CheckRunOutputImage.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CheckRunOutput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get title => (_$data['title'] as String);
  String get summary => (_$data['summary'] as String);
  String? get text => (_$data['text'] as String?);
  List<Input$CheckAnnotationData>? get annotations =>
      (_$data['annotations'] as List<Input$CheckAnnotationData>?);
  List<Input$CheckRunOutputImage>? get images =>
      (_$data['images'] as List<Input$CheckRunOutputImage>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$title = title;
    result$data['title'] = l$title;
    final l$summary = summary;
    result$data['summary'] = l$summary;
    if (_$data.containsKey('text')) {
      final l$text = text;
      result$data['text'] = l$text;
    }
    if (_$data.containsKey('annotations')) {
      final l$annotations = annotations;
      result$data['annotations'] =
          l$annotations?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('images')) {
      final l$images = images;
      result$data['images'] = l$images?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CheckRunOutput<Input$CheckRunOutput> get copyWith =>
      CopyWith$Input$CheckRunOutput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckRunOutput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (l$summary != lOther$summary) {
      return false;
    }
    final l$text = text;
    final lOther$text = other.text;
    if (_$data.containsKey('text') != other._$data.containsKey('text')) {
      return false;
    }
    if (l$text != lOther$text) {
      return false;
    }
    final l$annotations = annotations;
    final lOther$annotations = other.annotations;
    if (_$data.containsKey('annotations') !=
        other._$data.containsKey('annotations')) {
      return false;
    }
    if (l$annotations != null && lOther$annotations != null) {
      if (l$annotations.length != lOther$annotations.length) {
        return false;
      }
      for (int i = 0; i < l$annotations.length; i++) {
        final l$annotations$entry = l$annotations[i];
        final lOther$annotations$entry = lOther$annotations[i];
        if (l$annotations$entry != lOther$annotations$entry) {
          return false;
        }
      }
    } else if (l$annotations != lOther$annotations) {
      return false;
    }
    final l$images = images;
    final lOther$images = other.images;
    if (_$data.containsKey('images') != other._$data.containsKey('images')) {
      return false;
    }
    if (l$images != null && lOther$images != null) {
      if (l$images.length != lOther$images.length) {
        return false;
      }
      for (int i = 0; i < l$images.length; i++) {
        final l$images$entry = l$images[i];
        final lOther$images$entry = lOther$images[i];
        if (l$images$entry != lOther$images$entry) {
          return false;
        }
      }
    } else if (l$images != lOther$images) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$title = title;
    final l$summary = summary;
    final l$text = text;
    final l$annotations = annotations;
    final l$images = images;
    return Object.hashAll([
      l$title,
      l$summary,
      _$data.containsKey('text') ? l$text : const {},
      _$data.containsKey('annotations')
          ? l$annotations == null
              ? null
              : Object.hashAll(l$annotations.map((v) => v))
          : const {},
      _$data.containsKey('images')
          ? l$images == null
              ? null
              : Object.hashAll(l$images.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckRunOutput<TRes> {
  factory CopyWith$Input$CheckRunOutput(
    Input$CheckRunOutput instance,
    TRes Function(Input$CheckRunOutput) then,
  ) = _CopyWithImpl$Input$CheckRunOutput;

  factory CopyWith$Input$CheckRunOutput.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunOutput;

  TRes call({
    String? title,
    String? summary,
    String? text,
    List<Input$CheckAnnotationData>? annotations,
    List<Input$CheckRunOutputImage>? images,
  });
  TRes annotations(
      Iterable<Input$CheckAnnotationData>? Function(
              Iterable<
                  CopyWith$Input$CheckAnnotationData<
                      Input$CheckAnnotationData>>?)
          _fn);
  TRes images(
      Iterable<Input$CheckRunOutputImage>? Function(
              Iterable<
                  CopyWith$Input$CheckRunOutputImage<
                      Input$CheckRunOutputImage>>?)
          _fn);
}

class _CopyWithImpl$Input$CheckRunOutput<TRes>
    implements CopyWith$Input$CheckRunOutput<TRes> {
  _CopyWithImpl$Input$CheckRunOutput(
    this._instance,
    this._then,
  );

  final Input$CheckRunOutput _instance;

  final TRes Function(Input$CheckRunOutput) _then;

  static const _undefined = {};

  TRes call({
    Object? title = _undefined,
    Object? summary = _undefined,
    Object? text = _undefined,
    Object? annotations = _undefined,
    Object? images = _undefined,
  }) =>
      _then(Input$CheckRunOutput._({
        ..._instance._$data,
        if (title != _undefined && title != null) 'title': (title as String),
        if (summary != _undefined && summary != null)
          'summary': (summary as String),
        if (text != _undefined) 'text': (text as String?),
        if (annotations != _undefined)
          'annotations': (annotations as List<Input$CheckAnnotationData>?),
        if (images != _undefined)
          'images': (images as List<Input$CheckRunOutputImage>?),
      }));
  TRes annotations(
          Iterable<Input$CheckAnnotationData>? Function(
                  Iterable<
                      CopyWith$Input$CheckAnnotationData<
                          Input$CheckAnnotationData>>?)
              _fn) =>
      call(
          annotations: _fn(_instance.annotations
              ?.map((e) => CopyWith$Input$CheckAnnotationData(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes images(
          Iterable<Input$CheckRunOutputImage>? Function(
                  Iterable<
                      CopyWith$Input$CheckRunOutputImage<
                          Input$CheckRunOutputImage>>?)
              _fn) =>
      call(
          images: _fn(
              _instance.images?.map((e) => CopyWith$Input$CheckRunOutputImage(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CheckRunOutput<TRes>
    implements CopyWith$Input$CheckRunOutput<TRes> {
  _CopyWithStubImpl$Input$CheckRunOutput(this._res);

  TRes _res;

  call({
    String? title,
    String? summary,
    String? text,
    List<Input$CheckAnnotationData>? annotations,
    List<Input$CheckRunOutputImage>? images,
  }) =>
      _res;
  annotations(_fn) => _res;
  images(_fn) => _res;
}

class Input$CheckRunOutputImage {
  factory Input$CheckRunOutputImage({
    required String alt,
    required String imageUrl,
    String? caption,
  }) =>
      Input$CheckRunOutputImage._({
        r'alt': alt,
        r'imageUrl': imageUrl,
        if (caption != null) r'caption': caption,
      });

  Input$CheckRunOutputImage._(this._$data);

  factory Input$CheckRunOutputImage.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$alt = data['alt'];
    result$data['alt'] = (l$alt as String);
    final l$imageUrl = data['imageUrl'];
    result$data['imageUrl'] = (l$imageUrl as String);
    if (data.containsKey('caption')) {
      final l$caption = data['caption'];
      result$data['caption'] = (l$caption as String?);
    }
    return Input$CheckRunOutputImage._(result$data);
  }

  Map<String, dynamic> _$data;

  String get alt => (_$data['alt'] as String);
  String get imageUrl => (_$data['imageUrl'] as String);
  String? get caption => (_$data['caption'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$alt = alt;
    result$data['alt'] = l$alt;
    final l$imageUrl = imageUrl;
    result$data['imageUrl'] = l$imageUrl;
    if (_$data.containsKey('caption')) {
      final l$caption = caption;
      result$data['caption'] = l$caption;
    }
    return result$data;
  }

  CopyWith$Input$CheckRunOutputImage<Input$CheckRunOutputImage> get copyWith =>
      CopyWith$Input$CheckRunOutputImage(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckRunOutputImage) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$alt = alt;
    final lOther$alt = other.alt;
    if (l$alt != lOther$alt) {
      return false;
    }
    final l$imageUrl = imageUrl;
    final lOther$imageUrl = other.imageUrl;
    if (l$imageUrl != lOther$imageUrl) {
      return false;
    }
    final l$caption = caption;
    final lOther$caption = other.caption;
    if (_$data.containsKey('caption') != other._$data.containsKey('caption')) {
      return false;
    }
    if (l$caption != lOther$caption) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$alt = alt;
    final l$imageUrl = imageUrl;
    final l$caption = caption;
    return Object.hashAll([
      l$alt,
      l$imageUrl,
      _$data.containsKey('caption') ? l$caption : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckRunOutputImage<TRes> {
  factory CopyWith$Input$CheckRunOutputImage(
    Input$CheckRunOutputImage instance,
    TRes Function(Input$CheckRunOutputImage) then,
  ) = _CopyWithImpl$Input$CheckRunOutputImage;

  factory CopyWith$Input$CheckRunOutputImage.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunOutputImage;

  TRes call({
    String? alt,
    String? imageUrl,
    String? caption,
  });
}

class _CopyWithImpl$Input$CheckRunOutputImage<TRes>
    implements CopyWith$Input$CheckRunOutputImage<TRes> {
  _CopyWithImpl$Input$CheckRunOutputImage(
    this._instance,
    this._then,
  );

  final Input$CheckRunOutputImage _instance;

  final TRes Function(Input$CheckRunOutputImage) _then;

  static const _undefined = {};

  TRes call({
    Object? alt = _undefined,
    Object? imageUrl = _undefined,
    Object? caption = _undefined,
  }) =>
      _then(Input$CheckRunOutputImage._({
        ..._instance._$data,
        if (alt != _undefined && alt != null) 'alt': (alt as String),
        if (imageUrl != _undefined && imageUrl != null)
          'imageUrl': (imageUrl as String),
        if (caption != _undefined) 'caption': (caption as String?),
      }));
}

class _CopyWithStubImpl$Input$CheckRunOutputImage<TRes>
    implements CopyWith$Input$CheckRunOutputImage<TRes> {
  _CopyWithStubImpl$Input$CheckRunOutputImage(this._res);

  TRes _res;

  call({
    String? alt,
    String? imageUrl,
    String? caption,
  }) =>
      _res;
}

class Input$CheckSuiteAutoTriggerPreference {
  factory Input$CheckSuiteAutoTriggerPreference({
    required String appId,
    required bool setting,
  }) =>
      Input$CheckSuiteAutoTriggerPreference._({
        r'appId': appId,
        r'setting': setting,
      });

  Input$CheckSuiteAutoTriggerPreference._(this._$data);

  factory Input$CheckSuiteAutoTriggerPreference.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$appId = data['appId'];
    result$data['appId'] = (l$appId as String);
    final l$setting = data['setting'];
    result$data['setting'] = (l$setting as bool);
    return Input$CheckSuiteAutoTriggerPreference._(result$data);
  }

  Map<String, dynamic> _$data;

  String get appId => (_$data['appId'] as String);
  bool get setting => (_$data['setting'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$appId = appId;
    result$data['appId'] = l$appId;
    final l$setting = setting;
    result$data['setting'] = l$setting;
    return result$data;
  }

  CopyWith$Input$CheckSuiteAutoTriggerPreference<
          Input$CheckSuiteAutoTriggerPreference>
      get copyWith => CopyWith$Input$CheckSuiteAutoTriggerPreference(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckSuiteAutoTriggerPreference) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (l$appId != lOther$appId) {
      return false;
    }
    final l$setting = setting;
    final lOther$setting = other.setting;
    if (l$setting != lOther$setting) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$appId = appId;
    final l$setting = setting;
    return Object.hashAll([
      l$appId,
      l$setting,
    ]);
  }
}

abstract class CopyWith$Input$CheckSuiteAutoTriggerPreference<TRes> {
  factory CopyWith$Input$CheckSuiteAutoTriggerPreference(
    Input$CheckSuiteAutoTriggerPreference instance,
    TRes Function(Input$CheckSuiteAutoTriggerPreference) then,
  ) = _CopyWithImpl$Input$CheckSuiteAutoTriggerPreference;

  factory CopyWith$Input$CheckSuiteAutoTriggerPreference.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckSuiteAutoTriggerPreference;

  TRes call({
    String? appId,
    bool? setting,
  });
}

class _CopyWithImpl$Input$CheckSuiteAutoTriggerPreference<TRes>
    implements CopyWith$Input$CheckSuiteAutoTriggerPreference<TRes> {
  _CopyWithImpl$Input$CheckSuiteAutoTriggerPreference(
    this._instance,
    this._then,
  );

  final Input$CheckSuiteAutoTriggerPreference _instance;

  final TRes Function(Input$CheckSuiteAutoTriggerPreference) _then;

  static const _undefined = {};

  TRes call({
    Object? appId = _undefined,
    Object? setting = _undefined,
  }) =>
      _then(Input$CheckSuiteAutoTriggerPreference._({
        ..._instance._$data,
        if (appId != _undefined && appId != null) 'appId': (appId as String),
        if (setting != _undefined && setting != null)
          'setting': (setting as bool),
      }));
}

class _CopyWithStubImpl$Input$CheckSuiteAutoTriggerPreference<TRes>
    implements CopyWith$Input$CheckSuiteAutoTriggerPreference<TRes> {
  _CopyWithStubImpl$Input$CheckSuiteAutoTriggerPreference(this._res);

  TRes _res;

  call({
    String? appId,
    bool? setting,
  }) =>
      _res;
}

class Input$CheckSuiteFilter {
  factory Input$CheckSuiteFilter({
    int? appId,
    String? checkName,
  }) =>
      Input$CheckSuiteFilter._({
        if (appId != null) r'appId': appId,
        if (checkName != null) r'checkName': checkName,
      });

  Input$CheckSuiteFilter._(this._$data);

  factory Input$CheckSuiteFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('appId')) {
      final l$appId = data['appId'];
      result$data['appId'] = (l$appId as int?);
    }
    if (data.containsKey('checkName')) {
      final l$checkName = data['checkName'];
      result$data['checkName'] = (l$checkName as String?);
    }
    return Input$CheckSuiteFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get appId => (_$data['appId'] as int?);
  String? get checkName => (_$data['checkName'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('appId')) {
      final l$appId = appId;
      result$data['appId'] = l$appId;
    }
    if (_$data.containsKey('checkName')) {
      final l$checkName = checkName;
      result$data['checkName'] = l$checkName;
    }
    return result$data;
  }

  CopyWith$Input$CheckSuiteFilter<Input$CheckSuiteFilter> get copyWith =>
      CopyWith$Input$CheckSuiteFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckSuiteFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (_$data.containsKey('appId') != other._$data.containsKey('appId')) {
      return false;
    }
    if (l$appId != lOther$appId) {
      return false;
    }
    final l$checkName = checkName;
    final lOther$checkName = other.checkName;
    if (_$data.containsKey('checkName') !=
        other._$data.containsKey('checkName')) {
      return false;
    }
    if (l$checkName != lOther$checkName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$appId = appId;
    final l$checkName = checkName;
    return Object.hashAll([
      _$data.containsKey('appId') ? l$appId : const {},
      _$data.containsKey('checkName') ? l$checkName : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckSuiteFilter<TRes> {
  factory CopyWith$Input$CheckSuiteFilter(
    Input$CheckSuiteFilter instance,
    TRes Function(Input$CheckSuiteFilter) then,
  ) = _CopyWithImpl$Input$CheckSuiteFilter;

  factory CopyWith$Input$CheckSuiteFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckSuiteFilter;

  TRes call({
    int? appId,
    String? checkName,
  });
}

class _CopyWithImpl$Input$CheckSuiteFilter<TRes>
    implements CopyWith$Input$CheckSuiteFilter<TRes> {
  _CopyWithImpl$Input$CheckSuiteFilter(
    this._instance,
    this._then,
  );

  final Input$CheckSuiteFilter _instance;

  final TRes Function(Input$CheckSuiteFilter) _then;

  static const _undefined = {};

  TRes call({
    Object? appId = _undefined,
    Object? checkName = _undefined,
  }) =>
      _then(Input$CheckSuiteFilter._({
        ..._instance._$data,
        if (appId != _undefined) 'appId': (appId as int?),
        if (checkName != _undefined) 'checkName': (checkName as String?),
      }));
}

class _CopyWithStubImpl$Input$CheckSuiteFilter<TRes>
    implements CopyWith$Input$CheckSuiteFilter<TRes> {
  _CopyWithStubImpl$Input$CheckSuiteFilter(this._res);

  TRes _res;

  call({
    int? appId,
    String? checkName,
  }) =>
      _res;
}

class Input$ClearLabelsFromLabelableInput {
  factory Input$ClearLabelsFromLabelableInput({
    required String labelableId,
    String? clientMutationId,
  }) =>
      Input$ClearLabelsFromLabelableInput._({
        r'labelableId': labelableId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ClearLabelsFromLabelableInput._(this._$data);

  factory Input$ClearLabelsFromLabelableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$labelableId = data['labelableId'];
    result$data['labelableId'] = (l$labelableId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ClearLabelsFromLabelableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get labelableId => (_$data['labelableId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$labelableId = labelableId;
    result$data['labelableId'] = l$labelableId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ClearLabelsFromLabelableInput<
          Input$ClearLabelsFromLabelableInput>
      get copyWith => CopyWith$Input$ClearLabelsFromLabelableInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClearLabelsFromLabelableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$labelableId = labelableId;
    final lOther$labelableId = other.labelableId;
    if (l$labelableId != lOther$labelableId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$labelableId = labelableId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$labelableId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ClearLabelsFromLabelableInput<TRes> {
  factory CopyWith$Input$ClearLabelsFromLabelableInput(
    Input$ClearLabelsFromLabelableInput instance,
    TRes Function(Input$ClearLabelsFromLabelableInput) then,
  ) = _CopyWithImpl$Input$ClearLabelsFromLabelableInput;

  factory CopyWith$Input$ClearLabelsFromLabelableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClearLabelsFromLabelableInput;

  TRes call({
    String? labelableId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ClearLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$ClearLabelsFromLabelableInput<TRes> {
  _CopyWithImpl$Input$ClearLabelsFromLabelableInput(
    this._instance,
    this._then,
  );

  final Input$ClearLabelsFromLabelableInput _instance;

  final TRes Function(Input$ClearLabelsFromLabelableInput) _then;

  static const _undefined = {};

  TRes call({
    Object? labelableId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ClearLabelsFromLabelableInput._({
        ..._instance._$data,
        if (labelableId != _undefined && labelableId != null)
          'labelableId': (labelableId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ClearLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$ClearLabelsFromLabelableInput<TRes> {
  _CopyWithStubImpl$Input$ClearLabelsFromLabelableInput(this._res);

  TRes _res;

  call({
    String? labelableId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ClearProjectV2ItemFieldValueInput {
  factory Input$ClearProjectV2ItemFieldValueInput({
    required String projectId,
    required String itemId,
    required String fieldId,
    String? clientMutationId,
  }) =>
      Input$ClearProjectV2ItemFieldValueInput._({
        r'projectId': projectId,
        r'itemId': itemId,
        r'fieldId': fieldId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ClearProjectV2ItemFieldValueInput._(this._$data);

  factory Input$ClearProjectV2ItemFieldValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$fieldId = data['fieldId'];
    result$data['fieldId'] = (l$fieldId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ClearProjectV2ItemFieldValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get itemId => (_$data['itemId'] as String);
  String get fieldId => (_$data['fieldId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$fieldId = fieldId;
    result$data['fieldId'] = l$fieldId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ClearProjectV2ItemFieldValueInput<
          Input$ClearProjectV2ItemFieldValueInput>
      get copyWith => CopyWith$Input$ClearProjectV2ItemFieldValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClearProjectV2ItemFieldValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$fieldId = fieldId;
    final lOther$fieldId = other.fieldId;
    if (l$fieldId != lOther$fieldId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$itemId = itemId;
    final l$fieldId = fieldId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$itemId,
      l$fieldId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ClearProjectV2ItemFieldValueInput<TRes> {
  factory CopyWith$Input$ClearProjectV2ItemFieldValueInput(
    Input$ClearProjectV2ItemFieldValueInput instance,
    TRes Function(Input$ClearProjectV2ItemFieldValueInput) then,
  ) = _CopyWithImpl$Input$ClearProjectV2ItemFieldValueInput;

  factory CopyWith$Input$ClearProjectV2ItemFieldValueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClearProjectV2ItemFieldValueInput;

  TRes call({
    String? projectId,
    String? itemId,
    String? fieldId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ClearProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$ClearProjectV2ItemFieldValueInput<TRes> {
  _CopyWithImpl$Input$ClearProjectV2ItemFieldValueInput(
    this._instance,
    this._then,
  );

  final Input$ClearProjectV2ItemFieldValueInput _instance;

  final TRes Function(Input$ClearProjectV2ItemFieldValueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? itemId = _undefined,
    Object? fieldId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ClearProjectV2ItemFieldValueInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (fieldId != _undefined && fieldId != null)
          'fieldId': (fieldId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ClearProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$ClearProjectV2ItemFieldValueInput<TRes> {
  _CopyWithStubImpl$Input$ClearProjectV2ItemFieldValueInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? itemId,
    String? fieldId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CloneProjectInput {
  factory Input$CloneProjectInput({
    required String targetOwnerId,
    required String sourceId,
    required bool includeWorkflows,
    required String name,
    String? body,
    bool? public,
    String? clientMutationId,
  }) =>
      Input$CloneProjectInput._({
        r'targetOwnerId': targetOwnerId,
        r'sourceId': sourceId,
        r'includeWorkflows': includeWorkflows,
        r'name': name,
        if (body != null) r'body': body,
        if (public != null) r'public': public,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CloneProjectInput._(this._$data);

  factory Input$CloneProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$targetOwnerId = data['targetOwnerId'];
    result$data['targetOwnerId'] = (l$targetOwnerId as String);
    final l$sourceId = data['sourceId'];
    result$data['sourceId'] = (l$sourceId as String);
    final l$includeWorkflows = data['includeWorkflows'];
    result$data['includeWorkflows'] = (l$includeWorkflows as bool);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CloneProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get targetOwnerId => (_$data['targetOwnerId'] as String);
  String get sourceId => (_$data['sourceId'] as String);
  bool get includeWorkflows => (_$data['includeWorkflows'] as bool);
  String get name => (_$data['name'] as String);
  String? get body => (_$data['body'] as String?);
  bool? get public => (_$data['public'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$targetOwnerId = targetOwnerId;
    result$data['targetOwnerId'] = l$targetOwnerId;
    final l$sourceId = sourceId;
    result$data['sourceId'] = l$sourceId;
    final l$includeWorkflows = includeWorkflows;
    result$data['includeWorkflows'] = l$includeWorkflows;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CloneProjectInput<Input$CloneProjectInput> get copyWith =>
      CopyWith$Input$CloneProjectInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CloneProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$targetOwnerId = targetOwnerId;
    final lOther$targetOwnerId = other.targetOwnerId;
    if (l$targetOwnerId != lOther$targetOwnerId) {
      return false;
    }
    final l$sourceId = sourceId;
    final lOther$sourceId = other.sourceId;
    if (l$sourceId != lOther$sourceId) {
      return false;
    }
    final l$includeWorkflows = includeWorkflows;
    final lOther$includeWorkflows = other.includeWorkflows;
    if (l$includeWorkflows != lOther$includeWorkflows) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$targetOwnerId = targetOwnerId;
    final l$sourceId = sourceId;
    final l$includeWorkflows = includeWorkflows;
    final l$name = name;
    final l$body = body;
    final l$public = public;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$targetOwnerId,
      l$sourceId,
      l$includeWorkflows,
      l$name,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('public') ? l$public : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CloneProjectInput<TRes> {
  factory CopyWith$Input$CloneProjectInput(
    Input$CloneProjectInput instance,
    TRes Function(Input$CloneProjectInput) then,
  ) = _CopyWithImpl$Input$CloneProjectInput;

  factory CopyWith$Input$CloneProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CloneProjectInput;

  TRes call({
    String? targetOwnerId,
    String? sourceId,
    bool? includeWorkflows,
    String? name,
    String? body,
    bool? public,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CloneProjectInput<TRes>
    implements CopyWith$Input$CloneProjectInput<TRes> {
  _CopyWithImpl$Input$CloneProjectInput(
    this._instance,
    this._then,
  );

  final Input$CloneProjectInput _instance;

  final TRes Function(Input$CloneProjectInput) _then;

  static const _undefined = {};

  TRes call({
    Object? targetOwnerId = _undefined,
    Object? sourceId = _undefined,
    Object? includeWorkflows = _undefined,
    Object? name = _undefined,
    Object? body = _undefined,
    Object? public = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CloneProjectInput._({
        ..._instance._$data,
        if (targetOwnerId != _undefined && targetOwnerId != null)
          'targetOwnerId': (targetOwnerId as String),
        if (sourceId != _undefined && sourceId != null)
          'sourceId': (sourceId as String),
        if (includeWorkflows != _undefined && includeWorkflows != null)
          'includeWorkflows': (includeWorkflows as bool),
        if (name != _undefined && name != null) 'name': (name as String),
        if (body != _undefined) 'body': (body as String?),
        if (public != _undefined) 'public': (public as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CloneProjectInput<TRes>
    implements CopyWith$Input$CloneProjectInput<TRes> {
  _CopyWithStubImpl$Input$CloneProjectInput(this._res);

  TRes _res;

  call({
    String? targetOwnerId,
    String? sourceId,
    bool? includeWorkflows,
    String? name,
    String? body,
    bool? public,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CloneTemplateRepositoryInput {
  factory Input$CloneTemplateRepositoryInput({
    required String repositoryId,
    required String name,
    required String ownerId,
    String? description,
    required Enum$RepositoryVisibility visibility,
    bool? includeAllBranches,
    String? clientMutationId,
  }) =>
      Input$CloneTemplateRepositoryInput._({
        r'repositoryId': repositoryId,
        r'name': name,
        r'ownerId': ownerId,
        if (description != null) r'description': description,
        r'visibility': visibility,
        if (includeAllBranches != null)
          r'includeAllBranches': includeAllBranches,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CloneTemplateRepositoryInput._(this._$data);

  factory Input$CloneTemplateRepositoryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$visibility = data['visibility'];
    result$data['visibility'] =
        fromJson$Enum$RepositoryVisibility((l$visibility as String));
    if (data.containsKey('includeAllBranches')) {
      final l$includeAllBranches = data['includeAllBranches'];
      result$data['includeAllBranches'] = (l$includeAllBranches as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CloneTemplateRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get name => (_$data['name'] as String);
  String get ownerId => (_$data['ownerId'] as String);
  String? get description => (_$data['description'] as String?);
  Enum$RepositoryVisibility get visibility =>
      (_$data['visibility'] as Enum$RepositoryVisibility);
  bool? get includeAllBranches => (_$data['includeAllBranches'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$name = name;
    result$data['name'] = l$name;
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$visibility = visibility;
    result$data['visibility'] = toJson$Enum$RepositoryVisibility(l$visibility);
    if (_$data.containsKey('includeAllBranches')) {
      final l$includeAllBranches = includeAllBranches;
      result$data['includeAllBranches'] = l$includeAllBranches;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CloneTemplateRepositoryInput<
          Input$CloneTemplateRepositoryInput>
      get copyWith => CopyWith$Input$CloneTemplateRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CloneTemplateRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$visibility = visibility;
    final lOther$visibility = other.visibility;
    if (l$visibility != lOther$visibility) {
      return false;
    }
    final l$includeAllBranches = includeAllBranches;
    final lOther$includeAllBranches = other.includeAllBranches;
    if (_$data.containsKey('includeAllBranches') !=
        other._$data.containsKey('includeAllBranches')) {
      return false;
    }
    if (l$includeAllBranches != lOther$includeAllBranches) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$ownerId = ownerId;
    final l$description = description;
    final l$visibility = visibility;
    final l$includeAllBranches = includeAllBranches;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$name,
      l$ownerId,
      _$data.containsKey('description') ? l$description : const {},
      l$visibility,
      _$data.containsKey('includeAllBranches')
          ? l$includeAllBranches
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CloneTemplateRepositoryInput<TRes> {
  factory CopyWith$Input$CloneTemplateRepositoryInput(
    Input$CloneTemplateRepositoryInput instance,
    TRes Function(Input$CloneTemplateRepositoryInput) then,
  ) = _CopyWithImpl$Input$CloneTemplateRepositoryInput;

  factory CopyWith$Input$CloneTemplateRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CloneTemplateRepositoryInput;

  TRes call({
    String? repositoryId,
    String? name,
    String? ownerId,
    String? description,
    Enum$RepositoryVisibility? visibility,
    bool? includeAllBranches,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CloneTemplateRepositoryInput<TRes>
    implements CopyWith$Input$CloneTemplateRepositoryInput<TRes> {
  _CopyWithImpl$Input$CloneTemplateRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$CloneTemplateRepositoryInput _instance;

  final TRes Function(Input$CloneTemplateRepositoryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? ownerId = _undefined,
    Object? description = _undefined,
    Object? visibility = _undefined,
    Object? includeAllBranches = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CloneTemplateRepositoryInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (description != _undefined) 'description': (description as String?),
        if (visibility != _undefined && visibility != null)
          'visibility': (visibility as Enum$RepositoryVisibility),
        if (includeAllBranches != _undefined)
          'includeAllBranches': (includeAllBranches as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CloneTemplateRepositoryInput<TRes>
    implements CopyWith$Input$CloneTemplateRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$CloneTemplateRepositoryInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? name,
    String? ownerId,
    String? description,
    Enum$RepositoryVisibility? visibility,
    bool? includeAllBranches,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CloseIssueInput {
  factory Input$CloseIssueInput({
    required String issueId,
    Enum$IssueClosedStateReason? stateReason,
    String? clientMutationId,
  }) =>
      Input$CloseIssueInput._({
        r'issueId': issueId,
        if (stateReason != null) r'stateReason': stateReason,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CloseIssueInput._(this._$data);

  factory Input$CloseIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    if (data.containsKey('stateReason')) {
      final l$stateReason = data['stateReason'];
      result$data['stateReason'] = l$stateReason == null
          ? null
          : fromJson$Enum$IssueClosedStateReason((l$stateReason as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CloseIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get issueId => (_$data['issueId'] as String);
  Enum$IssueClosedStateReason? get stateReason =>
      (_$data['stateReason'] as Enum$IssueClosedStateReason?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    if (_$data.containsKey('stateReason')) {
      final l$stateReason = stateReason;
      result$data['stateReason'] = l$stateReason == null
          ? null
          : toJson$Enum$IssueClosedStateReason(l$stateReason);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CloseIssueInput<Input$CloseIssueInput> get copyWith =>
      CopyWith$Input$CloseIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CloseIssueInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$stateReason = stateReason;
    final lOther$stateReason = other.stateReason;
    if (_$data.containsKey('stateReason') !=
        other._$data.containsKey('stateReason')) {
      return false;
    }
    if (l$stateReason != lOther$stateReason) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$issueId = issueId;
    final l$stateReason = stateReason;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$issueId,
      _$data.containsKey('stateReason') ? l$stateReason : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CloseIssueInput<TRes> {
  factory CopyWith$Input$CloseIssueInput(
    Input$CloseIssueInput instance,
    TRes Function(Input$CloseIssueInput) then,
  ) = _CopyWithImpl$Input$CloseIssueInput;

  factory CopyWith$Input$CloseIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CloseIssueInput;

  TRes call({
    String? issueId,
    Enum$IssueClosedStateReason? stateReason,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CloseIssueInput<TRes>
    implements CopyWith$Input$CloseIssueInput<TRes> {
  _CopyWithImpl$Input$CloseIssueInput(
    this._instance,
    this._then,
  );

  final Input$CloseIssueInput _instance;

  final TRes Function(Input$CloseIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? issueId = _undefined,
    Object? stateReason = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CloseIssueInput._({
        ..._instance._$data,
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (stateReason != _undefined)
          'stateReason': (stateReason as Enum$IssueClosedStateReason?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CloseIssueInput<TRes>
    implements CopyWith$Input$CloseIssueInput<TRes> {
  _CopyWithStubImpl$Input$CloseIssueInput(this._res);

  TRes _res;

  call({
    String? issueId,
    Enum$IssueClosedStateReason? stateReason,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ClosePullRequestInput {
  factory Input$ClosePullRequestInput({
    required String pullRequestId,
    String? clientMutationId,
  }) =>
      Input$ClosePullRequestInput._({
        r'pullRequestId': pullRequestId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ClosePullRequestInput._(this._$data);

  factory Input$ClosePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ClosePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ClosePullRequestInput<Input$ClosePullRequestInput>
      get copyWith => CopyWith$Input$ClosePullRequestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClosePullRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ClosePullRequestInput<TRes> {
  factory CopyWith$Input$ClosePullRequestInput(
    Input$ClosePullRequestInput instance,
    TRes Function(Input$ClosePullRequestInput) then,
  ) = _CopyWithImpl$Input$ClosePullRequestInput;

  factory CopyWith$Input$ClosePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClosePullRequestInput;

  TRes call({
    String? pullRequestId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ClosePullRequestInput<TRes>
    implements CopyWith$Input$ClosePullRequestInput<TRes> {
  _CopyWithImpl$Input$ClosePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$ClosePullRequestInput _instance;

  final TRes Function(Input$ClosePullRequestInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ClosePullRequestInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ClosePullRequestInput<TRes>
    implements CopyWith$Input$ClosePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$ClosePullRequestInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CommitAuthor {
  factory Input$CommitAuthor({
    String? id,
    List<String>? emails,
  }) =>
      Input$CommitAuthor._({
        if (id != null) r'id': id,
        if (emails != null) r'emails': emails,
      });

  Input$CommitAuthor._(this._$data);

  factory Input$CommitAuthor.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('emails')) {
      final l$emails = data['emails'];
      result$data['emails'] =
          (l$emails as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$CommitAuthor._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  List<String>? get emails => (_$data['emails'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('emails')) {
      final l$emails = emails;
      result$data['emails'] = l$emails?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$CommitAuthor<Input$CommitAuthor> get copyWith =>
      CopyWith$Input$CommitAuthor(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommitAuthor) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$emails = emails;
    final lOther$emails = other.emails;
    if (_$data.containsKey('emails') != other._$data.containsKey('emails')) {
      return false;
    }
    if (l$emails != null && lOther$emails != null) {
      if (l$emails.length != lOther$emails.length) {
        return false;
      }
      for (int i = 0; i < l$emails.length; i++) {
        final l$emails$entry = l$emails[i];
        final lOther$emails$entry = lOther$emails[i];
        if (l$emails$entry != lOther$emails$entry) {
          return false;
        }
      }
    } else if (l$emails != lOther$emails) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$emails = emails;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('emails')
          ? l$emails == null
              ? null
              : Object.hashAll(l$emails.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommitAuthor<TRes> {
  factory CopyWith$Input$CommitAuthor(
    Input$CommitAuthor instance,
    TRes Function(Input$CommitAuthor) then,
  ) = _CopyWithImpl$Input$CommitAuthor;

  factory CopyWith$Input$CommitAuthor.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitAuthor;

  TRes call({
    String? id,
    List<String>? emails,
  });
}

class _CopyWithImpl$Input$CommitAuthor<TRes>
    implements CopyWith$Input$CommitAuthor<TRes> {
  _CopyWithImpl$Input$CommitAuthor(
    this._instance,
    this._then,
  );

  final Input$CommitAuthor _instance;

  final TRes Function(Input$CommitAuthor) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? emails = _undefined,
  }) =>
      _then(Input$CommitAuthor._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (emails != _undefined) 'emails': (emails as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$CommitAuthor<TRes>
    implements CopyWith$Input$CommitAuthor<TRes> {
  _CopyWithStubImpl$Input$CommitAuthor(this._res);

  TRes _res;

  call({
    String? id,
    List<String>? emails,
  }) =>
      _res;
}

class Input$CommitContributionOrder {
  factory Input$CommitContributionOrder({
    required Enum$CommitContributionOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$CommitContributionOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$CommitContributionOrder._(this._$data);

  factory Input$CommitContributionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$CommitContributionOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$CommitContributionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CommitContributionOrderField get field =>
      (_$data['field'] as Enum$CommitContributionOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$CommitContributionOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$CommitContributionOrder<Input$CommitContributionOrder>
      get copyWith => CopyWith$Input$CommitContributionOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommitContributionOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$CommitContributionOrder<TRes> {
  factory CopyWith$Input$CommitContributionOrder(
    Input$CommitContributionOrder instance,
    TRes Function(Input$CommitContributionOrder) then,
  ) = _CopyWithImpl$Input$CommitContributionOrder;

  factory CopyWith$Input$CommitContributionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitContributionOrder;

  TRes call({
    Enum$CommitContributionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$CommitContributionOrder<TRes>
    implements CopyWith$Input$CommitContributionOrder<TRes> {
  _CopyWithImpl$Input$CommitContributionOrder(
    this._instance,
    this._then,
  );

  final Input$CommitContributionOrder _instance;

  final TRes Function(Input$CommitContributionOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$CommitContributionOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$CommitContributionOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$CommitContributionOrder<TRes>
    implements CopyWith$Input$CommitContributionOrder<TRes> {
  _CopyWithStubImpl$Input$CommitContributionOrder(this._res);

  TRes _res;

  call({
    Enum$CommitContributionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$CommitMessage {
  factory Input$CommitMessage({
    required String headline,
    String? body,
  }) =>
      Input$CommitMessage._({
        r'headline': headline,
        if (body != null) r'body': body,
      });

  Input$CommitMessage._(this._$data);

  factory Input$CommitMessage.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$headline = data['headline'];
    result$data['headline'] = (l$headline as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    return Input$CommitMessage._(result$data);
  }

  Map<String, dynamic> _$data;

  String get headline => (_$data['headline'] as String);
  String? get body => (_$data['body'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$headline = headline;
    result$data['headline'] = l$headline;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    return result$data;
  }

  CopyWith$Input$CommitMessage<Input$CommitMessage> get copyWith =>
      CopyWith$Input$CommitMessage(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommitMessage) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$headline = headline;
    final lOther$headline = other.headline;
    if (l$headline != lOther$headline) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$headline = headline;
    final l$body = body;
    return Object.hashAll([
      l$headline,
      _$data.containsKey('body') ? l$body : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommitMessage<TRes> {
  factory CopyWith$Input$CommitMessage(
    Input$CommitMessage instance,
    TRes Function(Input$CommitMessage) then,
  ) = _CopyWithImpl$Input$CommitMessage;

  factory CopyWith$Input$CommitMessage.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitMessage;

  TRes call({
    String? headline,
    String? body,
  });
}

class _CopyWithImpl$Input$CommitMessage<TRes>
    implements CopyWith$Input$CommitMessage<TRes> {
  _CopyWithImpl$Input$CommitMessage(
    this._instance,
    this._then,
  );

  final Input$CommitMessage _instance;

  final TRes Function(Input$CommitMessage) _then;

  static const _undefined = {};

  TRes call({
    Object? headline = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$CommitMessage._({
        ..._instance._$data,
        if (headline != _undefined && headline != null)
          'headline': (headline as String),
        if (body != _undefined) 'body': (body as String?),
      }));
}

class _CopyWithStubImpl$Input$CommitMessage<TRes>
    implements CopyWith$Input$CommitMessage<TRes> {
  _CopyWithStubImpl$Input$CommitMessage(this._res);

  TRes _res;

  call({
    String? headline,
    String? body,
  }) =>
      _res;
}

class Input$CommittableBranch {
  factory Input$CommittableBranch({
    String? id,
    String? repositoryNameWithOwner,
    String? branchName,
  }) =>
      Input$CommittableBranch._({
        if (id != null) r'id': id,
        if (repositoryNameWithOwner != null)
          r'repositoryNameWithOwner': repositoryNameWithOwner,
        if (branchName != null) r'branchName': branchName,
      });

  Input$CommittableBranch._(this._$data);

  factory Input$CommittableBranch.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('repositoryNameWithOwner')) {
      final l$repositoryNameWithOwner = data['repositoryNameWithOwner'];
      result$data['repositoryNameWithOwner'] =
          (l$repositoryNameWithOwner as String?);
    }
    if (data.containsKey('branchName')) {
      final l$branchName = data['branchName'];
      result$data['branchName'] = (l$branchName as String?);
    }
    return Input$CommittableBranch._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get repositoryNameWithOwner =>
      (_$data['repositoryNameWithOwner'] as String?);
  String? get branchName => (_$data['branchName'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('repositoryNameWithOwner')) {
      final l$repositoryNameWithOwner = repositoryNameWithOwner;
      result$data['repositoryNameWithOwner'] = l$repositoryNameWithOwner;
    }
    if (_$data.containsKey('branchName')) {
      final l$branchName = branchName;
      result$data['branchName'] = l$branchName;
    }
    return result$data;
  }

  CopyWith$Input$CommittableBranch<Input$CommittableBranch> get copyWith =>
      CopyWith$Input$CommittableBranch(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommittableBranch) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$repositoryNameWithOwner = repositoryNameWithOwner;
    final lOther$repositoryNameWithOwner = other.repositoryNameWithOwner;
    if (_$data.containsKey('repositoryNameWithOwner') !=
        other._$data.containsKey('repositoryNameWithOwner')) {
      return false;
    }
    if (l$repositoryNameWithOwner != lOther$repositoryNameWithOwner) {
      return false;
    }
    final l$branchName = branchName;
    final lOther$branchName = other.branchName;
    if (_$data.containsKey('branchName') !=
        other._$data.containsKey('branchName')) {
      return false;
    }
    if (l$branchName != lOther$branchName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$repositoryNameWithOwner = repositoryNameWithOwner;
    final l$branchName = branchName;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('repositoryNameWithOwner')
          ? l$repositoryNameWithOwner
          : const {},
      _$data.containsKey('branchName') ? l$branchName : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommittableBranch<TRes> {
  factory CopyWith$Input$CommittableBranch(
    Input$CommittableBranch instance,
    TRes Function(Input$CommittableBranch) then,
  ) = _CopyWithImpl$Input$CommittableBranch;

  factory CopyWith$Input$CommittableBranch.stub(TRes res) =
      _CopyWithStubImpl$Input$CommittableBranch;

  TRes call({
    String? id,
    String? repositoryNameWithOwner,
    String? branchName,
  });
}

class _CopyWithImpl$Input$CommittableBranch<TRes>
    implements CopyWith$Input$CommittableBranch<TRes> {
  _CopyWithImpl$Input$CommittableBranch(
    this._instance,
    this._then,
  );

  final Input$CommittableBranch _instance;

  final TRes Function(Input$CommittableBranch) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? repositoryNameWithOwner = _undefined,
    Object? branchName = _undefined,
  }) =>
      _then(Input$CommittableBranch._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (repositoryNameWithOwner != _undefined)
          'repositoryNameWithOwner': (repositoryNameWithOwner as String?),
        if (branchName != _undefined) 'branchName': (branchName as String?),
      }));
}

class _CopyWithStubImpl$Input$CommittableBranch<TRes>
    implements CopyWith$Input$CommittableBranch<TRes> {
  _CopyWithStubImpl$Input$CommittableBranch(this._res);

  TRes _res;

  call({
    String? id,
    String? repositoryNameWithOwner,
    String? branchName,
  }) =>
      _res;
}

class Input$ContributionOrder {
  factory Input$ContributionOrder({required Enum$OrderDirection direction}) =>
      Input$ContributionOrder._({
        r'direction': direction,
      });

  Input$ContributionOrder._(this._$data);

  factory Input$ContributionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ContributionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ContributionOrder<Input$ContributionOrder> get copyWith =>
      CopyWith$Input$ContributionOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContributionOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    return Object.hashAll([l$direction]);
  }
}

abstract class CopyWith$Input$ContributionOrder<TRes> {
  factory CopyWith$Input$ContributionOrder(
    Input$ContributionOrder instance,
    TRes Function(Input$ContributionOrder) then,
  ) = _CopyWithImpl$Input$ContributionOrder;

  factory CopyWith$Input$ContributionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ContributionOrder;

  TRes call({Enum$OrderDirection? direction});
}

class _CopyWithImpl$Input$ContributionOrder<TRes>
    implements CopyWith$Input$ContributionOrder<TRes> {
  _CopyWithImpl$Input$ContributionOrder(
    this._instance,
    this._then,
  );

  final Input$ContributionOrder _instance;

  final TRes Function(Input$ContributionOrder) _then;

  static const _undefined = {};

  TRes call({Object? direction = _undefined}) =>
      _then(Input$ContributionOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ContributionOrder<TRes>
    implements CopyWith$Input$ContributionOrder<TRes> {
  _CopyWithStubImpl$Input$ContributionOrder(this._res);

  TRes _res;

  call({Enum$OrderDirection? direction}) => _res;
}

class Input$ConvertProjectCardNoteToIssueInput {
  factory Input$ConvertProjectCardNoteToIssueInput({
    required String projectCardId,
    required String repositoryId,
    String? title,
    String? body,
    String? clientMutationId,
  }) =>
      Input$ConvertProjectCardNoteToIssueInput._({
        r'projectCardId': projectCardId,
        r'repositoryId': repositoryId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ConvertProjectCardNoteToIssueInput._(this._$data);

  factory Input$ConvertProjectCardNoteToIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectCardId = data['projectCardId'];
    result$data['projectCardId'] = (l$projectCardId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ConvertProjectCardNoteToIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectCardId => (_$data['projectCardId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  String? get title => (_$data['title'] as String?);
  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectCardId = projectCardId;
    result$data['projectCardId'] = l$projectCardId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ConvertProjectCardNoteToIssueInput<
          Input$ConvertProjectCardNoteToIssueInput>
      get copyWith => CopyWith$Input$ConvertProjectCardNoteToIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ConvertProjectCardNoteToIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectCardId = projectCardId;
    final lOther$projectCardId = other.projectCardId;
    if (l$projectCardId != lOther$projectCardId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectCardId = projectCardId;
    final l$repositoryId = repositoryId;
    final l$title = title;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectCardId,
      l$repositoryId,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConvertProjectCardNoteToIssueInput<TRes> {
  factory CopyWith$Input$ConvertProjectCardNoteToIssueInput(
    Input$ConvertProjectCardNoteToIssueInput instance,
    TRes Function(Input$ConvertProjectCardNoteToIssueInput) then,
  ) = _CopyWithImpl$Input$ConvertProjectCardNoteToIssueInput;

  factory CopyWith$Input$ConvertProjectCardNoteToIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConvertProjectCardNoteToIssueInput;

  TRes call({
    String? projectCardId,
    String? repositoryId,
    String? title,
    String? body,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ConvertProjectCardNoteToIssueInput<TRes>
    implements CopyWith$Input$ConvertProjectCardNoteToIssueInput<TRes> {
  _CopyWithImpl$Input$ConvertProjectCardNoteToIssueInput(
    this._instance,
    this._then,
  );

  final Input$ConvertProjectCardNoteToIssueInput _instance;

  final TRes Function(Input$ConvertProjectCardNoteToIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectCardId = _undefined,
    Object? repositoryId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ConvertProjectCardNoteToIssueInput._({
        ..._instance._$data,
        if (projectCardId != _undefined && projectCardId != null)
          'projectCardId': (projectCardId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ConvertProjectCardNoteToIssueInput<TRes>
    implements CopyWith$Input$ConvertProjectCardNoteToIssueInput<TRes> {
  _CopyWithStubImpl$Input$ConvertProjectCardNoteToIssueInput(this._res);

  TRes _res;

  call({
    String? projectCardId,
    String? repositoryId,
    String? title,
    String? body,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ConvertPullRequestToDraftInput {
  factory Input$ConvertPullRequestToDraftInput({
    required String pullRequestId,
    String? clientMutationId,
  }) =>
      Input$ConvertPullRequestToDraftInput._({
        r'pullRequestId': pullRequestId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ConvertPullRequestToDraftInput._(this._$data);

  factory Input$ConvertPullRequestToDraftInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ConvertPullRequestToDraftInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ConvertPullRequestToDraftInput<
          Input$ConvertPullRequestToDraftInput>
      get copyWith => CopyWith$Input$ConvertPullRequestToDraftInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ConvertPullRequestToDraftInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConvertPullRequestToDraftInput<TRes> {
  factory CopyWith$Input$ConvertPullRequestToDraftInput(
    Input$ConvertPullRequestToDraftInput instance,
    TRes Function(Input$ConvertPullRequestToDraftInput) then,
  ) = _CopyWithImpl$Input$ConvertPullRequestToDraftInput;

  factory CopyWith$Input$ConvertPullRequestToDraftInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConvertPullRequestToDraftInput;

  TRes call({
    String? pullRequestId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ConvertPullRequestToDraftInput<TRes>
    implements CopyWith$Input$ConvertPullRequestToDraftInput<TRes> {
  _CopyWithImpl$Input$ConvertPullRequestToDraftInput(
    this._instance,
    this._then,
  );

  final Input$ConvertPullRequestToDraftInput _instance;

  final TRes Function(Input$ConvertPullRequestToDraftInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ConvertPullRequestToDraftInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ConvertPullRequestToDraftInput<TRes>
    implements CopyWith$Input$ConvertPullRequestToDraftInput<TRes> {
  _CopyWithStubImpl$Input$ConvertPullRequestToDraftInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateBranchProtectionRuleInput {
  factory Input$CreateBranchProtectionRuleInput({
    required String repositoryId,
    required String pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
    String? clientMutationId,
  }) =>
      Input$CreateBranchProtectionRuleInput._({
        r'repositoryId': repositoryId,
        r'pattern': pattern,
        if (requiresApprovingReviews != null)
          r'requiresApprovingReviews': requiresApprovingReviews,
        if (requiredApprovingReviewCount != null)
          r'requiredApprovingReviewCount': requiredApprovingReviewCount,
        if (requiresCommitSignatures != null)
          r'requiresCommitSignatures': requiresCommitSignatures,
        if (requiresLinearHistory != null)
          r'requiresLinearHistory': requiresLinearHistory,
        if (blocksCreations != null) r'blocksCreations': blocksCreations,
        if (allowsForcePushes != null) r'allowsForcePushes': allowsForcePushes,
        if (allowsDeletions != null) r'allowsDeletions': allowsDeletions,
        if (isAdminEnforced != null) r'isAdminEnforced': isAdminEnforced,
        if (requiresStatusChecks != null)
          r'requiresStatusChecks': requiresStatusChecks,
        if (requiresStrictStatusChecks != null)
          r'requiresStrictStatusChecks': requiresStrictStatusChecks,
        if (requiresCodeOwnerReviews != null)
          r'requiresCodeOwnerReviews': requiresCodeOwnerReviews,
        if (dismissesStaleReviews != null)
          r'dismissesStaleReviews': dismissesStaleReviews,
        if (restrictsReviewDismissals != null)
          r'restrictsReviewDismissals': restrictsReviewDismissals,
        if (reviewDismissalActorIds != null)
          r'reviewDismissalActorIds': reviewDismissalActorIds,
        if (bypassPullRequestActorIds != null)
          r'bypassPullRequestActorIds': bypassPullRequestActorIds,
        if (bypassForcePushActorIds != null)
          r'bypassForcePushActorIds': bypassForcePushActorIds,
        if (restrictsPushes != null) r'restrictsPushes': restrictsPushes,
        if (pushActorIds != null) r'pushActorIds': pushActorIds,
        if (requiredStatusCheckContexts != null)
          r'requiredStatusCheckContexts': requiredStatusCheckContexts,
        if (requiredStatusChecks != null)
          r'requiredStatusChecks': requiredStatusChecks,
        if (requiresConversationResolution != null)
          r'requiresConversationResolution': requiresConversationResolution,
        if (requireLastPushApproval != null)
          r'requireLastPushApproval': requireLastPushApproval,
        if (lockBranch != null) r'lockBranch': lockBranch,
        if (lockAllowsFetchAndMerge != null)
          r'lockAllowsFetchAndMerge': lockAllowsFetchAndMerge,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateBranchProtectionRuleInput._(this._$data);

  factory Input$CreateBranchProtectionRuleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$pattern = data['pattern'];
    result$data['pattern'] = (l$pattern as String);
    if (data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = data['requiresApprovingReviews'];
      result$data['requiresApprovingReviews'] =
          (l$requiresApprovingReviews as bool?);
    }
    if (data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount =
          data['requiredApprovingReviewCount'];
      result$data['requiredApprovingReviewCount'] =
          (l$requiredApprovingReviewCount as int?);
    }
    if (data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = data['requiresCommitSignatures'];
      result$data['requiresCommitSignatures'] =
          (l$requiresCommitSignatures as bool?);
    }
    if (data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = data['requiresLinearHistory'];
      result$data['requiresLinearHistory'] = (l$requiresLinearHistory as bool?);
    }
    if (data.containsKey('blocksCreations')) {
      final l$blocksCreations = data['blocksCreations'];
      result$data['blocksCreations'] = (l$blocksCreations as bool?);
    }
    if (data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = data['allowsForcePushes'];
      result$data['allowsForcePushes'] = (l$allowsForcePushes as bool?);
    }
    if (data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = data['allowsDeletions'];
      result$data['allowsDeletions'] = (l$allowsDeletions as bool?);
    }
    if (data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = data['isAdminEnforced'];
      result$data['isAdminEnforced'] = (l$isAdminEnforced as bool?);
    }
    if (data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = data['requiresStatusChecks'];
      result$data['requiresStatusChecks'] = (l$requiresStatusChecks as bool?);
    }
    if (data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = data['requiresStrictStatusChecks'];
      result$data['requiresStrictStatusChecks'] =
          (l$requiresStrictStatusChecks as bool?);
    }
    if (data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = data['requiresCodeOwnerReviews'];
      result$data['requiresCodeOwnerReviews'] =
          (l$requiresCodeOwnerReviews as bool?);
    }
    if (data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = data['dismissesStaleReviews'];
      result$data['dismissesStaleReviews'] = (l$dismissesStaleReviews as bool?);
    }
    if (data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = data['restrictsReviewDismissals'];
      result$data['restrictsReviewDismissals'] =
          (l$restrictsReviewDismissals as bool?);
    }
    if (data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = data['reviewDismissalActorIds'];
      result$data['reviewDismissalActorIds'] =
          (l$reviewDismissalActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = data['bypassPullRequestActorIds'];
      result$data['bypassPullRequestActorIds'] =
          (l$bypassPullRequestActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = data['bypassForcePushActorIds'];
      result$data['bypassForcePushActorIds'] =
          (l$bypassForcePushActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = data['restrictsPushes'];
      result$data['restrictsPushes'] = (l$restrictsPushes as bool?);
    }
    if (data.containsKey('pushActorIds')) {
      final l$pushActorIds = data['pushActorIds'];
      result$data['pushActorIds'] = (l$pushActorIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = data['requiredStatusCheckContexts'];
      result$data['requiredStatusCheckContexts'] =
          (l$requiredStatusCheckContexts as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = data['requiredStatusChecks'];
      result$data['requiredStatusChecks'] =
          (l$requiredStatusChecks as List<dynamic>?)
              ?.map((e) => Input$RequiredStatusCheckInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    if (data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution =
          data['requiresConversationResolution'];
      result$data['requiresConversationResolution'] =
          (l$requiresConversationResolution as bool?);
    }
    if (data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = data['requireLastPushApproval'];
      result$data['requireLastPushApproval'] =
          (l$requireLastPushApproval as bool?);
    }
    if (data.containsKey('lockBranch')) {
      final l$lockBranch = data['lockBranch'];
      result$data['lockBranch'] = (l$lockBranch as bool?);
    }
    if (data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = data['lockAllowsFetchAndMerge'];
      result$data['lockAllowsFetchAndMerge'] =
          (l$lockAllowsFetchAndMerge as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateBranchProtectionRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get pattern => (_$data['pattern'] as String);
  bool? get requiresApprovingReviews =>
      (_$data['requiresApprovingReviews'] as bool?);
  int? get requiredApprovingReviewCount =>
      (_$data['requiredApprovingReviewCount'] as int?);
  bool? get requiresCommitSignatures =>
      (_$data['requiresCommitSignatures'] as bool?);
  bool? get requiresLinearHistory => (_$data['requiresLinearHistory'] as bool?);
  bool? get blocksCreations => (_$data['blocksCreations'] as bool?);
  bool? get allowsForcePushes => (_$data['allowsForcePushes'] as bool?);
  bool? get allowsDeletions => (_$data['allowsDeletions'] as bool?);
  bool? get isAdminEnforced => (_$data['isAdminEnforced'] as bool?);
  bool? get requiresStatusChecks => (_$data['requiresStatusChecks'] as bool?);
  bool? get requiresStrictStatusChecks =>
      (_$data['requiresStrictStatusChecks'] as bool?);
  bool? get requiresCodeOwnerReviews =>
      (_$data['requiresCodeOwnerReviews'] as bool?);
  bool? get dismissesStaleReviews => (_$data['dismissesStaleReviews'] as bool?);
  bool? get restrictsReviewDismissals =>
      (_$data['restrictsReviewDismissals'] as bool?);
  List<String>? get reviewDismissalActorIds =>
      (_$data['reviewDismissalActorIds'] as List<String>?);
  List<String>? get bypassPullRequestActorIds =>
      (_$data['bypassPullRequestActorIds'] as List<String>?);
  List<String>? get bypassForcePushActorIds =>
      (_$data['bypassForcePushActorIds'] as List<String>?);
  bool? get restrictsPushes => (_$data['restrictsPushes'] as bool?);
  List<String>? get pushActorIds => (_$data['pushActorIds'] as List<String>?);
  List<String>? get requiredStatusCheckContexts =>
      (_$data['requiredStatusCheckContexts'] as List<String>?);
  List<Input$RequiredStatusCheckInput>? get requiredStatusChecks =>
      (_$data['requiredStatusChecks'] as List<Input$RequiredStatusCheckInput>?);
  bool? get requiresConversationResolution =>
      (_$data['requiresConversationResolution'] as bool?);
  bool? get requireLastPushApproval =>
      (_$data['requireLastPushApproval'] as bool?);
  bool? get lockBranch => (_$data['lockBranch'] as bool?);
  bool? get lockAllowsFetchAndMerge =>
      (_$data['lockAllowsFetchAndMerge'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$pattern = pattern;
    result$data['pattern'] = l$pattern;
    if (_$data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = requiresApprovingReviews;
      result$data['requiresApprovingReviews'] = l$requiresApprovingReviews;
    }
    if (_$data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
      result$data['requiredApprovingReviewCount'] =
          l$requiredApprovingReviewCount;
    }
    if (_$data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = requiresCommitSignatures;
      result$data['requiresCommitSignatures'] = l$requiresCommitSignatures;
    }
    if (_$data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = requiresLinearHistory;
      result$data['requiresLinearHistory'] = l$requiresLinearHistory;
    }
    if (_$data.containsKey('blocksCreations')) {
      final l$blocksCreations = blocksCreations;
      result$data['blocksCreations'] = l$blocksCreations;
    }
    if (_$data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = allowsForcePushes;
      result$data['allowsForcePushes'] = l$allowsForcePushes;
    }
    if (_$data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = allowsDeletions;
      result$data['allowsDeletions'] = l$allowsDeletions;
    }
    if (_$data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = isAdminEnforced;
      result$data['isAdminEnforced'] = l$isAdminEnforced;
    }
    if (_$data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = requiresStatusChecks;
      result$data['requiresStatusChecks'] = l$requiresStatusChecks;
    }
    if (_$data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
      result$data['requiresStrictStatusChecks'] = l$requiresStrictStatusChecks;
    }
    if (_$data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
      result$data['requiresCodeOwnerReviews'] = l$requiresCodeOwnerReviews;
    }
    if (_$data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = dismissesStaleReviews;
      result$data['dismissesStaleReviews'] = l$dismissesStaleReviews;
    }
    if (_$data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = restrictsReviewDismissals;
      result$data['restrictsReviewDismissals'] = l$restrictsReviewDismissals;
    }
    if (_$data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = reviewDismissalActorIds;
      result$data['reviewDismissalActorIds'] =
          l$reviewDismissalActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
      result$data['bypassPullRequestActorIds'] =
          l$bypassPullRequestActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = bypassForcePushActorIds;
      result$data['bypassForcePushActorIds'] =
          l$bypassForcePushActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = restrictsPushes;
      result$data['restrictsPushes'] = l$restrictsPushes;
    }
    if (_$data.containsKey('pushActorIds')) {
      final l$pushActorIds = pushActorIds;
      result$data['pushActorIds'] = l$pushActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
      result$data['requiredStatusCheckContexts'] =
          l$requiredStatusCheckContexts?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = requiredStatusChecks;
      result$data['requiredStatusChecks'] =
          l$requiredStatusChecks?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution = requiresConversationResolution;
      result$data['requiresConversationResolution'] =
          l$requiresConversationResolution;
    }
    if (_$data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = requireLastPushApproval;
      result$data['requireLastPushApproval'] = l$requireLastPushApproval;
    }
    if (_$data.containsKey('lockBranch')) {
      final l$lockBranch = lockBranch;
      result$data['lockBranch'] = l$lockBranch;
    }
    if (_$data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
      result$data['lockAllowsFetchAndMerge'] = l$lockAllowsFetchAndMerge;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateBranchProtectionRuleInput<
          Input$CreateBranchProtectionRuleInput>
      get copyWith => CopyWith$Input$CreateBranchProtectionRuleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateBranchProtectionRuleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$pattern = pattern;
    final lOther$pattern = other.pattern;
    if (l$pattern != lOther$pattern) {
      return false;
    }
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final lOther$requiresApprovingReviews = other.requiresApprovingReviews;
    if (_$data.containsKey('requiresApprovingReviews') !=
        other._$data.containsKey('requiresApprovingReviews')) {
      return false;
    }
    if (l$requiresApprovingReviews != lOther$requiresApprovingReviews) {
      return false;
    }
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final lOther$requiredApprovingReviewCount =
        other.requiredApprovingReviewCount;
    if (_$data.containsKey('requiredApprovingReviewCount') !=
        other._$data.containsKey('requiredApprovingReviewCount')) {
      return false;
    }
    if (l$requiredApprovingReviewCount != lOther$requiredApprovingReviewCount) {
      return false;
    }
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final lOther$requiresCommitSignatures = other.requiresCommitSignatures;
    if (_$data.containsKey('requiresCommitSignatures') !=
        other._$data.containsKey('requiresCommitSignatures')) {
      return false;
    }
    if (l$requiresCommitSignatures != lOther$requiresCommitSignatures) {
      return false;
    }
    final l$requiresLinearHistory = requiresLinearHistory;
    final lOther$requiresLinearHistory = other.requiresLinearHistory;
    if (_$data.containsKey('requiresLinearHistory') !=
        other._$data.containsKey('requiresLinearHistory')) {
      return false;
    }
    if (l$requiresLinearHistory != lOther$requiresLinearHistory) {
      return false;
    }
    final l$blocksCreations = blocksCreations;
    final lOther$blocksCreations = other.blocksCreations;
    if (_$data.containsKey('blocksCreations') !=
        other._$data.containsKey('blocksCreations')) {
      return false;
    }
    if (l$blocksCreations != lOther$blocksCreations) {
      return false;
    }
    final l$allowsForcePushes = allowsForcePushes;
    final lOther$allowsForcePushes = other.allowsForcePushes;
    if (_$data.containsKey('allowsForcePushes') !=
        other._$data.containsKey('allowsForcePushes')) {
      return false;
    }
    if (l$allowsForcePushes != lOther$allowsForcePushes) {
      return false;
    }
    final l$allowsDeletions = allowsDeletions;
    final lOther$allowsDeletions = other.allowsDeletions;
    if (_$data.containsKey('allowsDeletions') !=
        other._$data.containsKey('allowsDeletions')) {
      return false;
    }
    if (l$allowsDeletions != lOther$allowsDeletions) {
      return false;
    }
    final l$isAdminEnforced = isAdminEnforced;
    final lOther$isAdminEnforced = other.isAdminEnforced;
    if (_$data.containsKey('isAdminEnforced') !=
        other._$data.containsKey('isAdminEnforced')) {
      return false;
    }
    if (l$isAdminEnforced != lOther$isAdminEnforced) {
      return false;
    }
    final l$requiresStatusChecks = requiresStatusChecks;
    final lOther$requiresStatusChecks = other.requiresStatusChecks;
    if (_$data.containsKey('requiresStatusChecks') !=
        other._$data.containsKey('requiresStatusChecks')) {
      return false;
    }
    if (l$requiresStatusChecks != lOther$requiresStatusChecks) {
      return false;
    }
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final lOther$requiresStrictStatusChecks = other.requiresStrictStatusChecks;
    if (_$data.containsKey('requiresStrictStatusChecks') !=
        other._$data.containsKey('requiresStrictStatusChecks')) {
      return false;
    }
    if (l$requiresStrictStatusChecks != lOther$requiresStrictStatusChecks) {
      return false;
    }
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final lOther$requiresCodeOwnerReviews = other.requiresCodeOwnerReviews;
    if (_$data.containsKey('requiresCodeOwnerReviews') !=
        other._$data.containsKey('requiresCodeOwnerReviews')) {
      return false;
    }
    if (l$requiresCodeOwnerReviews != lOther$requiresCodeOwnerReviews) {
      return false;
    }
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final lOther$dismissesStaleReviews = other.dismissesStaleReviews;
    if (_$data.containsKey('dismissesStaleReviews') !=
        other._$data.containsKey('dismissesStaleReviews')) {
      return false;
    }
    if (l$dismissesStaleReviews != lOther$dismissesStaleReviews) {
      return false;
    }
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final lOther$restrictsReviewDismissals = other.restrictsReviewDismissals;
    if (_$data.containsKey('restrictsReviewDismissals') !=
        other._$data.containsKey('restrictsReviewDismissals')) {
      return false;
    }
    if (l$restrictsReviewDismissals != lOther$restrictsReviewDismissals) {
      return false;
    }
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    final lOther$reviewDismissalActorIds = other.reviewDismissalActorIds;
    if (_$data.containsKey('reviewDismissalActorIds') !=
        other._$data.containsKey('reviewDismissalActorIds')) {
      return false;
    }
    if (l$reviewDismissalActorIds != null &&
        lOther$reviewDismissalActorIds != null) {
      if (l$reviewDismissalActorIds.length !=
          lOther$reviewDismissalActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$reviewDismissalActorIds.length; i++) {
        final l$reviewDismissalActorIds$entry = l$reviewDismissalActorIds[i];
        final lOther$reviewDismissalActorIds$entry =
            lOther$reviewDismissalActorIds[i];
        if (l$reviewDismissalActorIds$entry !=
            lOther$reviewDismissalActorIds$entry) {
          return false;
        }
      }
    } else if (l$reviewDismissalActorIds != lOther$reviewDismissalActorIds) {
      return false;
    }
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final lOther$bypassPullRequestActorIds = other.bypassPullRequestActorIds;
    if (_$data.containsKey('bypassPullRequestActorIds') !=
        other._$data.containsKey('bypassPullRequestActorIds')) {
      return false;
    }
    if (l$bypassPullRequestActorIds != null &&
        lOther$bypassPullRequestActorIds != null) {
      if (l$bypassPullRequestActorIds.length !=
          lOther$bypassPullRequestActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassPullRequestActorIds.length; i++) {
        final l$bypassPullRequestActorIds$entry =
            l$bypassPullRequestActorIds[i];
        final lOther$bypassPullRequestActorIds$entry =
            lOther$bypassPullRequestActorIds[i];
        if (l$bypassPullRequestActorIds$entry !=
            lOther$bypassPullRequestActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassPullRequestActorIds !=
        lOther$bypassPullRequestActorIds) {
      return false;
    }
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final lOther$bypassForcePushActorIds = other.bypassForcePushActorIds;
    if (_$data.containsKey('bypassForcePushActorIds') !=
        other._$data.containsKey('bypassForcePushActorIds')) {
      return false;
    }
    if (l$bypassForcePushActorIds != null &&
        lOther$bypassForcePushActorIds != null) {
      if (l$bypassForcePushActorIds.length !=
          lOther$bypassForcePushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassForcePushActorIds.length; i++) {
        final l$bypassForcePushActorIds$entry = l$bypassForcePushActorIds[i];
        final lOther$bypassForcePushActorIds$entry =
            lOther$bypassForcePushActorIds[i];
        if (l$bypassForcePushActorIds$entry !=
            lOther$bypassForcePushActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassForcePushActorIds != lOther$bypassForcePushActorIds) {
      return false;
    }
    final l$restrictsPushes = restrictsPushes;
    final lOther$restrictsPushes = other.restrictsPushes;
    if (_$data.containsKey('restrictsPushes') !=
        other._$data.containsKey('restrictsPushes')) {
      return false;
    }
    if (l$restrictsPushes != lOther$restrictsPushes) {
      return false;
    }
    final l$pushActorIds = pushActorIds;
    final lOther$pushActorIds = other.pushActorIds;
    if (_$data.containsKey('pushActorIds') !=
        other._$data.containsKey('pushActorIds')) {
      return false;
    }
    if (l$pushActorIds != null && lOther$pushActorIds != null) {
      if (l$pushActorIds.length != lOther$pushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$pushActorIds.length; i++) {
        final l$pushActorIds$entry = l$pushActorIds[i];
        final lOther$pushActorIds$entry = lOther$pushActorIds[i];
        if (l$pushActorIds$entry != lOther$pushActorIds$entry) {
          return false;
        }
      }
    } else if (l$pushActorIds != lOther$pushActorIds) {
      return false;
    }
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final lOther$requiredStatusCheckContexts =
        other.requiredStatusCheckContexts;
    if (_$data.containsKey('requiredStatusCheckContexts') !=
        other._$data.containsKey('requiredStatusCheckContexts')) {
      return false;
    }
    if (l$requiredStatusCheckContexts != null &&
        lOther$requiredStatusCheckContexts != null) {
      if (l$requiredStatusCheckContexts.length !=
          lOther$requiredStatusCheckContexts.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusCheckContexts.length; i++) {
        final l$requiredStatusCheckContexts$entry =
            l$requiredStatusCheckContexts[i];
        final lOther$requiredStatusCheckContexts$entry =
            lOther$requiredStatusCheckContexts[i];
        if (l$requiredStatusCheckContexts$entry !=
            lOther$requiredStatusCheckContexts$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusCheckContexts !=
        lOther$requiredStatusCheckContexts) {
      return false;
    }
    final l$requiredStatusChecks = requiredStatusChecks;
    final lOther$requiredStatusChecks = other.requiredStatusChecks;
    if (_$data.containsKey('requiredStatusChecks') !=
        other._$data.containsKey('requiredStatusChecks')) {
      return false;
    }
    if (l$requiredStatusChecks != null && lOther$requiredStatusChecks != null) {
      if (l$requiredStatusChecks.length != lOther$requiredStatusChecks.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusChecks.length; i++) {
        final l$requiredStatusChecks$entry = l$requiredStatusChecks[i];
        final lOther$requiredStatusChecks$entry =
            lOther$requiredStatusChecks[i];
        if (l$requiredStatusChecks$entry != lOther$requiredStatusChecks$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusChecks != lOther$requiredStatusChecks) {
      return false;
    }
    final l$requiresConversationResolution = requiresConversationResolution;
    final lOther$requiresConversationResolution =
        other.requiresConversationResolution;
    if (_$data.containsKey('requiresConversationResolution') !=
        other._$data.containsKey('requiresConversationResolution')) {
      return false;
    }
    if (l$requiresConversationResolution !=
        lOther$requiresConversationResolution) {
      return false;
    }
    final l$requireLastPushApproval = requireLastPushApproval;
    final lOther$requireLastPushApproval = other.requireLastPushApproval;
    if (_$data.containsKey('requireLastPushApproval') !=
        other._$data.containsKey('requireLastPushApproval')) {
      return false;
    }
    if (l$requireLastPushApproval != lOther$requireLastPushApproval) {
      return false;
    }
    final l$lockBranch = lockBranch;
    final lOther$lockBranch = other.lockBranch;
    if (_$data.containsKey('lockBranch') !=
        other._$data.containsKey('lockBranch')) {
      return false;
    }
    if (l$lockBranch != lOther$lockBranch) {
      return false;
    }
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    final lOther$lockAllowsFetchAndMerge = other.lockAllowsFetchAndMerge;
    if (_$data.containsKey('lockAllowsFetchAndMerge') !=
        other._$data.containsKey('lockAllowsFetchAndMerge')) {
      return false;
    }
    if (l$lockAllowsFetchAndMerge != lOther$lockAllowsFetchAndMerge) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$pattern = pattern;
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final l$requiresLinearHistory = requiresLinearHistory;
    final l$blocksCreations = blocksCreations;
    final l$allowsForcePushes = allowsForcePushes;
    final l$allowsDeletions = allowsDeletions;
    final l$isAdminEnforced = isAdminEnforced;
    final l$requiresStatusChecks = requiresStatusChecks;
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final l$restrictsPushes = restrictsPushes;
    final l$pushActorIds = pushActorIds;
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final l$requiredStatusChecks = requiredStatusChecks;
    final l$requiresConversationResolution = requiresConversationResolution;
    final l$requireLastPushApproval = requireLastPushApproval;
    final l$lockBranch = lockBranch;
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$pattern,
      _$data.containsKey('requiresApprovingReviews')
          ? l$requiresApprovingReviews
          : const {},
      _$data.containsKey('requiredApprovingReviewCount')
          ? l$requiredApprovingReviewCount
          : const {},
      _$data.containsKey('requiresCommitSignatures')
          ? l$requiresCommitSignatures
          : const {},
      _$data.containsKey('requiresLinearHistory')
          ? l$requiresLinearHistory
          : const {},
      _$data.containsKey('blocksCreations') ? l$blocksCreations : const {},
      _$data.containsKey('allowsForcePushes') ? l$allowsForcePushes : const {},
      _$data.containsKey('allowsDeletions') ? l$allowsDeletions : const {},
      _$data.containsKey('isAdminEnforced') ? l$isAdminEnforced : const {},
      _$data.containsKey('requiresStatusChecks')
          ? l$requiresStatusChecks
          : const {},
      _$data.containsKey('requiresStrictStatusChecks')
          ? l$requiresStrictStatusChecks
          : const {},
      _$data.containsKey('requiresCodeOwnerReviews')
          ? l$requiresCodeOwnerReviews
          : const {},
      _$data.containsKey('dismissesStaleReviews')
          ? l$dismissesStaleReviews
          : const {},
      _$data.containsKey('restrictsReviewDismissals')
          ? l$restrictsReviewDismissals
          : const {},
      _$data.containsKey('reviewDismissalActorIds')
          ? l$reviewDismissalActorIds == null
              ? null
              : Object.hashAll(l$reviewDismissalActorIds.map((v) => v))
          : const {},
      _$data.containsKey('bypassPullRequestActorIds')
          ? l$bypassPullRequestActorIds == null
              ? null
              : Object.hashAll(l$bypassPullRequestActorIds.map((v) => v))
          : const {},
      _$data.containsKey('bypassForcePushActorIds')
          ? l$bypassForcePushActorIds == null
              ? null
              : Object.hashAll(l$bypassForcePushActorIds.map((v) => v))
          : const {},
      _$data.containsKey('restrictsPushes') ? l$restrictsPushes : const {},
      _$data.containsKey('pushActorIds')
          ? l$pushActorIds == null
              ? null
              : Object.hashAll(l$pushActorIds.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusCheckContexts')
          ? l$requiredStatusCheckContexts == null
              ? null
              : Object.hashAll(l$requiredStatusCheckContexts.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusChecks')
          ? l$requiredStatusChecks == null
              ? null
              : Object.hashAll(l$requiredStatusChecks.map((v) => v))
          : const {},
      _$data.containsKey('requiresConversationResolution')
          ? l$requiresConversationResolution
          : const {},
      _$data.containsKey('requireLastPushApproval')
          ? l$requireLastPushApproval
          : const {},
      _$data.containsKey('lockBranch') ? l$lockBranch : const {},
      _$data.containsKey('lockAllowsFetchAndMerge')
          ? l$lockAllowsFetchAndMerge
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateBranchProtectionRuleInput<TRes> {
  factory CopyWith$Input$CreateBranchProtectionRuleInput(
    Input$CreateBranchProtectionRuleInput instance,
    TRes Function(Input$CreateBranchProtectionRuleInput) then,
  ) = _CopyWithImpl$Input$CreateBranchProtectionRuleInput;

  factory CopyWith$Input$CreateBranchProtectionRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateBranchProtectionRuleInput;

  TRes call({
    String? repositoryId,
    String? pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
    String? clientMutationId,
  });
  TRes requiredStatusChecks(
      Iterable<Input$RequiredStatusCheckInput>? Function(
              Iterable<
                  CopyWith$Input$RequiredStatusCheckInput<
                      Input$RequiredStatusCheckInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CreateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$CreateBranchProtectionRuleInput<TRes> {
  _CopyWithImpl$Input$CreateBranchProtectionRuleInput(
    this._instance,
    this._then,
  );

  final Input$CreateBranchProtectionRuleInput _instance;

  final TRes Function(Input$CreateBranchProtectionRuleInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? pattern = _undefined,
    Object? requiresApprovingReviews = _undefined,
    Object? requiredApprovingReviewCount = _undefined,
    Object? requiresCommitSignatures = _undefined,
    Object? requiresLinearHistory = _undefined,
    Object? blocksCreations = _undefined,
    Object? allowsForcePushes = _undefined,
    Object? allowsDeletions = _undefined,
    Object? isAdminEnforced = _undefined,
    Object? requiresStatusChecks = _undefined,
    Object? requiresStrictStatusChecks = _undefined,
    Object? requiresCodeOwnerReviews = _undefined,
    Object? dismissesStaleReviews = _undefined,
    Object? restrictsReviewDismissals = _undefined,
    Object? reviewDismissalActorIds = _undefined,
    Object? bypassPullRequestActorIds = _undefined,
    Object? bypassForcePushActorIds = _undefined,
    Object? restrictsPushes = _undefined,
    Object? pushActorIds = _undefined,
    Object? requiredStatusCheckContexts = _undefined,
    Object? requiredStatusChecks = _undefined,
    Object? requiresConversationResolution = _undefined,
    Object? requireLastPushApproval = _undefined,
    Object? lockBranch = _undefined,
    Object? lockAllowsFetchAndMerge = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateBranchProtectionRuleInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (pattern != _undefined && pattern != null)
          'pattern': (pattern as String),
        if (requiresApprovingReviews != _undefined)
          'requiresApprovingReviews': (requiresApprovingReviews as bool?),
        if (requiredApprovingReviewCount != _undefined)
          'requiredApprovingReviewCount':
              (requiredApprovingReviewCount as int?),
        if (requiresCommitSignatures != _undefined)
          'requiresCommitSignatures': (requiresCommitSignatures as bool?),
        if (requiresLinearHistory != _undefined)
          'requiresLinearHistory': (requiresLinearHistory as bool?),
        if (blocksCreations != _undefined)
          'blocksCreations': (blocksCreations as bool?),
        if (allowsForcePushes != _undefined)
          'allowsForcePushes': (allowsForcePushes as bool?),
        if (allowsDeletions != _undefined)
          'allowsDeletions': (allowsDeletions as bool?),
        if (isAdminEnforced != _undefined)
          'isAdminEnforced': (isAdminEnforced as bool?),
        if (requiresStatusChecks != _undefined)
          'requiresStatusChecks': (requiresStatusChecks as bool?),
        if (requiresStrictStatusChecks != _undefined)
          'requiresStrictStatusChecks': (requiresStrictStatusChecks as bool?),
        if (requiresCodeOwnerReviews != _undefined)
          'requiresCodeOwnerReviews': (requiresCodeOwnerReviews as bool?),
        if (dismissesStaleReviews != _undefined)
          'dismissesStaleReviews': (dismissesStaleReviews as bool?),
        if (restrictsReviewDismissals != _undefined)
          'restrictsReviewDismissals': (restrictsReviewDismissals as bool?),
        if (reviewDismissalActorIds != _undefined)
          'reviewDismissalActorIds': (reviewDismissalActorIds as List<String>?),
        if (bypassPullRequestActorIds != _undefined)
          'bypassPullRequestActorIds':
              (bypassPullRequestActorIds as List<String>?),
        if (bypassForcePushActorIds != _undefined)
          'bypassForcePushActorIds': (bypassForcePushActorIds as List<String>?),
        if (restrictsPushes != _undefined)
          'restrictsPushes': (restrictsPushes as bool?),
        if (pushActorIds != _undefined)
          'pushActorIds': (pushActorIds as List<String>?),
        if (requiredStatusCheckContexts != _undefined)
          'requiredStatusCheckContexts':
              (requiredStatusCheckContexts as List<String>?),
        if (requiredStatusChecks != _undefined)
          'requiredStatusChecks':
              (requiredStatusChecks as List<Input$RequiredStatusCheckInput>?),
        if (requiresConversationResolution != _undefined)
          'requiresConversationResolution':
              (requiresConversationResolution as bool?),
        if (requireLastPushApproval != _undefined)
          'requireLastPushApproval': (requireLastPushApproval as bool?),
        if (lockBranch != _undefined) 'lockBranch': (lockBranch as bool?),
        if (lockAllowsFetchAndMerge != _undefined)
          'lockAllowsFetchAndMerge': (lockAllowsFetchAndMerge as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
  TRes requiredStatusChecks(
          Iterable<Input$RequiredStatusCheckInput>? Function(
                  Iterable<
                      CopyWith$Input$RequiredStatusCheckInput<
                          Input$RequiredStatusCheckInput>>?)
              _fn) =>
      call(
          requiredStatusChecks: _fn(_instance.requiredStatusChecks
              ?.map((e) => CopyWith$Input$RequiredStatusCheckInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CreateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$CreateBranchProtectionRuleInput<TRes> {
  _CopyWithStubImpl$Input$CreateBranchProtectionRuleInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
    String? clientMutationId,
  }) =>
      _res;
  requiredStatusChecks(_fn) => _res;
}

class Input$CreateCheckRunInput {
  factory Input$CreateCheckRunInput({
    required String repositoryId,
    required String name,
    required String headSha,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
    String? clientMutationId,
  }) =>
      Input$CreateCheckRunInput._({
        r'repositoryId': repositoryId,
        r'name': name,
        r'headSha': headSha,
        if (detailsUrl != null) r'detailsUrl': detailsUrl,
        if (externalId != null) r'externalId': externalId,
        if (status != null) r'status': status,
        if (startedAt != null) r'startedAt': startedAt,
        if (conclusion != null) r'conclusion': conclusion,
        if (completedAt != null) r'completedAt': completedAt,
        if (output != null) r'output': output,
        if (actions != null) r'actions': actions,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateCheckRunInput._(this._$data);

  factory Input$CreateCheckRunInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$headSha = data['headSha'];
    result$data['headSha'] = (l$headSha as String);
    if (data.containsKey('detailsUrl')) {
      final l$detailsUrl = data['detailsUrl'];
      result$data['detailsUrl'] = (l$detailsUrl as String?);
    }
    if (data.containsKey('externalId')) {
      final l$externalId = data['externalId'];
      result$data['externalId'] = (l$externalId as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$RequestableCheckStatusState((l$status as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = (l$startedAt as String?);
    }
    if (data.containsKey('conclusion')) {
      final l$conclusion = data['conclusion'];
      result$data['conclusion'] = l$conclusion == null
          ? null
          : fromJson$Enum$CheckConclusionState((l$conclusion as String));
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = (l$completedAt as String?);
    }
    if (data.containsKey('output')) {
      final l$output = data['output'];
      result$data['output'] = l$output == null
          ? null
          : Input$CheckRunOutput.fromJson((l$output as Map<String, dynamic>));
    }
    if (data.containsKey('actions')) {
      final l$actions = data['actions'];
      result$data['actions'] = (l$actions as List<dynamic>?)
          ?.map(
              (e) => Input$CheckRunAction.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateCheckRunInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get name => (_$data['name'] as String);
  String get headSha => (_$data['headSha'] as String);
  String? get detailsUrl => (_$data['detailsUrl'] as String?);
  String? get externalId => (_$data['externalId'] as String?);
  Enum$RequestableCheckStatusState? get status =>
      (_$data['status'] as Enum$RequestableCheckStatusState?);
  String? get startedAt => (_$data['startedAt'] as String?);
  Enum$CheckConclusionState? get conclusion =>
      (_$data['conclusion'] as Enum$CheckConclusionState?);
  String? get completedAt => (_$data['completedAt'] as String?);
  Input$CheckRunOutput? get output =>
      (_$data['output'] as Input$CheckRunOutput?);
  List<Input$CheckRunAction>? get actions =>
      (_$data['actions'] as List<Input$CheckRunAction>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$name = name;
    result$data['name'] = l$name;
    final l$headSha = headSha;
    result$data['headSha'] = l$headSha;
    if (_$data.containsKey('detailsUrl')) {
      final l$detailsUrl = detailsUrl;
      result$data['detailsUrl'] = l$detailsUrl;
    }
    if (_$data.containsKey('externalId')) {
      final l$externalId = externalId;
      result$data['externalId'] = l$externalId;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$RequestableCheckStatusState(l$status);
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt;
    }
    if (_$data.containsKey('conclusion')) {
      final l$conclusion = conclusion;
      result$data['conclusion'] = l$conclusion == null
          ? null
          : toJson$Enum$CheckConclusionState(l$conclusion);
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt;
    }
    if (_$data.containsKey('output')) {
      final l$output = output;
      result$data['output'] = l$output?.toJson();
    }
    if (_$data.containsKey('actions')) {
      final l$actions = actions;
      result$data['actions'] = l$actions?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateCheckRunInput<Input$CreateCheckRunInput> get copyWith =>
      CopyWith$Input$CreateCheckRunInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateCheckRunInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$headSha = headSha;
    final lOther$headSha = other.headSha;
    if (l$headSha != lOther$headSha) {
      return false;
    }
    final l$detailsUrl = detailsUrl;
    final lOther$detailsUrl = other.detailsUrl;
    if (_$data.containsKey('detailsUrl') !=
        other._$data.containsKey('detailsUrl')) {
      return false;
    }
    if (l$detailsUrl != lOther$detailsUrl) {
      return false;
    }
    final l$externalId = externalId;
    final lOther$externalId = other.externalId;
    if (_$data.containsKey('externalId') !=
        other._$data.containsKey('externalId')) {
      return false;
    }
    if (l$externalId != lOther$externalId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$conclusion = conclusion;
    final lOther$conclusion = other.conclusion;
    if (_$data.containsKey('conclusion') !=
        other._$data.containsKey('conclusion')) {
      return false;
    }
    if (l$conclusion != lOther$conclusion) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$output = output;
    final lOther$output = other.output;
    if (_$data.containsKey('output') != other._$data.containsKey('output')) {
      return false;
    }
    if (l$output != lOther$output) {
      return false;
    }
    final l$actions = actions;
    final lOther$actions = other.actions;
    if (_$data.containsKey('actions') != other._$data.containsKey('actions')) {
      return false;
    }
    if (l$actions != null && lOther$actions != null) {
      if (l$actions.length != lOther$actions.length) {
        return false;
      }
      for (int i = 0; i < l$actions.length; i++) {
        final l$actions$entry = l$actions[i];
        final lOther$actions$entry = lOther$actions[i];
        if (l$actions$entry != lOther$actions$entry) {
          return false;
        }
      }
    } else if (l$actions != lOther$actions) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$headSha = headSha;
    final l$detailsUrl = detailsUrl;
    final l$externalId = externalId;
    final l$status = status;
    final l$startedAt = startedAt;
    final l$conclusion = conclusion;
    final l$completedAt = completedAt;
    final l$output = output;
    final l$actions = actions;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$name,
      l$headSha,
      _$data.containsKey('detailsUrl') ? l$detailsUrl : const {},
      _$data.containsKey('externalId') ? l$externalId : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('conclusion') ? l$conclusion : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('output') ? l$output : const {},
      _$data.containsKey('actions')
          ? l$actions == null
              ? null
              : Object.hashAll(l$actions.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateCheckRunInput<TRes> {
  factory CopyWith$Input$CreateCheckRunInput(
    Input$CreateCheckRunInput instance,
    TRes Function(Input$CreateCheckRunInput) then,
  ) = _CopyWithImpl$Input$CreateCheckRunInput;

  factory CopyWith$Input$CreateCheckRunInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCheckRunInput;

  TRes call({
    String? repositoryId,
    String? name,
    String? headSha,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
    String? clientMutationId,
  });
  CopyWith$Input$CheckRunOutput<TRes> get output;
  TRes actions(
      Iterable<Input$CheckRunAction>? Function(
              Iterable<CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
          _fn);
}

class _CopyWithImpl$Input$CreateCheckRunInput<TRes>
    implements CopyWith$Input$CreateCheckRunInput<TRes> {
  _CopyWithImpl$Input$CreateCheckRunInput(
    this._instance,
    this._then,
  );

  final Input$CreateCheckRunInput _instance;

  final TRes Function(Input$CreateCheckRunInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? headSha = _undefined,
    Object? detailsUrl = _undefined,
    Object? externalId = _undefined,
    Object? status = _undefined,
    Object? startedAt = _undefined,
    Object? conclusion = _undefined,
    Object? completedAt = _undefined,
    Object? output = _undefined,
    Object? actions = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateCheckRunInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (headSha != _undefined && headSha != null)
          'headSha': (headSha as String),
        if (detailsUrl != _undefined) 'detailsUrl': (detailsUrl as String?),
        if (externalId != _undefined) 'externalId': (externalId as String?),
        if (status != _undefined)
          'status': (status as Enum$RequestableCheckStatusState?),
        if (startedAt != _undefined) 'startedAt': (startedAt as String?),
        if (conclusion != _undefined)
          'conclusion': (conclusion as Enum$CheckConclusionState?),
        if (completedAt != _undefined) 'completedAt': (completedAt as String?),
        if (output != _undefined) 'output': (output as Input$CheckRunOutput?),
        if (actions != _undefined)
          'actions': (actions as List<Input$CheckRunAction>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
  CopyWith$Input$CheckRunOutput<TRes> get output {
    final local$output = _instance.output;
    return local$output == null
        ? CopyWith$Input$CheckRunOutput.stub(_then(_instance))
        : CopyWith$Input$CheckRunOutput(local$output, (e) => call(output: e));
  }

  TRes actions(
          Iterable<Input$CheckRunAction>? Function(
                  Iterable<
                      CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
              _fn) =>
      call(
          actions:
              _fn(_instance.actions?.map((e) => CopyWith$Input$CheckRunAction(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CreateCheckRunInput<TRes>
    implements CopyWith$Input$CreateCheckRunInput<TRes> {
  _CopyWithStubImpl$Input$CreateCheckRunInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? name,
    String? headSha,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
    String? clientMutationId,
  }) =>
      _res;
  CopyWith$Input$CheckRunOutput<TRes> get output =>
      CopyWith$Input$CheckRunOutput.stub(_res);
  actions(_fn) => _res;
}

class Input$CreateCheckSuiteInput {
  factory Input$CreateCheckSuiteInput({
    required String repositoryId,
    required String headSha,
    String? clientMutationId,
  }) =>
      Input$CreateCheckSuiteInput._({
        r'repositoryId': repositoryId,
        r'headSha': headSha,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateCheckSuiteInput._(this._$data);

  factory Input$CreateCheckSuiteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$headSha = data['headSha'];
    result$data['headSha'] = (l$headSha as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateCheckSuiteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get headSha => (_$data['headSha'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$headSha = headSha;
    result$data['headSha'] = l$headSha;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateCheckSuiteInput<Input$CreateCheckSuiteInput>
      get copyWith => CopyWith$Input$CreateCheckSuiteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateCheckSuiteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$headSha = headSha;
    final lOther$headSha = other.headSha;
    if (l$headSha != lOther$headSha) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$headSha = headSha;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$headSha,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateCheckSuiteInput<TRes> {
  factory CopyWith$Input$CreateCheckSuiteInput(
    Input$CreateCheckSuiteInput instance,
    TRes Function(Input$CreateCheckSuiteInput) then,
  ) = _CopyWithImpl$Input$CreateCheckSuiteInput;

  factory CopyWith$Input$CreateCheckSuiteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCheckSuiteInput;

  TRes call({
    String? repositoryId,
    String? headSha,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateCheckSuiteInput<TRes>
    implements CopyWith$Input$CreateCheckSuiteInput<TRes> {
  _CopyWithImpl$Input$CreateCheckSuiteInput(
    this._instance,
    this._then,
  );

  final Input$CreateCheckSuiteInput _instance;

  final TRes Function(Input$CreateCheckSuiteInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? headSha = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateCheckSuiteInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (headSha != _undefined && headSha != null)
          'headSha': (headSha as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateCheckSuiteInput<TRes>
    implements CopyWith$Input$CreateCheckSuiteInput<TRes> {
  _CopyWithStubImpl$Input$CreateCheckSuiteInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? headSha,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateCommitOnBranchInput {
  factory Input$CreateCommitOnBranchInput({
    required Input$CommittableBranch branch,
    Input$FileChanges? fileChanges,
    required Input$CommitMessage message,
    required String expectedHeadOid,
    String? clientMutationId,
  }) =>
      Input$CreateCommitOnBranchInput._({
        r'branch': branch,
        if (fileChanges != null) r'fileChanges': fileChanges,
        r'message': message,
        r'expectedHeadOid': expectedHeadOid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateCommitOnBranchInput._(this._$data);

  factory Input$CreateCommitOnBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$branch = data['branch'];
    result$data['branch'] =
        Input$CommittableBranch.fromJson((l$branch as Map<String, dynamic>));
    if (data.containsKey('fileChanges')) {
      final l$fileChanges = data['fileChanges'];
      result$data['fileChanges'] = l$fileChanges == null
          ? null
          : Input$FileChanges.fromJson((l$fileChanges as Map<String, dynamic>));
    }
    final l$message = data['message'];
    result$data['message'] =
        Input$CommitMessage.fromJson((l$message as Map<String, dynamic>));
    final l$expectedHeadOid = data['expectedHeadOid'];
    result$data['expectedHeadOid'] = (l$expectedHeadOid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateCommitOnBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$CommittableBranch get branch =>
      (_$data['branch'] as Input$CommittableBranch);
  Input$FileChanges? get fileChanges =>
      (_$data['fileChanges'] as Input$FileChanges?);
  Input$CommitMessage get message => (_$data['message'] as Input$CommitMessage);
  String get expectedHeadOid => (_$data['expectedHeadOid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$branch = branch;
    result$data['branch'] = l$branch.toJson();
    if (_$data.containsKey('fileChanges')) {
      final l$fileChanges = fileChanges;
      result$data['fileChanges'] = l$fileChanges?.toJson();
    }
    final l$message = message;
    result$data['message'] = l$message.toJson();
    final l$expectedHeadOid = expectedHeadOid;
    result$data['expectedHeadOid'] = l$expectedHeadOid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateCommitOnBranchInput<Input$CreateCommitOnBranchInput>
      get copyWith => CopyWith$Input$CreateCommitOnBranchInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateCommitOnBranchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$branch = branch;
    final lOther$branch = other.branch;
    if (l$branch != lOther$branch) {
      return false;
    }
    final l$fileChanges = fileChanges;
    final lOther$fileChanges = other.fileChanges;
    if (_$data.containsKey('fileChanges') !=
        other._$data.containsKey('fileChanges')) {
      return false;
    }
    if (l$fileChanges != lOther$fileChanges) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$branch = branch;
    final l$fileChanges = fileChanges;
    final l$message = message;
    final l$expectedHeadOid = expectedHeadOid;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$branch,
      _$data.containsKey('fileChanges') ? l$fileChanges : const {},
      l$message,
      l$expectedHeadOid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateCommitOnBranchInput<TRes> {
  factory CopyWith$Input$CreateCommitOnBranchInput(
    Input$CreateCommitOnBranchInput instance,
    TRes Function(Input$CreateCommitOnBranchInput) then,
  ) = _CopyWithImpl$Input$CreateCommitOnBranchInput;

  factory CopyWith$Input$CreateCommitOnBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCommitOnBranchInput;

  TRes call({
    Input$CommittableBranch? branch,
    Input$FileChanges? fileChanges,
    Input$CommitMessage? message,
    String? expectedHeadOid,
    String? clientMutationId,
  });
  CopyWith$Input$CommittableBranch<TRes> get branch;
  CopyWith$Input$FileChanges<TRes> get fileChanges;
  CopyWith$Input$CommitMessage<TRes> get message;
}

class _CopyWithImpl$Input$CreateCommitOnBranchInput<TRes>
    implements CopyWith$Input$CreateCommitOnBranchInput<TRes> {
  _CopyWithImpl$Input$CreateCommitOnBranchInput(
    this._instance,
    this._then,
  );

  final Input$CreateCommitOnBranchInput _instance;

  final TRes Function(Input$CreateCommitOnBranchInput) _then;

  static const _undefined = {};

  TRes call({
    Object? branch = _undefined,
    Object? fileChanges = _undefined,
    Object? message = _undefined,
    Object? expectedHeadOid = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateCommitOnBranchInput._({
        ..._instance._$data,
        if (branch != _undefined && branch != null)
          'branch': (branch as Input$CommittableBranch),
        if (fileChanges != _undefined)
          'fileChanges': (fileChanges as Input$FileChanges?),
        if (message != _undefined && message != null)
          'message': (message as Input$CommitMessage),
        if (expectedHeadOid != _undefined && expectedHeadOid != null)
          'expectedHeadOid': (expectedHeadOid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
  CopyWith$Input$CommittableBranch<TRes> get branch {
    final local$branch = _instance.branch;
    return CopyWith$Input$CommittableBranch(
        local$branch, (e) => call(branch: e));
  }

  CopyWith$Input$FileChanges<TRes> get fileChanges {
    final local$fileChanges = _instance.fileChanges;
    return local$fileChanges == null
        ? CopyWith$Input$FileChanges.stub(_then(_instance))
        : CopyWith$Input$FileChanges(
            local$fileChanges, (e) => call(fileChanges: e));
  }

  CopyWith$Input$CommitMessage<TRes> get message {
    final local$message = _instance.message;
    return CopyWith$Input$CommitMessage(local$message, (e) => call(message: e));
  }
}

class _CopyWithStubImpl$Input$CreateCommitOnBranchInput<TRes>
    implements CopyWith$Input$CreateCommitOnBranchInput<TRes> {
  _CopyWithStubImpl$Input$CreateCommitOnBranchInput(this._res);

  TRes _res;

  call({
    Input$CommittableBranch? branch,
    Input$FileChanges? fileChanges,
    Input$CommitMessage? message,
    String? expectedHeadOid,
    String? clientMutationId,
  }) =>
      _res;
  CopyWith$Input$CommittableBranch<TRes> get branch =>
      CopyWith$Input$CommittableBranch.stub(_res);
  CopyWith$Input$FileChanges<TRes> get fileChanges =>
      CopyWith$Input$FileChanges.stub(_res);
  CopyWith$Input$CommitMessage<TRes> get message =>
      CopyWith$Input$CommitMessage.stub(_res);
}

class Input$CreateDiscussionInput {
  factory Input$CreateDiscussionInput({
    required String repositoryId,
    required String title,
    required String body,
    required String categoryId,
    String? clientMutationId,
  }) =>
      Input$CreateDiscussionInput._({
        r'repositoryId': repositoryId,
        r'title': title,
        r'body': body,
        r'categoryId': categoryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateDiscussionInput._(this._$data);

  factory Input$CreateDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    final l$categoryId = data['categoryId'];
    result$data['categoryId'] = (l$categoryId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get title => (_$data['title'] as String);
  String get body => (_$data['body'] as String);
  String get categoryId => (_$data['categoryId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$title = title;
    result$data['title'] = l$title;
    final l$body = body;
    result$data['body'] = l$body;
    final l$categoryId = categoryId;
    result$data['categoryId'] = l$categoryId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateDiscussionInput<Input$CreateDiscussionInput>
      get copyWith => CopyWith$Input$CreateDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$categoryId = categoryId;
    final lOther$categoryId = other.categoryId;
    if (l$categoryId != lOther$categoryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$title = title;
    final l$body = body;
    final l$categoryId = categoryId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$title,
      l$body,
      l$categoryId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateDiscussionInput<TRes> {
  factory CopyWith$Input$CreateDiscussionInput(
    Input$CreateDiscussionInput instance,
    TRes Function(Input$CreateDiscussionInput) then,
  ) = _CopyWithImpl$Input$CreateDiscussionInput;

  factory CopyWith$Input$CreateDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateDiscussionInput;

  TRes call({
    String? repositoryId,
    String? title,
    String? body,
    String? categoryId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateDiscussionInput<TRes>
    implements CopyWith$Input$CreateDiscussionInput<TRes> {
  _CopyWithImpl$Input$CreateDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$CreateDiscussionInput _instance;

  final TRes Function(Input$CreateDiscussionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? categoryId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateDiscussionInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (categoryId != _undefined && categoryId != null)
          'categoryId': (categoryId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateDiscussionInput<TRes>
    implements CopyWith$Input$CreateDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$CreateDiscussionInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? title,
    String? body,
    String? categoryId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateEnterpriseOrganizationInput {
  factory Input$CreateEnterpriseOrganizationInput({
    required String enterpriseId,
    required String login,
    required String profileName,
    required String billingEmail,
    required List<String> adminLogins,
    String? clientMutationId,
  }) =>
      Input$CreateEnterpriseOrganizationInput._({
        r'enterpriseId': enterpriseId,
        r'login': login,
        r'profileName': profileName,
        r'billingEmail': billingEmail,
        r'adminLogins': adminLogins,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateEnterpriseOrganizationInput._(this._$data);

  factory Input$CreateEnterpriseOrganizationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    final l$profileName = data['profileName'];
    result$data['profileName'] = (l$profileName as String);
    final l$billingEmail = data['billingEmail'];
    result$data['billingEmail'] = (l$billingEmail as String);
    final l$adminLogins = data['adminLogins'];
    result$data['adminLogins'] =
        (l$adminLogins as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateEnterpriseOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  String get profileName => (_$data['profileName'] as String);
  String get billingEmail => (_$data['billingEmail'] as String);
  List<String> get adminLogins => (_$data['adminLogins'] as List<String>);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    final l$profileName = profileName;
    result$data['profileName'] = l$profileName;
    final l$billingEmail = billingEmail;
    result$data['billingEmail'] = l$billingEmail;
    final l$adminLogins = adminLogins;
    result$data['adminLogins'] = l$adminLogins.map((e) => e).toList();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateEnterpriseOrganizationInput<
          Input$CreateEnterpriseOrganizationInput>
      get copyWith => CopyWith$Input$CreateEnterpriseOrganizationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateEnterpriseOrganizationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    final l$profileName = profileName;
    final lOther$profileName = other.profileName;
    if (l$profileName != lOther$profileName) {
      return false;
    }
    final l$billingEmail = billingEmail;
    final lOther$billingEmail = other.billingEmail;
    if (l$billingEmail != lOther$billingEmail) {
      return false;
    }
    final l$adminLogins = adminLogins;
    final lOther$adminLogins = other.adminLogins;
    if (l$adminLogins.length != lOther$adminLogins.length) {
      return false;
    }
    for (int i = 0; i < l$adminLogins.length; i++) {
      final l$adminLogins$entry = l$adminLogins[i];
      final lOther$adminLogins$entry = lOther$adminLogins[i];
      if (l$adminLogins$entry != lOther$adminLogins$entry) {
        return false;
      }
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    final l$profileName = profileName;
    final l$billingEmail = billingEmail;
    final l$adminLogins = adminLogins;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$login,
      l$profileName,
      l$billingEmail,
      Object.hashAll(l$adminLogins.map((v) => v)),
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateEnterpriseOrganizationInput<TRes> {
  factory CopyWith$Input$CreateEnterpriseOrganizationInput(
    Input$CreateEnterpriseOrganizationInput instance,
    TRes Function(Input$CreateEnterpriseOrganizationInput) then,
  ) = _CopyWithImpl$Input$CreateEnterpriseOrganizationInput;

  factory CopyWith$Input$CreateEnterpriseOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateEnterpriseOrganizationInput;

  TRes call({
    String? enterpriseId,
    String? login,
    String? profileName,
    String? billingEmail,
    List<String>? adminLogins,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$CreateEnterpriseOrganizationInput<TRes> {
  _CopyWithImpl$Input$CreateEnterpriseOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$CreateEnterpriseOrganizationInput _instance;

  final TRes Function(Input$CreateEnterpriseOrganizationInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
    Object? profileName = _undefined,
    Object? billingEmail = _undefined,
    Object? adminLogins = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateEnterpriseOrganizationInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
        if (profileName != _undefined && profileName != null)
          'profileName': (profileName as String),
        if (billingEmail != _undefined && billingEmail != null)
          'billingEmail': (billingEmail as String),
        if (adminLogins != _undefined && adminLogins != null)
          'adminLogins': (adminLogins as List<String>),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$CreateEnterpriseOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$CreateEnterpriseOrganizationInput(this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? login,
    String? profileName,
    String? billingEmail,
    List<String>? adminLogins,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateEnvironmentInput {
  factory Input$CreateEnvironmentInput({
    required String repositoryId,
    required String name,
    String? clientMutationId,
  }) =>
      Input$CreateEnvironmentInput._({
        r'repositoryId': repositoryId,
        r'name': name,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateEnvironmentInput._(this._$data);

  factory Input$CreateEnvironmentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateEnvironmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get name => (_$data['name'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateEnvironmentInput<Input$CreateEnvironmentInput>
      get copyWith => CopyWith$Input$CreateEnvironmentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateEnvironmentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$name,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateEnvironmentInput<TRes> {
  factory CopyWith$Input$CreateEnvironmentInput(
    Input$CreateEnvironmentInput instance,
    TRes Function(Input$CreateEnvironmentInput) then,
  ) = _CopyWithImpl$Input$CreateEnvironmentInput;

  factory CopyWith$Input$CreateEnvironmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateEnvironmentInput;

  TRes call({
    String? repositoryId,
    String? name,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateEnvironmentInput<TRes>
    implements CopyWith$Input$CreateEnvironmentInput<TRes> {
  _CopyWithImpl$Input$CreateEnvironmentInput(
    this._instance,
    this._then,
  );

  final Input$CreateEnvironmentInput _instance;

  final TRes Function(Input$CreateEnvironmentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateEnvironmentInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateEnvironmentInput<TRes>
    implements CopyWith$Input$CreateEnvironmentInput<TRes> {
  _CopyWithStubImpl$Input$CreateEnvironmentInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? name,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateIpAllowListEntryInput {
  factory Input$CreateIpAllowListEntryInput({
    required String ownerId,
    required String allowListValue,
    String? name,
    required bool isActive,
    String? clientMutationId,
  }) =>
      Input$CreateIpAllowListEntryInput._({
        r'ownerId': ownerId,
        r'allowListValue': allowListValue,
        if (name != null) r'name': name,
        r'isActive': isActive,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateIpAllowListEntryInput._(this._$data);

  factory Input$CreateIpAllowListEntryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$allowListValue = data['allowListValue'];
    result$data['allowListValue'] = (l$allowListValue as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    final l$isActive = data['isActive'];
    result$data['isActive'] = (l$isActive as bool);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateIpAllowListEntryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get ownerId => (_$data['ownerId'] as String);
  String get allowListValue => (_$data['allowListValue'] as String);
  String? get name => (_$data['name'] as String?);
  bool get isActive => (_$data['isActive'] as bool);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$allowListValue = allowListValue;
    result$data['allowListValue'] = l$allowListValue;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    final l$isActive = isActive;
    result$data['isActive'] = l$isActive;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateIpAllowListEntryInput<Input$CreateIpAllowListEntryInput>
      get copyWith => CopyWith$Input$CreateIpAllowListEntryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateIpAllowListEntryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$allowListValue = allowListValue;
    final lOther$allowListValue = other.allowListValue;
    if (l$allowListValue != lOther$allowListValue) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ownerId = ownerId;
    final l$allowListValue = allowListValue;
    final l$name = name;
    final l$isActive = isActive;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$ownerId,
      l$allowListValue,
      _$data.containsKey('name') ? l$name : const {},
      l$isActive,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateIpAllowListEntryInput<TRes> {
  factory CopyWith$Input$CreateIpAllowListEntryInput(
    Input$CreateIpAllowListEntryInput instance,
    TRes Function(Input$CreateIpAllowListEntryInput) then,
  ) = _CopyWithImpl$Input$CreateIpAllowListEntryInput;

  factory CopyWith$Input$CreateIpAllowListEntryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateIpAllowListEntryInput;

  TRes call({
    String? ownerId,
    String? allowListValue,
    String? name,
    bool? isActive,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$CreateIpAllowListEntryInput<TRes> {
  _CopyWithImpl$Input$CreateIpAllowListEntryInput(
    this._instance,
    this._then,
  );

  final Input$CreateIpAllowListEntryInput _instance;

  final TRes Function(Input$CreateIpAllowListEntryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? ownerId = _undefined,
    Object? allowListValue = _undefined,
    Object? name = _undefined,
    Object? isActive = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateIpAllowListEntryInput._({
        ..._instance._$data,
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (allowListValue != _undefined && allowListValue != null)
          'allowListValue': (allowListValue as String),
        if (name != _undefined) 'name': (name as String?),
        if (isActive != _undefined && isActive != null)
          'isActive': (isActive as bool),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$CreateIpAllowListEntryInput<TRes> {
  _CopyWithStubImpl$Input$CreateIpAllowListEntryInput(this._res);

  TRes _res;

  call({
    String? ownerId,
    String? allowListValue,
    String? name,
    bool? isActive,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateIssueInput {
  factory Input$CreateIssueInput({
    required String repositoryId,
    required String title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
    String? issueTemplate,
    String? clientMutationId,
  }) =>
      Input$CreateIssueInput._({
        r'repositoryId': repositoryId,
        r'title': title,
        if (body != null) r'body': body,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (labelIds != null) r'labelIds': labelIds,
        if (projectIds != null) r'projectIds': projectIds,
        if (issueTemplate != null) r'issueTemplate': issueTemplate,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateIssueInput._(this._$data);

  factory Input$CreateIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('projectIds')) {
      final l$projectIds = data['projectIds'];
      result$data['projectIds'] =
          (l$projectIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('issueTemplate')) {
      final l$issueTemplate = data['issueTemplate'];
      result$data['issueTemplate'] = (l$issueTemplate as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get title => (_$data['title'] as String);
  String? get body => (_$data['body'] as String?);
  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  List<String>? get projectIds => (_$data['projectIds'] as List<String>?);
  String? get issueTemplate => (_$data['issueTemplate'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('projectIds')) {
      final l$projectIds = projectIds;
      result$data['projectIds'] = l$projectIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('issueTemplate')) {
      final l$issueTemplate = issueTemplate;
      result$data['issueTemplate'] = l$issueTemplate;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateIssueInput<Input$CreateIssueInput> get copyWith =>
      CopyWith$Input$CreateIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$projectIds = projectIds;
    final lOther$projectIds = other.projectIds;
    if (_$data.containsKey('projectIds') !=
        other._$data.containsKey('projectIds')) {
      return false;
    }
    if (l$projectIds != null && lOther$projectIds != null) {
      if (l$projectIds.length != lOther$projectIds.length) {
        return false;
      }
      for (int i = 0; i < l$projectIds.length; i++) {
        final l$projectIds$entry = l$projectIds[i];
        final lOther$projectIds$entry = lOther$projectIds[i];
        if (l$projectIds$entry != lOther$projectIds$entry) {
          return false;
        }
      }
    } else if (l$projectIds != lOther$projectIds) {
      return false;
    }
    final l$issueTemplate = issueTemplate;
    final lOther$issueTemplate = other.issueTemplate;
    if (_$data.containsKey('issueTemplate') !=
        other._$data.containsKey('issueTemplate')) {
      return false;
    }
    if (l$issueTemplate != lOther$issueTemplate) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$title = title;
    final l$body = body;
    final l$assigneeIds = assigneeIds;
    final l$milestoneId = milestoneId;
    final l$labelIds = labelIds;
    final l$projectIds = projectIds;
    final l$issueTemplate = issueTemplate;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$title,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('projectIds')
          ? l$projectIds == null
              ? null
              : Object.hashAll(l$projectIds.map((v) => v))
          : const {},
      _$data.containsKey('issueTemplate') ? l$issueTemplate : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateIssueInput<TRes> {
  factory CopyWith$Input$CreateIssueInput(
    Input$CreateIssueInput instance,
    TRes Function(Input$CreateIssueInput) then,
  ) = _CopyWithImpl$Input$CreateIssueInput;

  factory CopyWith$Input$CreateIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateIssueInput;

  TRes call({
    String? repositoryId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
    String? issueTemplate,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateIssueInput<TRes>
    implements CopyWith$Input$CreateIssueInput<TRes> {
  _CopyWithImpl$Input$CreateIssueInput(
    this._instance,
    this._then,
  );

  final Input$CreateIssueInput _instance;

  final TRes Function(Input$CreateIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? assigneeIds = _undefined,
    Object? milestoneId = _undefined,
    Object? labelIds = _undefined,
    Object? projectIds = _undefined,
    Object? issueTemplate = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateIssueInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (body != _undefined) 'body': (body as String?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (projectIds != _undefined)
          'projectIds': (projectIds as List<String>?),
        if (issueTemplate != _undefined)
          'issueTemplate': (issueTemplate as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateIssueInput<TRes>
    implements CopyWith$Input$CreateIssueInput<TRes> {
  _CopyWithStubImpl$Input$CreateIssueInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
    String? issueTemplate,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateLinkedBranchInput {
  factory Input$CreateLinkedBranchInput({
    required String issueId,
    required String oid,
    String? name,
    String? repositoryId,
    String? clientMutationId,
  }) =>
      Input$CreateLinkedBranchInput._({
        r'issueId': issueId,
        r'oid': oid,
        if (name != null) r'name': name,
        if (repositoryId != null) r'repositoryId': repositoryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateLinkedBranchInput._(this._$data);

  factory Input$CreateLinkedBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    final l$oid = data['oid'];
    result$data['oid'] = (l$oid as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = (l$repositoryId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateLinkedBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get issueId => (_$data['issueId'] as String);
  String get oid => (_$data['oid'] as String);
  String? get name => (_$data['name'] as String?);
  String? get repositoryId => (_$data['repositoryId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    final l$oid = oid;
    result$data['oid'] = l$oid;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateLinkedBranchInput<Input$CreateLinkedBranchInput>
      get copyWith => CopyWith$Input$CreateLinkedBranchInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateLinkedBranchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$oid = oid;
    final lOther$oid = other.oid;
    if (l$oid != lOther$oid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$issueId = issueId;
    final l$oid = oid;
    final l$name = name;
    final l$repositoryId = repositoryId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$issueId,
      l$oid,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateLinkedBranchInput<TRes> {
  factory CopyWith$Input$CreateLinkedBranchInput(
    Input$CreateLinkedBranchInput instance,
    TRes Function(Input$CreateLinkedBranchInput) then,
  ) = _CopyWithImpl$Input$CreateLinkedBranchInput;

  factory CopyWith$Input$CreateLinkedBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateLinkedBranchInput;

  TRes call({
    String? issueId,
    String? oid,
    String? name,
    String? repositoryId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateLinkedBranchInput<TRes>
    implements CopyWith$Input$CreateLinkedBranchInput<TRes> {
  _CopyWithImpl$Input$CreateLinkedBranchInput(
    this._instance,
    this._then,
  );

  final Input$CreateLinkedBranchInput _instance;

  final TRes Function(Input$CreateLinkedBranchInput) _then;

  static const _undefined = {};

  TRes call({
    Object? issueId = _undefined,
    Object? oid = _undefined,
    Object? name = _undefined,
    Object? repositoryId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateLinkedBranchInput._({
        ..._instance._$data,
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (oid != _undefined && oid != null) 'oid': (oid as String),
        if (name != _undefined) 'name': (name as String?),
        if (repositoryId != _undefined)
          'repositoryId': (repositoryId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateLinkedBranchInput<TRes>
    implements CopyWith$Input$CreateLinkedBranchInput<TRes> {
  _CopyWithStubImpl$Input$CreateLinkedBranchInput(this._res);

  TRes _res;

  call({
    String? issueId,
    String? oid,
    String? name,
    String? repositoryId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateMigrationSourceInput {
  factory Input$CreateMigrationSourceInput({
    required String name,
    required String url,
    String? accessToken,
    required Enum$MigrationSourceType type,
    required String ownerId,
    String? githubPat,
    String? clientMutationId,
  }) =>
      Input$CreateMigrationSourceInput._({
        r'name': name,
        r'url': url,
        if (accessToken != null) r'accessToken': accessToken,
        r'type': type,
        r'ownerId': ownerId,
        if (githubPat != null) r'githubPat': githubPat,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateMigrationSourceInput._(this._$data);

  factory Input$CreateMigrationSourceInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$url = data['url'];
    result$data['url'] = (l$url as String);
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = (l$accessToken as String?);
    }
    final l$type = data['type'];
    result$data['type'] = fromJson$Enum$MigrationSourceType((l$type as String));
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    if (data.containsKey('githubPat')) {
      final l$githubPat = data['githubPat'];
      result$data['githubPat'] = (l$githubPat as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateMigrationSourceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  String get url => (_$data['url'] as String);
  String? get accessToken => (_$data['accessToken'] as String?);
  Enum$MigrationSourceType get type =>
      (_$data['type'] as Enum$MigrationSourceType);
  String get ownerId => (_$data['ownerId'] as String);
  String? get githubPat => (_$data['githubPat'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$url = url;
    result$data['url'] = l$url;
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] = l$accessToken;
    }
    final l$type = type;
    result$data['type'] = toJson$Enum$MigrationSourceType(l$type);
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    if (_$data.containsKey('githubPat')) {
      final l$githubPat = githubPat;
      result$data['githubPat'] = l$githubPat;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateMigrationSourceInput<Input$CreateMigrationSourceInput>
      get copyWith => CopyWith$Input$CreateMigrationSourceInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateMigrationSourceInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (l$url != lOther$url) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$githubPat = githubPat;
    final lOther$githubPat = other.githubPat;
    if (_$data.containsKey('githubPat') !=
        other._$data.containsKey('githubPat')) {
      return false;
    }
    if (l$githubPat != lOther$githubPat) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$url = url;
    final l$accessToken = accessToken;
    final l$type = type;
    final l$ownerId = ownerId;
    final l$githubPat = githubPat;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$name,
      l$url,
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      l$type,
      l$ownerId,
      _$data.containsKey('githubPat') ? l$githubPat : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateMigrationSourceInput<TRes> {
  factory CopyWith$Input$CreateMigrationSourceInput(
    Input$CreateMigrationSourceInput instance,
    TRes Function(Input$CreateMigrationSourceInput) then,
  ) = _CopyWithImpl$Input$CreateMigrationSourceInput;

  factory CopyWith$Input$CreateMigrationSourceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateMigrationSourceInput;

  TRes call({
    String? name,
    String? url,
    String? accessToken,
    Enum$MigrationSourceType? type,
    String? ownerId,
    String? githubPat,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateMigrationSourceInput<TRes>
    implements CopyWith$Input$CreateMigrationSourceInput<TRes> {
  _CopyWithImpl$Input$CreateMigrationSourceInput(
    this._instance,
    this._then,
  );

  final Input$CreateMigrationSourceInput _instance;

  final TRes Function(Input$CreateMigrationSourceInput) _then;

  static const _undefined = {};

  TRes call({
    Object? name = _undefined,
    Object? url = _undefined,
    Object? accessToken = _undefined,
    Object? type = _undefined,
    Object? ownerId = _undefined,
    Object? githubPat = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateMigrationSourceInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (url != _undefined && url != null) 'url': (url as String),
        if (accessToken != _undefined) 'accessToken': (accessToken as String?),
        if (type != _undefined && type != null)
          'type': (type as Enum$MigrationSourceType),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (githubPat != _undefined) 'githubPat': (githubPat as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateMigrationSourceInput<TRes>
    implements CopyWith$Input$CreateMigrationSourceInput<TRes> {
  _CopyWithStubImpl$Input$CreateMigrationSourceInput(this._res);

  TRes _res;

  call({
    String? name,
    String? url,
    String? accessToken,
    Enum$MigrationSourceType? type,
    String? ownerId,
    String? githubPat,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateProjectInput {
  factory Input$CreateProjectInput({
    required String ownerId,
    required String name,
    String? body,
    Enum$ProjectTemplate? template,
    List<String>? repositoryIds,
    String? clientMutationId,
  }) =>
      Input$CreateProjectInput._({
        r'ownerId': ownerId,
        r'name': name,
        if (body != null) r'body': body,
        if (template != null) r'template': template,
        if (repositoryIds != null) r'repositoryIds': repositoryIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateProjectInput._(this._$data);

  factory Input$CreateProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = l$template == null
          ? null
          : fromJson$Enum$ProjectTemplate((l$template as String));
    }
    if (data.containsKey('repositoryIds')) {
      final l$repositoryIds = data['repositoryIds'];
      result$data['repositoryIds'] = (l$repositoryIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get ownerId => (_$data['ownerId'] as String);
  String get name => (_$data['name'] as String);
  String? get body => (_$data['body'] as String?);
  Enum$ProjectTemplate? get template =>
      (_$data['template'] as Enum$ProjectTemplate?);
  List<String>? get repositoryIds => (_$data['repositoryIds'] as List<String>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] =
          l$template == null ? null : toJson$Enum$ProjectTemplate(l$template);
    }
    if (_$data.containsKey('repositoryIds')) {
      final l$repositoryIds = repositoryIds;
      result$data['repositoryIds'] = l$repositoryIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateProjectInput<Input$CreateProjectInput> get copyWith =>
      CopyWith$Input$CreateProjectInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    final l$repositoryIds = repositoryIds;
    final lOther$repositoryIds = other.repositoryIds;
    if (_$data.containsKey('repositoryIds') !=
        other._$data.containsKey('repositoryIds')) {
      return false;
    }
    if (l$repositoryIds != null && lOther$repositoryIds != null) {
      if (l$repositoryIds.length != lOther$repositoryIds.length) {
        return false;
      }
      for (int i = 0; i < l$repositoryIds.length; i++) {
        final l$repositoryIds$entry = l$repositoryIds[i];
        final lOther$repositoryIds$entry = lOther$repositoryIds[i];
        if (l$repositoryIds$entry != lOther$repositoryIds$entry) {
          return false;
        }
      }
    } else if (l$repositoryIds != lOther$repositoryIds) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ownerId = ownerId;
    final l$name = name;
    final l$body = body;
    final l$template = template;
    final l$repositoryIds = repositoryIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$ownerId,
      l$name,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('template') ? l$template : const {},
      _$data.containsKey('repositoryIds')
          ? l$repositoryIds == null
              ? null
              : Object.hashAll(l$repositoryIds.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateProjectInput<TRes> {
  factory CopyWith$Input$CreateProjectInput(
    Input$CreateProjectInput instance,
    TRes Function(Input$CreateProjectInput) then,
  ) = _CopyWithImpl$Input$CreateProjectInput;

  factory CopyWith$Input$CreateProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateProjectInput;

  TRes call({
    String? ownerId,
    String? name,
    String? body,
    Enum$ProjectTemplate? template,
    List<String>? repositoryIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateProjectInput<TRes>
    implements CopyWith$Input$CreateProjectInput<TRes> {
  _CopyWithImpl$Input$CreateProjectInput(
    this._instance,
    this._then,
  );

  final Input$CreateProjectInput _instance;

  final TRes Function(Input$CreateProjectInput) _then;

  static const _undefined = {};

  TRes call({
    Object? ownerId = _undefined,
    Object? name = _undefined,
    Object? body = _undefined,
    Object? template = _undefined,
    Object? repositoryIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateProjectInput._({
        ..._instance._$data,
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (body != _undefined) 'body': (body as String?),
        if (template != _undefined)
          'template': (template as Enum$ProjectTemplate?),
        if (repositoryIds != _undefined)
          'repositoryIds': (repositoryIds as List<String>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateProjectInput<TRes>
    implements CopyWith$Input$CreateProjectInput<TRes> {
  _CopyWithStubImpl$Input$CreateProjectInput(this._res);

  TRes _res;

  call({
    String? ownerId,
    String? name,
    String? body,
    Enum$ProjectTemplate? template,
    List<String>? repositoryIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateProjectV2Input {
  factory Input$CreateProjectV2Input({
    required String ownerId,
    required String title,
    String? repositoryId,
    String? teamId,
    String? clientMutationId,
  }) =>
      Input$CreateProjectV2Input._({
        r'ownerId': ownerId,
        r'title': title,
        if (repositoryId != null) r'repositoryId': repositoryId,
        if (teamId != null) r'teamId': teamId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateProjectV2Input._(this._$data);

  factory Input$CreateProjectV2Input.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = (l$repositoryId as String?);
    }
    if (data.containsKey('teamId')) {
      final l$teamId = data['teamId'];
      result$data['teamId'] = (l$teamId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateProjectV2Input._(result$data);
  }

  Map<String, dynamic> _$data;

  String get ownerId => (_$data['ownerId'] as String);
  String get title => (_$data['title'] as String);
  String? get repositoryId => (_$data['repositoryId'] as String?);
  String? get teamId => (_$data['teamId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId;
    }
    if (_$data.containsKey('teamId')) {
      final l$teamId = teamId;
      result$data['teamId'] = l$teamId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateProjectV2Input<Input$CreateProjectV2Input>
      get copyWith => CopyWith$Input$CreateProjectV2Input(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateProjectV2Input) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (_$data.containsKey('teamId') != other._$data.containsKey('teamId')) {
      return false;
    }
    if (l$teamId != lOther$teamId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ownerId = ownerId;
    final l$title = title;
    final l$repositoryId = repositoryId;
    final l$teamId = teamId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$ownerId,
      l$title,
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
      _$data.containsKey('teamId') ? l$teamId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateProjectV2Input<TRes> {
  factory CopyWith$Input$CreateProjectV2Input(
    Input$CreateProjectV2Input instance,
    TRes Function(Input$CreateProjectV2Input) then,
  ) = _CopyWithImpl$Input$CreateProjectV2Input;

  factory CopyWith$Input$CreateProjectV2Input.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateProjectV2Input;

  TRes call({
    String? ownerId,
    String? title,
    String? repositoryId,
    String? teamId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateProjectV2Input<TRes>
    implements CopyWith$Input$CreateProjectV2Input<TRes> {
  _CopyWithImpl$Input$CreateProjectV2Input(
    this._instance,
    this._then,
  );

  final Input$CreateProjectV2Input _instance;

  final TRes Function(Input$CreateProjectV2Input) _then;

  static const _undefined = {};

  TRes call({
    Object? ownerId = _undefined,
    Object? title = _undefined,
    Object? repositoryId = _undefined,
    Object? teamId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateProjectV2Input._({
        ..._instance._$data,
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (repositoryId != _undefined)
          'repositoryId': (repositoryId as String?),
        if (teamId != _undefined) 'teamId': (teamId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateProjectV2Input<TRes>
    implements CopyWith$Input$CreateProjectV2Input<TRes> {
  _CopyWithStubImpl$Input$CreateProjectV2Input(this._res);

  TRes _res;

  call({
    String? ownerId,
    String? title,
    String? repositoryId,
    String? teamId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreatePullRequestInput {
  factory Input$CreatePullRequestInput({
    required String repositoryId,
    required String baseRefName,
    required String headRefName,
    required String title,
    String? body,
    bool? maintainerCanModify,
    bool? draft,
    String? clientMutationId,
  }) =>
      Input$CreatePullRequestInput._({
        r'repositoryId': repositoryId,
        r'baseRefName': baseRefName,
        r'headRefName': headRefName,
        r'title': title,
        if (body != null) r'body': body,
        if (maintainerCanModify != null)
          r'maintainerCanModify': maintainerCanModify,
        if (draft != null) r'draft': draft,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreatePullRequestInput._(this._$data);

  factory Input$CreatePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$baseRefName = data['baseRefName'];
    result$data['baseRefName'] = (l$baseRefName as String);
    final l$headRefName = data['headRefName'];
    result$data['headRefName'] = (l$headRefName as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = data['maintainerCanModify'];
      result$data['maintainerCanModify'] = (l$maintainerCanModify as bool?);
    }
    if (data.containsKey('draft')) {
      final l$draft = data['draft'];
      result$data['draft'] = (l$draft as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreatePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get baseRefName => (_$data['baseRefName'] as String);
  String get headRefName => (_$data['headRefName'] as String);
  String get title => (_$data['title'] as String);
  String? get body => (_$data['body'] as String?);
  bool? get maintainerCanModify => (_$data['maintainerCanModify'] as bool?);
  bool? get draft => (_$data['draft'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$baseRefName = baseRefName;
    result$data['baseRefName'] = l$baseRefName;
    final l$headRefName = headRefName;
    result$data['headRefName'] = l$headRefName;
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = maintainerCanModify;
      result$data['maintainerCanModify'] = l$maintainerCanModify;
    }
    if (_$data.containsKey('draft')) {
      final l$draft = draft;
      result$data['draft'] = l$draft;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreatePullRequestInput<Input$CreatePullRequestInput>
      get copyWith => CopyWith$Input$CreatePullRequestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreatePullRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$baseRefName = baseRefName;
    final lOther$baseRefName = other.baseRefName;
    if (l$baseRefName != lOther$baseRefName) {
      return false;
    }
    final l$headRefName = headRefName;
    final lOther$headRefName = other.headRefName;
    if (l$headRefName != lOther$headRefName) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$maintainerCanModify = maintainerCanModify;
    final lOther$maintainerCanModify = other.maintainerCanModify;
    if (_$data.containsKey('maintainerCanModify') !=
        other._$data.containsKey('maintainerCanModify')) {
      return false;
    }
    if (l$maintainerCanModify != lOther$maintainerCanModify) {
      return false;
    }
    final l$draft = draft;
    final lOther$draft = other.draft;
    if (_$data.containsKey('draft') != other._$data.containsKey('draft')) {
      return false;
    }
    if (l$draft != lOther$draft) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$baseRefName = baseRefName;
    final l$headRefName = headRefName;
    final l$title = title;
    final l$body = body;
    final l$maintainerCanModify = maintainerCanModify;
    final l$draft = draft;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$baseRefName,
      l$headRefName,
      l$title,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('maintainerCanModify')
          ? l$maintainerCanModify
          : const {},
      _$data.containsKey('draft') ? l$draft : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreatePullRequestInput<TRes> {
  factory CopyWith$Input$CreatePullRequestInput(
    Input$CreatePullRequestInput instance,
    TRes Function(Input$CreatePullRequestInput) then,
  ) = _CopyWithImpl$Input$CreatePullRequestInput;

  factory CopyWith$Input$CreatePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreatePullRequestInput;

  TRes call({
    String? repositoryId,
    String? baseRefName,
    String? headRefName,
    String? title,
    String? body,
    bool? maintainerCanModify,
    bool? draft,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreatePullRequestInput<TRes>
    implements CopyWith$Input$CreatePullRequestInput<TRes> {
  _CopyWithImpl$Input$CreatePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreatePullRequestInput _instance;

  final TRes Function(Input$CreatePullRequestInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? baseRefName = _undefined,
    Object? headRefName = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? maintainerCanModify = _undefined,
    Object? draft = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreatePullRequestInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (baseRefName != _undefined && baseRefName != null)
          'baseRefName': (baseRefName as String),
        if (headRefName != _undefined && headRefName != null)
          'headRefName': (headRefName as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (body != _undefined) 'body': (body as String?),
        if (maintainerCanModify != _undefined)
          'maintainerCanModify': (maintainerCanModify as bool?),
        if (draft != _undefined) 'draft': (draft as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreatePullRequestInput<TRes>
    implements CopyWith$Input$CreatePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreatePullRequestInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? baseRefName,
    String? headRefName,
    String? title,
    String? body,
    bool? maintainerCanModify,
    bool? draft,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateRefInput {
  factory Input$CreateRefInput({
    required String repositoryId,
    required String name,
    required String oid,
    String? clientMutationId,
  }) =>
      Input$CreateRefInput._({
        r'repositoryId': repositoryId,
        r'name': name,
        r'oid': oid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateRefInput._(this._$data);

  factory Input$CreateRefInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$oid = data['oid'];
    result$data['oid'] = (l$oid as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateRefInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get name => (_$data['name'] as String);
  String get oid => (_$data['oid'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$name = name;
    result$data['name'] = l$name;
    final l$oid = oid;
    result$data['oid'] = l$oid;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateRefInput<Input$CreateRefInput> get copyWith =>
      CopyWith$Input$CreateRefInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateRefInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$oid = oid;
    final lOther$oid = other.oid;
    if (l$oid != lOther$oid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$oid = oid;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$name,
      l$oid,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateRefInput<TRes> {
  factory CopyWith$Input$CreateRefInput(
    Input$CreateRefInput instance,
    TRes Function(Input$CreateRefInput) then,
  ) = _CopyWithImpl$Input$CreateRefInput;

  factory CopyWith$Input$CreateRefInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRefInput;

  TRes call({
    String? repositoryId,
    String? name,
    String? oid,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateRefInput<TRes>
    implements CopyWith$Input$CreateRefInput<TRes> {
  _CopyWithImpl$Input$CreateRefInput(
    this._instance,
    this._then,
  );

  final Input$CreateRefInput _instance;

  final TRes Function(Input$CreateRefInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? oid = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateRefInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (oid != _undefined && oid != null) 'oid': (oid as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateRefInput<TRes>
    implements CopyWith$Input$CreateRefInput<TRes> {
  _CopyWithStubImpl$Input$CreateRefInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? name,
    String? oid,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateRepositoryInput {
  factory Input$CreateRepositoryInput({
    required String name,
    String? ownerId,
    String? description,
    required Enum$RepositoryVisibility visibility,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    String? teamId,
    String? clientMutationId,
  }) =>
      Input$CreateRepositoryInput._({
        r'name': name,
        if (ownerId != null) r'ownerId': ownerId,
        if (description != null) r'description': description,
        r'visibility': visibility,
        if (template != null) r'template': template,
        if (homepageUrl != null) r'homepageUrl': homepageUrl,
        if (hasWikiEnabled != null) r'hasWikiEnabled': hasWikiEnabled,
        if (hasIssuesEnabled != null) r'hasIssuesEnabled': hasIssuesEnabled,
        if (teamId != null) r'teamId': teamId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateRepositoryInput._(this._$data);

  factory Input$CreateRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$visibility = data['visibility'];
    result$data['visibility'] =
        fromJson$Enum$RepositoryVisibility((l$visibility as String));
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = (l$template as bool?);
    }
    if (data.containsKey('homepageUrl')) {
      final l$homepageUrl = data['homepageUrl'];
      result$data['homepageUrl'] = (l$homepageUrl as String?);
    }
    if (data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = data['hasWikiEnabled'];
      result$data['hasWikiEnabled'] = (l$hasWikiEnabled as bool?);
    }
    if (data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = data['hasIssuesEnabled'];
      result$data['hasIssuesEnabled'] = (l$hasIssuesEnabled as bool?);
    }
    if (data.containsKey('teamId')) {
      final l$teamId = data['teamId'];
      result$data['teamId'] = (l$teamId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  String? get ownerId => (_$data['ownerId'] as String?);
  String? get description => (_$data['description'] as String?);
  Enum$RepositoryVisibility get visibility =>
      (_$data['visibility'] as Enum$RepositoryVisibility);
  bool? get template => (_$data['template'] as bool?);
  String? get homepageUrl => (_$data['homepageUrl'] as String?);
  bool? get hasWikiEnabled => (_$data['hasWikiEnabled'] as bool?);
  bool? get hasIssuesEnabled => (_$data['hasIssuesEnabled'] as bool?);
  String? get teamId => (_$data['teamId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$visibility = visibility;
    result$data['visibility'] = toJson$Enum$RepositoryVisibility(l$visibility);
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] = l$template;
    }
    if (_$data.containsKey('homepageUrl')) {
      final l$homepageUrl = homepageUrl;
      result$data['homepageUrl'] = l$homepageUrl;
    }
    if (_$data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = hasWikiEnabled;
      result$data['hasWikiEnabled'] = l$hasWikiEnabled;
    }
    if (_$data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = hasIssuesEnabled;
      result$data['hasIssuesEnabled'] = l$hasIssuesEnabled;
    }
    if (_$data.containsKey('teamId')) {
      final l$teamId = teamId;
      result$data['teamId'] = l$teamId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateRepositoryInput<Input$CreateRepositoryInput>
      get copyWith => CopyWith$Input$CreateRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$visibility = visibility;
    final lOther$visibility = other.visibility;
    if (l$visibility != lOther$visibility) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    final l$homepageUrl = homepageUrl;
    final lOther$homepageUrl = other.homepageUrl;
    if (_$data.containsKey('homepageUrl') !=
        other._$data.containsKey('homepageUrl')) {
      return false;
    }
    if (l$homepageUrl != lOther$homepageUrl) {
      return false;
    }
    final l$hasWikiEnabled = hasWikiEnabled;
    final lOther$hasWikiEnabled = other.hasWikiEnabled;
    if (_$data.containsKey('hasWikiEnabled') !=
        other._$data.containsKey('hasWikiEnabled')) {
      return false;
    }
    if (l$hasWikiEnabled != lOther$hasWikiEnabled) {
      return false;
    }
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final lOther$hasIssuesEnabled = other.hasIssuesEnabled;
    if (_$data.containsKey('hasIssuesEnabled') !=
        other._$data.containsKey('hasIssuesEnabled')) {
      return false;
    }
    if (l$hasIssuesEnabled != lOther$hasIssuesEnabled) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (_$data.containsKey('teamId') != other._$data.containsKey('teamId')) {
      return false;
    }
    if (l$teamId != lOther$teamId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$ownerId = ownerId;
    final l$description = description;
    final l$visibility = visibility;
    final l$template = template;
    final l$homepageUrl = homepageUrl;
    final l$hasWikiEnabled = hasWikiEnabled;
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final l$teamId = teamId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$name,
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('description') ? l$description : const {},
      l$visibility,
      _$data.containsKey('template') ? l$template : const {},
      _$data.containsKey('homepageUrl') ? l$homepageUrl : const {},
      _$data.containsKey('hasWikiEnabled') ? l$hasWikiEnabled : const {},
      _$data.containsKey('hasIssuesEnabled') ? l$hasIssuesEnabled : const {},
      _$data.containsKey('teamId') ? l$teamId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateRepositoryInput<TRes> {
  factory CopyWith$Input$CreateRepositoryInput(
    Input$CreateRepositoryInput instance,
    TRes Function(Input$CreateRepositoryInput) then,
  ) = _CopyWithImpl$Input$CreateRepositoryInput;

  factory CopyWith$Input$CreateRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRepositoryInput;

  TRes call({
    String? name,
    String? ownerId,
    String? description,
    Enum$RepositoryVisibility? visibility,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    String? teamId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateRepositoryInput<TRes>
    implements CopyWith$Input$CreateRepositoryInput<TRes> {
  _CopyWithImpl$Input$CreateRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$CreateRepositoryInput _instance;

  final TRes Function(Input$CreateRepositoryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? name = _undefined,
    Object? ownerId = _undefined,
    Object? description = _undefined,
    Object? visibility = _undefined,
    Object? template = _undefined,
    Object? homepageUrl = _undefined,
    Object? hasWikiEnabled = _undefined,
    Object? hasIssuesEnabled = _undefined,
    Object? teamId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateRepositoryInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
        if (description != _undefined) 'description': (description as String?),
        if (visibility != _undefined && visibility != null)
          'visibility': (visibility as Enum$RepositoryVisibility),
        if (template != _undefined) 'template': (template as bool?),
        if (homepageUrl != _undefined) 'homepageUrl': (homepageUrl as String?),
        if (hasWikiEnabled != _undefined)
          'hasWikiEnabled': (hasWikiEnabled as bool?),
        if (hasIssuesEnabled != _undefined)
          'hasIssuesEnabled': (hasIssuesEnabled as bool?),
        if (teamId != _undefined) 'teamId': (teamId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateRepositoryInput<TRes>
    implements CopyWith$Input$CreateRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$CreateRepositoryInput(this._res);

  TRes _res;

  call({
    String? name,
    String? ownerId,
    String? description,
    Enum$RepositoryVisibility? visibility,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    String? teamId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateSponsorshipInput {
  factory Input$CreateSponsorshipInput({
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? tierId,
    int? amount,
    bool? isRecurring,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
    String? clientMutationId,
  }) =>
      Input$CreateSponsorshipInput._({
        if (sponsorId != null) r'sponsorId': sponsorId,
        if (sponsorLogin != null) r'sponsorLogin': sponsorLogin,
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        if (tierId != null) r'tierId': tierId,
        if (amount != null) r'amount': amount,
        if (isRecurring != null) r'isRecurring': isRecurring,
        if (receiveEmails != null) r'receiveEmails': receiveEmails,
        if (privacyLevel != null) r'privacyLevel': privacyLevel,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateSponsorshipInput._(this._$data);

  factory Input$CreateSponsorshipInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('sponsorId')) {
      final l$sponsorId = data['sponsorId'];
      result$data['sponsorId'] = (l$sponsorId as String?);
    }
    if (data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = data['sponsorLogin'];
      result$data['sponsorLogin'] = (l$sponsorLogin as String?);
    }
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    if (data.containsKey('tierId')) {
      final l$tierId = data['tierId'];
      result$data['tierId'] = (l$tierId as String?);
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = (l$amount as int?);
    }
    if (data.containsKey('isRecurring')) {
      final l$isRecurring = data['isRecurring'];
      result$data['isRecurring'] = (l$isRecurring as bool?);
    }
    if (data.containsKey('receiveEmails')) {
      final l$receiveEmails = data['receiveEmails'];
      result$data['receiveEmails'] = (l$receiveEmails as bool?);
    }
    if (data.containsKey('privacyLevel')) {
      final l$privacyLevel = data['privacyLevel'];
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : fromJson$Enum$SponsorshipPrivacy((l$privacyLevel as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateSponsorshipInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get sponsorId => (_$data['sponsorId'] as String?);
  String? get sponsorLogin => (_$data['sponsorLogin'] as String?);
  String? get sponsorableId => (_$data['sponsorableId'] as String?);
  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);
  String? get tierId => (_$data['tierId'] as String?);
  int? get amount => (_$data['amount'] as int?);
  bool? get isRecurring => (_$data['isRecurring'] as bool?);
  bool? get receiveEmails => (_$data['receiveEmails'] as bool?);
  Enum$SponsorshipPrivacy? get privacyLevel =>
      (_$data['privacyLevel'] as Enum$SponsorshipPrivacy?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('sponsorId')) {
      final l$sponsorId = sponsorId;
      result$data['sponsorId'] = l$sponsorId;
    }
    if (_$data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = sponsorLogin;
      result$data['sponsorLogin'] = l$sponsorLogin;
    }
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    if (_$data.containsKey('tierId')) {
      final l$tierId = tierId;
      result$data['tierId'] = l$tierId;
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount;
    }
    if (_$data.containsKey('isRecurring')) {
      final l$isRecurring = isRecurring;
      result$data['isRecurring'] = l$isRecurring;
    }
    if (_$data.containsKey('receiveEmails')) {
      final l$receiveEmails = receiveEmails;
      result$data['receiveEmails'] = l$receiveEmails;
    }
    if (_$data.containsKey('privacyLevel')) {
      final l$privacyLevel = privacyLevel;
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : toJson$Enum$SponsorshipPrivacy(l$privacyLevel);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateSponsorshipInput<Input$CreateSponsorshipInput>
      get copyWith => CopyWith$Input$CreateSponsorshipInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateSponsorshipInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$sponsorId = sponsorId;
    final lOther$sponsorId = other.sponsorId;
    if (_$data.containsKey('sponsorId') !=
        other._$data.containsKey('sponsorId')) {
      return false;
    }
    if (l$sponsorId != lOther$sponsorId) {
      return false;
    }
    final l$sponsorLogin = sponsorLogin;
    final lOther$sponsorLogin = other.sponsorLogin;
    if (_$data.containsKey('sponsorLogin') !=
        other._$data.containsKey('sponsorLogin')) {
      return false;
    }
    if (l$sponsorLogin != lOther$sponsorLogin) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$tierId = tierId;
    final lOther$tierId = other.tierId;
    if (_$data.containsKey('tierId') != other._$data.containsKey('tierId')) {
      return false;
    }
    if (l$tierId != lOther$tierId) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$isRecurring = isRecurring;
    final lOther$isRecurring = other.isRecurring;
    if (_$data.containsKey('isRecurring') !=
        other._$data.containsKey('isRecurring')) {
      return false;
    }
    if (l$isRecurring != lOther$isRecurring) {
      return false;
    }
    final l$receiveEmails = receiveEmails;
    final lOther$receiveEmails = other.receiveEmails;
    if (_$data.containsKey('receiveEmails') !=
        other._$data.containsKey('receiveEmails')) {
      return false;
    }
    if (l$receiveEmails != lOther$receiveEmails) {
      return false;
    }
    final l$privacyLevel = privacyLevel;
    final lOther$privacyLevel = other.privacyLevel;
    if (_$data.containsKey('privacyLevel') !=
        other._$data.containsKey('privacyLevel')) {
      return false;
    }
    if (l$privacyLevel != lOther$privacyLevel) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sponsorId = sponsorId;
    final l$sponsorLogin = sponsorLogin;
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$tierId = tierId;
    final l$amount = amount;
    final l$isRecurring = isRecurring;
    final l$receiveEmails = receiveEmails;
    final l$privacyLevel = privacyLevel;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('sponsorId') ? l$sponsorId : const {},
      _$data.containsKey('sponsorLogin') ? l$sponsorLogin : const {},
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      _$data.containsKey('tierId') ? l$tierId : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('isRecurring') ? l$isRecurring : const {},
      _$data.containsKey('receiveEmails') ? l$receiveEmails : const {},
      _$data.containsKey('privacyLevel') ? l$privacyLevel : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateSponsorshipInput<TRes> {
  factory CopyWith$Input$CreateSponsorshipInput(
    Input$CreateSponsorshipInput instance,
    TRes Function(Input$CreateSponsorshipInput) then,
  ) = _CopyWithImpl$Input$CreateSponsorshipInput;

  factory CopyWith$Input$CreateSponsorshipInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSponsorshipInput;

  TRes call({
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? tierId,
    int? amount,
    bool? isRecurring,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateSponsorshipInput<TRes>
    implements CopyWith$Input$CreateSponsorshipInput<TRes> {
  _CopyWithImpl$Input$CreateSponsorshipInput(
    this._instance,
    this._then,
  );

  final Input$CreateSponsorshipInput _instance;

  final TRes Function(Input$CreateSponsorshipInput) _then;

  static const _undefined = {};

  TRes call({
    Object? sponsorId = _undefined,
    Object? sponsorLogin = _undefined,
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? tierId = _undefined,
    Object? amount = _undefined,
    Object? isRecurring = _undefined,
    Object? receiveEmails = _undefined,
    Object? privacyLevel = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateSponsorshipInput._({
        ..._instance._$data,
        if (sponsorId != _undefined) 'sponsorId': (sponsorId as String?),
        if (sponsorLogin != _undefined)
          'sponsorLogin': (sponsorLogin as String?),
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (tierId != _undefined) 'tierId': (tierId as String?),
        if (amount != _undefined) 'amount': (amount as int?),
        if (isRecurring != _undefined) 'isRecurring': (isRecurring as bool?),
        if (receiveEmails != _undefined)
          'receiveEmails': (receiveEmails as bool?),
        if (privacyLevel != _undefined)
          'privacyLevel': (privacyLevel as Enum$SponsorshipPrivacy?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateSponsorshipInput<TRes>
    implements CopyWith$Input$CreateSponsorshipInput<TRes> {
  _CopyWithStubImpl$Input$CreateSponsorshipInput(this._res);

  TRes _res;

  call({
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? tierId,
    int? amount,
    bool? isRecurring,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateSponsorsTierInput {
  factory Input$CreateSponsorsTierInput({
    String? sponsorableId,
    String? sponsorableLogin,
    required int amount,
    bool? isRecurring,
    String? repositoryId,
    String? repositoryOwnerLogin,
    String? repositoryName,
    String? welcomeMessage,
    required String description,
    bool? publish,
    String? clientMutationId,
  }) =>
      Input$CreateSponsorsTierInput._({
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        r'amount': amount,
        if (isRecurring != null) r'isRecurring': isRecurring,
        if (repositoryId != null) r'repositoryId': repositoryId,
        if (repositoryOwnerLogin != null)
          r'repositoryOwnerLogin': repositoryOwnerLogin,
        if (repositoryName != null) r'repositoryName': repositoryName,
        if (welcomeMessage != null) r'welcomeMessage': welcomeMessage,
        r'description': description,
        if (publish != null) r'publish': publish,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateSponsorsTierInput._(this._$data);

  factory Input$CreateSponsorsTierInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    final l$amount = data['amount'];
    result$data['amount'] = (l$amount as int);
    if (data.containsKey('isRecurring')) {
      final l$isRecurring = data['isRecurring'];
      result$data['isRecurring'] = (l$isRecurring as bool?);
    }
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = (l$repositoryId as String?);
    }
    if (data.containsKey('repositoryOwnerLogin')) {
      final l$repositoryOwnerLogin = data['repositoryOwnerLogin'];
      result$data['repositoryOwnerLogin'] = (l$repositoryOwnerLogin as String?);
    }
    if (data.containsKey('repositoryName')) {
      final l$repositoryName = data['repositoryName'];
      result$data['repositoryName'] = (l$repositoryName as String?);
    }
    if (data.containsKey('welcomeMessage')) {
      final l$welcomeMessage = data['welcomeMessage'];
      result$data['welcomeMessage'] = (l$welcomeMessage as String?);
    }
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    if (data.containsKey('publish')) {
      final l$publish = data['publish'];
      result$data['publish'] = (l$publish as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateSponsorsTierInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get sponsorableId => (_$data['sponsorableId'] as String?);
  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);
  int get amount => (_$data['amount'] as int);
  bool? get isRecurring => (_$data['isRecurring'] as bool?);
  String? get repositoryId => (_$data['repositoryId'] as String?);
  String? get repositoryOwnerLogin =>
      (_$data['repositoryOwnerLogin'] as String?);
  String? get repositoryName => (_$data['repositoryName'] as String?);
  String? get welcomeMessage => (_$data['welcomeMessage'] as String?);
  String get description => (_$data['description'] as String);
  bool? get publish => (_$data['publish'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    final l$amount = amount;
    result$data['amount'] = l$amount;
    if (_$data.containsKey('isRecurring')) {
      final l$isRecurring = isRecurring;
      result$data['isRecurring'] = l$isRecurring;
    }
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId;
    }
    if (_$data.containsKey('repositoryOwnerLogin')) {
      final l$repositoryOwnerLogin = repositoryOwnerLogin;
      result$data['repositoryOwnerLogin'] = l$repositoryOwnerLogin;
    }
    if (_$data.containsKey('repositoryName')) {
      final l$repositoryName = repositoryName;
      result$data['repositoryName'] = l$repositoryName;
    }
    if (_$data.containsKey('welcomeMessage')) {
      final l$welcomeMessage = welcomeMessage;
      result$data['welcomeMessage'] = l$welcomeMessage;
    }
    final l$description = description;
    result$data['description'] = l$description;
    if (_$data.containsKey('publish')) {
      final l$publish = publish;
      result$data['publish'] = l$publish;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateSponsorsTierInput<Input$CreateSponsorsTierInput>
      get copyWith => CopyWith$Input$CreateSponsorsTierInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateSponsorsTierInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$isRecurring = isRecurring;
    final lOther$isRecurring = other.isRecurring;
    if (_$data.containsKey('isRecurring') !=
        other._$data.containsKey('isRecurring')) {
      return false;
    }
    if (l$isRecurring != lOther$isRecurring) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$repositoryOwnerLogin = repositoryOwnerLogin;
    final lOther$repositoryOwnerLogin = other.repositoryOwnerLogin;
    if (_$data.containsKey('repositoryOwnerLogin') !=
        other._$data.containsKey('repositoryOwnerLogin')) {
      return false;
    }
    if (l$repositoryOwnerLogin != lOther$repositoryOwnerLogin) {
      return false;
    }
    final l$repositoryName = repositoryName;
    final lOther$repositoryName = other.repositoryName;
    if (_$data.containsKey('repositoryName') !=
        other._$data.containsKey('repositoryName')) {
      return false;
    }
    if (l$repositoryName != lOther$repositoryName) {
      return false;
    }
    final l$welcomeMessage = welcomeMessage;
    final lOther$welcomeMessage = other.welcomeMessage;
    if (_$data.containsKey('welcomeMessage') !=
        other._$data.containsKey('welcomeMessage')) {
      return false;
    }
    if (l$welcomeMessage != lOther$welcomeMessage) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$publish = publish;
    final lOther$publish = other.publish;
    if (_$data.containsKey('publish') != other._$data.containsKey('publish')) {
      return false;
    }
    if (l$publish != lOther$publish) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$amount = amount;
    final l$isRecurring = isRecurring;
    final l$repositoryId = repositoryId;
    final l$repositoryOwnerLogin = repositoryOwnerLogin;
    final l$repositoryName = repositoryName;
    final l$welcomeMessage = welcomeMessage;
    final l$description = description;
    final l$publish = publish;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      l$amount,
      _$data.containsKey('isRecurring') ? l$isRecurring : const {},
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
      _$data.containsKey('repositoryOwnerLogin')
          ? l$repositoryOwnerLogin
          : const {},
      _$data.containsKey('repositoryName') ? l$repositoryName : const {},
      _$data.containsKey('welcomeMessage') ? l$welcomeMessage : const {},
      l$description,
      _$data.containsKey('publish') ? l$publish : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateSponsorsTierInput<TRes> {
  factory CopyWith$Input$CreateSponsorsTierInput(
    Input$CreateSponsorsTierInput instance,
    TRes Function(Input$CreateSponsorsTierInput) then,
  ) = _CopyWithImpl$Input$CreateSponsorsTierInput;

  factory CopyWith$Input$CreateSponsorsTierInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSponsorsTierInput;

  TRes call({
    String? sponsorableId,
    String? sponsorableLogin,
    int? amount,
    bool? isRecurring,
    String? repositoryId,
    String? repositoryOwnerLogin,
    String? repositoryName,
    String? welcomeMessage,
    String? description,
    bool? publish,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateSponsorsTierInput<TRes>
    implements CopyWith$Input$CreateSponsorsTierInput<TRes> {
  _CopyWithImpl$Input$CreateSponsorsTierInput(
    this._instance,
    this._then,
  );

  final Input$CreateSponsorsTierInput _instance;

  final TRes Function(Input$CreateSponsorsTierInput) _then;

  static const _undefined = {};

  TRes call({
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? amount = _undefined,
    Object? isRecurring = _undefined,
    Object? repositoryId = _undefined,
    Object? repositoryOwnerLogin = _undefined,
    Object? repositoryName = _undefined,
    Object? welcomeMessage = _undefined,
    Object? description = _undefined,
    Object? publish = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateSponsorsTierInput._({
        ..._instance._$data,
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (amount != _undefined && amount != null) 'amount': (amount as int),
        if (isRecurring != _undefined) 'isRecurring': (isRecurring as bool?),
        if (repositoryId != _undefined)
          'repositoryId': (repositoryId as String?),
        if (repositoryOwnerLogin != _undefined)
          'repositoryOwnerLogin': (repositoryOwnerLogin as String?),
        if (repositoryName != _undefined)
          'repositoryName': (repositoryName as String?),
        if (welcomeMessage != _undefined)
          'welcomeMessage': (welcomeMessage as String?),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (publish != _undefined) 'publish': (publish as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateSponsorsTierInput<TRes>
    implements CopyWith$Input$CreateSponsorsTierInput<TRes> {
  _CopyWithStubImpl$Input$CreateSponsorsTierInput(this._res);

  TRes _res;

  call({
    String? sponsorableId,
    String? sponsorableLogin,
    int? amount,
    bool? isRecurring,
    String? repositoryId,
    String? repositoryOwnerLogin,
    String? repositoryName,
    String? welcomeMessage,
    String? description,
    bool? publish,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateTeamDiscussionCommentInput {
  factory Input$CreateTeamDiscussionCommentInput({
    required String discussionId,
    required String body,
    String? clientMutationId,
  }) =>
      Input$CreateTeamDiscussionCommentInput._({
        r'discussionId': discussionId,
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateTeamDiscussionCommentInput._(this._$data);

  factory Input$CreateTeamDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateTeamDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get discussionId => (_$data['discussionId'] as String);
  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateTeamDiscussionCommentInput<
          Input$CreateTeamDiscussionCommentInput>
      get copyWith => CopyWith$Input$CreateTeamDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateTeamDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$discussionId = discussionId;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$discussionId,
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateTeamDiscussionCommentInput<TRes> {
  factory CopyWith$Input$CreateTeamDiscussionCommentInput(
    Input$CreateTeamDiscussionCommentInput instance,
    TRes Function(Input$CreateTeamDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$CreateTeamDiscussionCommentInput;

  factory CopyWith$Input$CreateTeamDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateTeamDiscussionCommentInput;

  TRes call({
    String? discussionId,
    String? body,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$CreateTeamDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$CreateTeamDiscussionCommentInput _instance;

  final TRes Function(Input$CreateTeamDiscussionCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? discussionId = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateTeamDiscussionCommentInput._({
        ..._instance._$data,
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$CreateTeamDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? discussionId,
    String? body,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$CreateTeamDiscussionInput {
  factory Input$CreateTeamDiscussionInput({
    required String teamId,
    required String title,
    required String body,
    bool? private,
    String? clientMutationId,
  }) =>
      Input$CreateTeamDiscussionInput._({
        r'teamId': teamId,
        r'title': title,
        r'body': body,
        if (private != null) r'private': private,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$CreateTeamDiscussionInput._(this._$data);

  factory Input$CreateTeamDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$teamId = data['teamId'];
    result$data['teamId'] = (l$teamId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('private')) {
      final l$private = data['private'];
      result$data['private'] = (l$private as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$CreateTeamDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get teamId => (_$data['teamId'] as String);
  String get title => (_$data['title'] as String);
  String get body => (_$data['body'] as String);
  bool? get private => (_$data['private'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$teamId = teamId;
    result$data['teamId'] = l$teamId;
    final l$title = title;
    result$data['title'] = l$title;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('private')) {
      final l$private = private;
      result$data['private'] = l$private;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$CreateTeamDiscussionInput<Input$CreateTeamDiscussionInput>
      get copyWith => CopyWith$Input$CreateTeamDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateTeamDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (l$teamId != lOther$teamId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$private = private;
    final lOther$private = other.private;
    if (_$data.containsKey('private') != other._$data.containsKey('private')) {
      return false;
    }
    if (l$private != lOther$private) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$teamId = teamId;
    final l$title = title;
    final l$body = body;
    final l$private = private;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$teamId,
      l$title,
      l$body,
      _$data.containsKey('private') ? l$private : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateTeamDiscussionInput<TRes> {
  factory CopyWith$Input$CreateTeamDiscussionInput(
    Input$CreateTeamDiscussionInput instance,
    TRes Function(Input$CreateTeamDiscussionInput) then,
  ) = _CopyWithImpl$Input$CreateTeamDiscussionInput;

  factory CopyWith$Input$CreateTeamDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateTeamDiscussionInput;

  TRes call({
    String? teamId,
    String? title,
    String? body,
    bool? private,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$CreateTeamDiscussionInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionInput<TRes> {
  _CopyWithImpl$Input$CreateTeamDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$CreateTeamDiscussionInput _instance;

  final TRes Function(Input$CreateTeamDiscussionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? teamId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? private = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$CreateTeamDiscussionInput._({
        ..._instance._$data,
        if (teamId != _undefined && teamId != null)
          'teamId': (teamId as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (private != _undefined) 'private': (private as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateTeamDiscussionInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$CreateTeamDiscussionInput(this._res);

  TRes _res;

  call({
    String? teamId,
    String? title,
    String? body,
    bool? private,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeclineTopicSuggestionInput {
  factory Input$DeclineTopicSuggestionInput({
    required String repositoryId,
    required String name,
    required Enum$TopicSuggestionDeclineReason reason,
    String? clientMutationId,
  }) =>
      Input$DeclineTopicSuggestionInput._({
        r'repositoryId': repositoryId,
        r'name': name,
        r'reason': reason,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeclineTopicSuggestionInput._(this._$data);

  factory Input$DeclineTopicSuggestionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$reason = data['reason'];
    result$data['reason'] =
        fromJson$Enum$TopicSuggestionDeclineReason((l$reason as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeclineTopicSuggestionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get name => (_$data['name'] as String);
  Enum$TopicSuggestionDeclineReason get reason =>
      (_$data['reason'] as Enum$TopicSuggestionDeclineReason);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$name = name;
    result$data['name'] = l$name;
    final l$reason = reason;
    result$data['reason'] = toJson$Enum$TopicSuggestionDeclineReason(l$reason);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeclineTopicSuggestionInput<Input$DeclineTopicSuggestionInput>
      get copyWith => CopyWith$Input$DeclineTopicSuggestionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeclineTopicSuggestionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (l$reason != lOther$reason) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$reason = reason;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$name,
      l$reason,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeclineTopicSuggestionInput<TRes> {
  factory CopyWith$Input$DeclineTopicSuggestionInput(
    Input$DeclineTopicSuggestionInput instance,
    TRes Function(Input$DeclineTopicSuggestionInput) then,
  ) = _CopyWithImpl$Input$DeclineTopicSuggestionInput;

  factory CopyWith$Input$DeclineTopicSuggestionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeclineTopicSuggestionInput;

  TRes call({
    String? repositoryId,
    String? name,
    Enum$TopicSuggestionDeclineReason? reason,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeclineTopicSuggestionInput<TRes>
    implements CopyWith$Input$DeclineTopicSuggestionInput<TRes> {
  _CopyWithImpl$Input$DeclineTopicSuggestionInput(
    this._instance,
    this._then,
  );

  final Input$DeclineTopicSuggestionInput _instance;

  final TRes Function(Input$DeclineTopicSuggestionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? reason = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeclineTopicSuggestionInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (reason != _undefined && reason != null)
          'reason': (reason as Enum$TopicSuggestionDeclineReason),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeclineTopicSuggestionInput<TRes>
    implements CopyWith$Input$DeclineTopicSuggestionInput<TRes> {
  _CopyWithStubImpl$Input$DeclineTopicSuggestionInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? name,
    Enum$TopicSuggestionDeclineReason? reason,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteBranchProtectionRuleInput {
  factory Input$DeleteBranchProtectionRuleInput({
    required String branchProtectionRuleId,
    String? clientMutationId,
  }) =>
      Input$DeleteBranchProtectionRuleInput._({
        r'branchProtectionRuleId': branchProtectionRuleId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteBranchProtectionRuleInput._(this._$data);

  factory Input$DeleteBranchProtectionRuleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$branchProtectionRuleId = data['branchProtectionRuleId'];
    result$data['branchProtectionRuleId'] =
        (l$branchProtectionRuleId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteBranchProtectionRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get branchProtectionRuleId =>
      (_$data['branchProtectionRuleId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$branchProtectionRuleId = branchProtectionRuleId;
    result$data['branchProtectionRuleId'] = l$branchProtectionRuleId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteBranchProtectionRuleInput<
          Input$DeleteBranchProtectionRuleInput>
      get copyWith => CopyWith$Input$DeleteBranchProtectionRuleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteBranchProtectionRuleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$branchProtectionRuleId = branchProtectionRuleId;
    final lOther$branchProtectionRuleId = other.branchProtectionRuleId;
    if (l$branchProtectionRuleId != lOther$branchProtectionRuleId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$branchProtectionRuleId = branchProtectionRuleId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$branchProtectionRuleId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteBranchProtectionRuleInput<TRes> {
  factory CopyWith$Input$DeleteBranchProtectionRuleInput(
    Input$DeleteBranchProtectionRuleInput instance,
    TRes Function(Input$DeleteBranchProtectionRuleInput) then,
  ) = _CopyWithImpl$Input$DeleteBranchProtectionRuleInput;

  factory CopyWith$Input$DeleteBranchProtectionRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteBranchProtectionRuleInput;

  TRes call({
    String? branchProtectionRuleId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$DeleteBranchProtectionRuleInput<TRes> {
  _CopyWithImpl$Input$DeleteBranchProtectionRuleInput(
    this._instance,
    this._then,
  );

  final Input$DeleteBranchProtectionRuleInput _instance;

  final TRes Function(Input$DeleteBranchProtectionRuleInput) _then;

  static const _undefined = {};

  TRes call({
    Object? branchProtectionRuleId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteBranchProtectionRuleInput._({
        ..._instance._$data,
        if (branchProtectionRuleId != _undefined &&
            branchProtectionRuleId != null)
          'branchProtectionRuleId': (branchProtectionRuleId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$DeleteBranchProtectionRuleInput<TRes> {
  _CopyWithStubImpl$Input$DeleteBranchProtectionRuleInput(this._res);

  TRes _res;

  call({
    String? branchProtectionRuleId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteDeploymentInput {
  factory Input$DeleteDeploymentInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$DeleteDeploymentInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteDeploymentInput._(this._$data);

  factory Input$DeleteDeploymentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteDeploymentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteDeploymentInput<Input$DeleteDeploymentInput>
      get copyWith => CopyWith$Input$DeleteDeploymentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteDeploymentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteDeploymentInput<TRes> {
  factory CopyWith$Input$DeleteDeploymentInput(
    Input$DeleteDeploymentInput instance,
    TRes Function(Input$DeleteDeploymentInput) then,
  ) = _CopyWithImpl$Input$DeleteDeploymentInput;

  factory CopyWith$Input$DeleteDeploymentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteDeploymentInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteDeploymentInput<TRes>
    implements CopyWith$Input$DeleteDeploymentInput<TRes> {
  _CopyWithImpl$Input$DeleteDeploymentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteDeploymentInput _instance;

  final TRes Function(Input$DeleteDeploymentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteDeploymentInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteDeploymentInput<TRes>
    implements CopyWith$Input$DeleteDeploymentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteDeploymentInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteDiscussionCommentInput {
  factory Input$DeleteDiscussionCommentInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$DeleteDiscussionCommentInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteDiscussionCommentInput._(this._$data);

  factory Input$DeleteDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteDiscussionCommentInput<
          Input$DeleteDiscussionCommentInput>
      get copyWith => CopyWith$Input$DeleteDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteDiscussionCommentInput<TRes> {
  factory CopyWith$Input$DeleteDiscussionCommentInput(
    Input$DeleteDiscussionCommentInput instance,
    TRes Function(Input$DeleteDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$DeleteDiscussionCommentInput;

  factory CopyWith$Input$DeleteDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteDiscussionCommentInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$DeleteDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteDiscussionCommentInput _instance;

  final TRes Function(Input$DeleteDiscussionCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteDiscussionCommentInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteDiscussionInput {
  factory Input$DeleteDiscussionInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$DeleteDiscussionInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteDiscussionInput._(this._$data);

  factory Input$DeleteDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteDiscussionInput<Input$DeleteDiscussionInput>
      get copyWith => CopyWith$Input$DeleteDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteDiscussionInput<TRes> {
  factory CopyWith$Input$DeleteDiscussionInput(
    Input$DeleteDiscussionInput instance,
    TRes Function(Input$DeleteDiscussionInput) then,
  ) = _CopyWithImpl$Input$DeleteDiscussionInput;

  factory CopyWith$Input$DeleteDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteDiscussionInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteDiscussionInput<TRes>
    implements CopyWith$Input$DeleteDiscussionInput<TRes> {
  _CopyWithImpl$Input$DeleteDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$DeleteDiscussionInput _instance;

  final TRes Function(Input$DeleteDiscussionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteDiscussionInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteDiscussionInput<TRes>
    implements CopyWith$Input$DeleteDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$DeleteDiscussionInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteEnvironmentInput {
  factory Input$DeleteEnvironmentInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$DeleteEnvironmentInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteEnvironmentInput._(this._$data);

  factory Input$DeleteEnvironmentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteEnvironmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteEnvironmentInput<Input$DeleteEnvironmentInput>
      get copyWith => CopyWith$Input$DeleteEnvironmentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteEnvironmentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteEnvironmentInput<TRes> {
  factory CopyWith$Input$DeleteEnvironmentInput(
    Input$DeleteEnvironmentInput instance,
    TRes Function(Input$DeleteEnvironmentInput) then,
  ) = _CopyWithImpl$Input$DeleteEnvironmentInput;

  factory CopyWith$Input$DeleteEnvironmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteEnvironmentInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteEnvironmentInput<TRes>
    implements CopyWith$Input$DeleteEnvironmentInput<TRes> {
  _CopyWithImpl$Input$DeleteEnvironmentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteEnvironmentInput _instance;

  final TRes Function(Input$DeleteEnvironmentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteEnvironmentInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteEnvironmentInput<TRes>
    implements CopyWith$Input$DeleteEnvironmentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteEnvironmentInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteIpAllowListEntryInput {
  factory Input$DeleteIpAllowListEntryInput({
    required String ipAllowListEntryId,
    String? clientMutationId,
  }) =>
      Input$DeleteIpAllowListEntryInput._({
        r'ipAllowListEntryId': ipAllowListEntryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteIpAllowListEntryInput._(this._$data);

  factory Input$DeleteIpAllowListEntryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$ipAllowListEntryId = data['ipAllowListEntryId'];
    result$data['ipAllowListEntryId'] = (l$ipAllowListEntryId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteIpAllowListEntryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get ipAllowListEntryId => (_$data['ipAllowListEntryId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ipAllowListEntryId = ipAllowListEntryId;
    result$data['ipAllowListEntryId'] = l$ipAllowListEntryId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteIpAllowListEntryInput<Input$DeleteIpAllowListEntryInput>
      get copyWith => CopyWith$Input$DeleteIpAllowListEntryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteIpAllowListEntryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ipAllowListEntryId = ipAllowListEntryId;
    final lOther$ipAllowListEntryId = other.ipAllowListEntryId;
    if (l$ipAllowListEntryId != lOther$ipAllowListEntryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ipAllowListEntryId = ipAllowListEntryId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$ipAllowListEntryId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteIpAllowListEntryInput<TRes> {
  factory CopyWith$Input$DeleteIpAllowListEntryInput(
    Input$DeleteIpAllowListEntryInput instance,
    TRes Function(Input$DeleteIpAllowListEntryInput) then,
  ) = _CopyWithImpl$Input$DeleteIpAllowListEntryInput;

  factory CopyWith$Input$DeleteIpAllowListEntryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteIpAllowListEntryInput;

  TRes call({
    String? ipAllowListEntryId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteIpAllowListEntryInput<TRes>
    implements CopyWith$Input$DeleteIpAllowListEntryInput<TRes> {
  _CopyWithImpl$Input$DeleteIpAllowListEntryInput(
    this._instance,
    this._then,
  );

  final Input$DeleteIpAllowListEntryInput _instance;

  final TRes Function(Input$DeleteIpAllowListEntryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? ipAllowListEntryId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteIpAllowListEntryInput._({
        ..._instance._$data,
        if (ipAllowListEntryId != _undefined && ipAllowListEntryId != null)
          'ipAllowListEntryId': (ipAllowListEntryId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteIpAllowListEntryInput<TRes>
    implements CopyWith$Input$DeleteIpAllowListEntryInput<TRes> {
  _CopyWithStubImpl$Input$DeleteIpAllowListEntryInput(this._res);

  TRes _res;

  call({
    String? ipAllowListEntryId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteIssueCommentInput {
  factory Input$DeleteIssueCommentInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$DeleteIssueCommentInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteIssueCommentInput._(this._$data);

  factory Input$DeleteIssueCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteIssueCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteIssueCommentInput<Input$DeleteIssueCommentInput>
      get copyWith => CopyWith$Input$DeleteIssueCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteIssueCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteIssueCommentInput<TRes> {
  factory CopyWith$Input$DeleteIssueCommentInput(
    Input$DeleteIssueCommentInput instance,
    TRes Function(Input$DeleteIssueCommentInput) then,
  ) = _CopyWithImpl$Input$DeleteIssueCommentInput;

  factory CopyWith$Input$DeleteIssueCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteIssueCommentInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteIssueCommentInput<TRes>
    implements CopyWith$Input$DeleteIssueCommentInput<TRes> {
  _CopyWithImpl$Input$DeleteIssueCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteIssueCommentInput _instance;

  final TRes Function(Input$DeleteIssueCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteIssueCommentInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteIssueCommentInput<TRes>
    implements CopyWith$Input$DeleteIssueCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteIssueCommentInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteIssueInput {
  factory Input$DeleteIssueInput({
    required String issueId,
    String? clientMutationId,
  }) =>
      Input$DeleteIssueInput._({
        r'issueId': issueId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteIssueInput._(this._$data);

  factory Input$DeleteIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get issueId => (_$data['issueId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteIssueInput<Input$DeleteIssueInput> get copyWith =>
      CopyWith$Input$DeleteIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$issueId = issueId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$issueId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteIssueInput<TRes> {
  factory CopyWith$Input$DeleteIssueInput(
    Input$DeleteIssueInput instance,
    TRes Function(Input$DeleteIssueInput) then,
  ) = _CopyWithImpl$Input$DeleteIssueInput;

  factory CopyWith$Input$DeleteIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteIssueInput;

  TRes call({
    String? issueId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteIssueInput<TRes>
    implements CopyWith$Input$DeleteIssueInput<TRes> {
  _CopyWithImpl$Input$DeleteIssueInput(
    this._instance,
    this._then,
  );

  final Input$DeleteIssueInput _instance;

  final TRes Function(Input$DeleteIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? issueId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteIssueInput._({
        ..._instance._$data,
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteIssueInput<TRes>
    implements CopyWith$Input$DeleteIssueInput<TRes> {
  _CopyWithStubImpl$Input$DeleteIssueInput(this._res);

  TRes _res;

  call({
    String? issueId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteLinkedBranchInput {
  factory Input$DeleteLinkedBranchInput({
    required String linkedBranchId,
    String? clientMutationId,
  }) =>
      Input$DeleteLinkedBranchInput._({
        r'linkedBranchId': linkedBranchId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteLinkedBranchInput._(this._$data);

  factory Input$DeleteLinkedBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$linkedBranchId = data['linkedBranchId'];
    result$data['linkedBranchId'] = (l$linkedBranchId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteLinkedBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get linkedBranchId => (_$data['linkedBranchId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$linkedBranchId = linkedBranchId;
    result$data['linkedBranchId'] = l$linkedBranchId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteLinkedBranchInput<Input$DeleteLinkedBranchInput>
      get copyWith => CopyWith$Input$DeleteLinkedBranchInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteLinkedBranchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$linkedBranchId = linkedBranchId;
    final lOther$linkedBranchId = other.linkedBranchId;
    if (l$linkedBranchId != lOther$linkedBranchId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$linkedBranchId = linkedBranchId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$linkedBranchId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteLinkedBranchInput<TRes> {
  factory CopyWith$Input$DeleteLinkedBranchInput(
    Input$DeleteLinkedBranchInput instance,
    TRes Function(Input$DeleteLinkedBranchInput) then,
  ) = _CopyWithImpl$Input$DeleteLinkedBranchInput;

  factory CopyWith$Input$DeleteLinkedBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteLinkedBranchInput;

  TRes call({
    String? linkedBranchId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteLinkedBranchInput<TRes>
    implements CopyWith$Input$DeleteLinkedBranchInput<TRes> {
  _CopyWithImpl$Input$DeleteLinkedBranchInput(
    this._instance,
    this._then,
  );

  final Input$DeleteLinkedBranchInput _instance;

  final TRes Function(Input$DeleteLinkedBranchInput) _then;

  static const _undefined = {};

  TRes call({
    Object? linkedBranchId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteLinkedBranchInput._({
        ..._instance._$data,
        if (linkedBranchId != _undefined && linkedBranchId != null)
          'linkedBranchId': (linkedBranchId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteLinkedBranchInput<TRes>
    implements CopyWith$Input$DeleteLinkedBranchInput<TRes> {
  _CopyWithStubImpl$Input$DeleteLinkedBranchInput(this._res);

  TRes _res;

  call({
    String? linkedBranchId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteProjectCardInput {
  factory Input$DeleteProjectCardInput({
    required String cardId,
    String? clientMutationId,
  }) =>
      Input$DeleteProjectCardInput._({
        r'cardId': cardId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteProjectCardInput._(this._$data);

  factory Input$DeleteProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$cardId = data['cardId'];
    result$data['cardId'] = (l$cardId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get cardId => (_$data['cardId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$cardId = cardId;
    result$data['cardId'] = l$cardId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteProjectCardInput<Input$DeleteProjectCardInput>
      get copyWith => CopyWith$Input$DeleteProjectCardInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectCardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$cardId = cardId;
    final lOther$cardId = other.cardId;
    if (l$cardId != lOther$cardId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$cardId = cardId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$cardId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectCardInput<TRes> {
  factory CopyWith$Input$DeleteProjectCardInput(
    Input$DeleteProjectCardInput instance,
    TRes Function(Input$DeleteProjectCardInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectCardInput;

  factory CopyWith$Input$DeleteProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectCardInput;

  TRes call({
    String? cardId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteProjectCardInput<TRes>
    implements CopyWith$Input$DeleteProjectCardInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectCardInput _instance;

  final TRes Function(Input$DeleteProjectCardInput) _then;

  static const _undefined = {};

  TRes call({
    Object? cardId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteProjectCardInput._({
        ..._instance._$data,
        if (cardId != _undefined && cardId != null)
          'cardId': (cardId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectCardInput<TRes>
    implements CopyWith$Input$DeleteProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectCardInput(this._res);

  TRes _res;

  call({
    String? cardId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteProjectColumnInput {
  factory Input$DeleteProjectColumnInput({
    required String columnId,
    String? clientMutationId,
  }) =>
      Input$DeleteProjectColumnInput._({
        r'columnId': columnId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteProjectColumnInput._(this._$data);

  factory Input$DeleteProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$columnId = data['columnId'];
    result$data['columnId'] = (l$columnId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get columnId => (_$data['columnId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$columnId = columnId;
    result$data['columnId'] = l$columnId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteProjectColumnInput<Input$DeleteProjectColumnInput>
      get copyWith => CopyWith$Input$DeleteProjectColumnInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectColumnInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$columnId = columnId;
    final lOther$columnId = other.columnId;
    if (l$columnId != lOther$columnId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$columnId = columnId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$columnId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectColumnInput<TRes> {
  factory CopyWith$Input$DeleteProjectColumnInput(
    Input$DeleteProjectColumnInput instance,
    TRes Function(Input$DeleteProjectColumnInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectColumnInput;

  factory CopyWith$Input$DeleteProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectColumnInput;

  TRes call({
    String? columnId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteProjectColumnInput<TRes>
    implements CopyWith$Input$DeleteProjectColumnInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectColumnInput _instance;

  final TRes Function(Input$DeleteProjectColumnInput) _then;

  static const _undefined = {};

  TRes call({
    Object? columnId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteProjectColumnInput._({
        ..._instance._$data,
        if (columnId != _undefined && columnId != null)
          'columnId': (columnId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectColumnInput<TRes>
    implements CopyWith$Input$DeleteProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectColumnInput(this._res);

  TRes _res;

  call({
    String? columnId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteProjectInput {
  factory Input$DeleteProjectInput({
    required String projectId,
    String? clientMutationId,
  }) =>
      Input$DeleteProjectInput._({
        r'projectId': projectId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteProjectInput._(this._$data);

  factory Input$DeleteProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteProjectInput<Input$DeleteProjectInput> get copyWith =>
      CopyWith$Input$DeleteProjectInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectInput<TRes> {
  factory CopyWith$Input$DeleteProjectInput(
    Input$DeleteProjectInput instance,
    TRes Function(Input$DeleteProjectInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectInput;

  factory CopyWith$Input$DeleteProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectInput;

  TRes call({
    String? projectId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteProjectInput<TRes>
    implements CopyWith$Input$DeleteProjectInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectInput _instance;

  final TRes Function(Input$DeleteProjectInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteProjectInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectInput<TRes>
    implements CopyWith$Input$DeleteProjectInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteProjectNextItemInput {
  factory Input$DeleteProjectNextItemInput({
    String? projectId,
    String? itemId,
    String? clientMutationId,
  }) =>
      Input$DeleteProjectNextItemInput._({
        if (projectId != null) r'projectId': projectId,
        if (itemId != null) r'itemId': itemId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteProjectNextItemInput._(this._$data);

  factory Input$DeleteProjectNextItemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('projectId')) {
      final l$projectId = data['projectId'];
      result$data['projectId'] = (l$projectId as String?);
    }
    if (data.containsKey('itemId')) {
      final l$itemId = data['itemId'];
      result$data['itemId'] = (l$itemId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteProjectNextItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get projectId => (_$data['projectId'] as String?);
  String? get itemId => (_$data['itemId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('projectId')) {
      final l$projectId = projectId;
      result$data['projectId'] = l$projectId;
    }
    if (_$data.containsKey('itemId')) {
      final l$itemId = itemId;
      result$data['itemId'] = l$itemId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteProjectNextItemInput<Input$DeleteProjectNextItemInput>
      get copyWith => CopyWith$Input$DeleteProjectNextItemInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectNextItemInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (_$data.containsKey('projectId') !=
        other._$data.containsKey('projectId')) {
      return false;
    }
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (_$data.containsKey('itemId') != other._$data.containsKey('itemId')) {
      return false;
    }
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$itemId = itemId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('projectId') ? l$projectId : const {},
      _$data.containsKey('itemId') ? l$itemId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectNextItemInput<TRes> {
  factory CopyWith$Input$DeleteProjectNextItemInput(
    Input$DeleteProjectNextItemInput instance,
    TRes Function(Input$DeleteProjectNextItemInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectNextItemInput;

  factory CopyWith$Input$DeleteProjectNextItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectNextItemInput;

  TRes call({
    String? projectId,
    String? itemId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteProjectNextItemInput<TRes>
    implements CopyWith$Input$DeleteProjectNextItemInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectNextItemInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectNextItemInput _instance;

  final TRes Function(Input$DeleteProjectNextItemInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? itemId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteProjectNextItemInput._({
        ..._instance._$data,
        if (projectId != _undefined) 'projectId': (projectId as String?),
        if (itemId != _undefined) 'itemId': (itemId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectNextItemInput<TRes>
    implements CopyWith$Input$DeleteProjectNextItemInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectNextItemInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? itemId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteProjectV2ItemInput {
  factory Input$DeleteProjectV2ItemInput({
    required String projectId,
    required String itemId,
    String? clientMutationId,
  }) =>
      Input$DeleteProjectV2ItemInput._({
        r'projectId': projectId,
        r'itemId': itemId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteProjectV2ItemInput._(this._$data);

  factory Input$DeleteProjectV2ItemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteProjectV2ItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get itemId => (_$data['itemId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteProjectV2ItemInput<Input$DeleteProjectV2ItemInput>
      get copyWith => CopyWith$Input$DeleteProjectV2ItemInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectV2ItemInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$itemId = itemId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$itemId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectV2ItemInput<TRes> {
  factory CopyWith$Input$DeleteProjectV2ItemInput(
    Input$DeleteProjectV2ItemInput instance,
    TRes Function(Input$DeleteProjectV2ItemInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectV2ItemInput;

  factory CopyWith$Input$DeleteProjectV2ItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectV2ItemInput;

  TRes call({
    String? projectId,
    String? itemId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteProjectV2ItemInput<TRes>
    implements CopyWith$Input$DeleteProjectV2ItemInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectV2ItemInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectV2ItemInput _instance;

  final TRes Function(Input$DeleteProjectV2ItemInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? itemId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteProjectV2ItemInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectV2ItemInput<TRes>
    implements CopyWith$Input$DeleteProjectV2ItemInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectV2ItemInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? itemId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeletePullRequestReviewCommentInput {
  factory Input$DeletePullRequestReviewCommentInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$DeletePullRequestReviewCommentInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeletePullRequestReviewCommentInput._(this._$data);

  factory Input$DeletePullRequestReviewCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeletePullRequestReviewCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeletePullRequestReviewCommentInput<
          Input$DeletePullRequestReviewCommentInput>
      get copyWith => CopyWith$Input$DeletePullRequestReviewCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeletePullRequestReviewCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeletePullRequestReviewCommentInput<TRes> {
  factory CopyWith$Input$DeletePullRequestReviewCommentInput(
    Input$DeletePullRequestReviewCommentInput instance,
    TRes Function(Input$DeletePullRequestReviewCommentInput) then,
  ) = _CopyWithImpl$Input$DeletePullRequestReviewCommentInput;

  factory CopyWith$Input$DeletePullRequestReviewCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeletePullRequestReviewCommentInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeletePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewCommentInput<TRes> {
  _CopyWithImpl$Input$DeletePullRequestReviewCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeletePullRequestReviewCommentInput _instance;

  final TRes Function(Input$DeletePullRequestReviewCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeletePullRequestReviewCommentInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeletePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeletePullRequestReviewCommentInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeletePullRequestReviewInput {
  factory Input$DeletePullRequestReviewInput({
    required String pullRequestReviewId,
    String? clientMutationId,
  }) =>
      Input$DeletePullRequestReviewInput._({
        r'pullRequestReviewId': pullRequestReviewId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeletePullRequestReviewInput._(this._$data);

  factory Input$DeletePullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestReviewId = data['pullRequestReviewId'];
    result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeletePullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestReviewId => (_$data['pullRequestReviewId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestReviewId = pullRequestReviewId;
    result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeletePullRequestReviewInput<
          Input$DeletePullRequestReviewInput>
      get copyWith => CopyWith$Input$DeletePullRequestReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeletePullRequestReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestReviewId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeletePullRequestReviewInput<TRes> {
  factory CopyWith$Input$DeletePullRequestReviewInput(
    Input$DeletePullRequestReviewInput instance,
    TRes Function(Input$DeletePullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$DeletePullRequestReviewInput;

  factory CopyWith$Input$DeletePullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeletePullRequestReviewInput;

  TRes call({
    String? pullRequestReviewId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeletePullRequestReviewInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$DeletePullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$DeletePullRequestReviewInput _instance;

  final TRes Function(Input$DeletePullRequestReviewInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestReviewId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeletePullRequestReviewInput._({
        ..._instance._$data,
        if (pullRequestReviewId != _undefined && pullRequestReviewId != null)
          'pullRequestReviewId': (pullRequestReviewId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeletePullRequestReviewInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$DeletePullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? pullRequestReviewId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteRefInput {
  factory Input$DeleteRefInput({
    required String refId,
    String? clientMutationId,
  }) =>
      Input$DeleteRefInput._({
        r'refId': refId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteRefInput._(this._$data);

  factory Input$DeleteRefInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$refId = data['refId'];
    result$data['refId'] = (l$refId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteRefInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get refId => (_$data['refId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$refId = refId;
    result$data['refId'] = l$refId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteRefInput<Input$DeleteRefInput> get copyWith =>
      CopyWith$Input$DeleteRefInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteRefInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$refId = refId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$refId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteRefInput<TRes> {
  factory CopyWith$Input$DeleteRefInput(
    Input$DeleteRefInput instance,
    TRes Function(Input$DeleteRefInput) then,
  ) = _CopyWithImpl$Input$DeleteRefInput;

  factory CopyWith$Input$DeleteRefInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteRefInput;

  TRes call({
    String? refId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteRefInput<TRes>
    implements CopyWith$Input$DeleteRefInput<TRes> {
  _CopyWithImpl$Input$DeleteRefInput(
    this._instance,
    this._then,
  );

  final Input$DeleteRefInput _instance;

  final TRes Function(Input$DeleteRefInput) _then;

  static const _undefined = {};

  TRes call({
    Object? refId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteRefInput._({
        ..._instance._$data,
        if (refId != _undefined && refId != null) 'refId': (refId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteRefInput<TRes>
    implements CopyWith$Input$DeleteRefInput<TRes> {
  _CopyWithStubImpl$Input$DeleteRefInput(this._res);

  TRes _res;

  call({
    String? refId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteTeamDiscussionCommentInput {
  factory Input$DeleteTeamDiscussionCommentInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$DeleteTeamDiscussionCommentInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteTeamDiscussionCommentInput._(this._$data);

  factory Input$DeleteTeamDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteTeamDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteTeamDiscussionCommentInput<
          Input$DeleteTeamDiscussionCommentInput>
      get copyWith => CopyWith$Input$DeleteTeamDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteTeamDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteTeamDiscussionCommentInput<TRes> {
  factory CopyWith$Input$DeleteTeamDiscussionCommentInput(
    Input$DeleteTeamDiscussionCommentInput instance,
    TRes Function(Input$DeleteTeamDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$DeleteTeamDiscussionCommentInput;

  factory CopyWith$Input$DeleteTeamDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteTeamDiscussionCommentInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$DeleteTeamDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteTeamDiscussionCommentInput _instance;

  final TRes Function(Input$DeleteTeamDiscussionCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteTeamDiscussionCommentInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteTeamDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteTeamDiscussionInput {
  factory Input$DeleteTeamDiscussionInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$DeleteTeamDiscussionInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteTeamDiscussionInput._(this._$data);

  factory Input$DeleteTeamDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteTeamDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteTeamDiscussionInput<Input$DeleteTeamDiscussionInput>
      get copyWith => CopyWith$Input$DeleteTeamDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteTeamDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteTeamDiscussionInput<TRes> {
  factory CopyWith$Input$DeleteTeamDiscussionInput(
    Input$DeleteTeamDiscussionInput instance,
    TRes Function(Input$DeleteTeamDiscussionInput) then,
  ) = _CopyWithImpl$Input$DeleteTeamDiscussionInput;

  factory CopyWith$Input$DeleteTeamDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteTeamDiscussionInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteTeamDiscussionInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionInput<TRes> {
  _CopyWithImpl$Input$DeleteTeamDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$DeleteTeamDiscussionInput _instance;

  final TRes Function(Input$DeleteTeamDiscussionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteTeamDiscussionInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteTeamDiscussionInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$DeleteTeamDiscussionInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteVerifiableDomainInput {
  factory Input$DeleteVerifiableDomainInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$DeleteVerifiableDomainInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteVerifiableDomainInput._(this._$data);

  factory Input$DeleteVerifiableDomainInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteVerifiableDomainInput<Input$DeleteVerifiableDomainInput>
      get copyWith => CopyWith$Input$DeleteVerifiableDomainInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteVerifiableDomainInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteVerifiableDomainInput<TRes> {
  factory CopyWith$Input$DeleteVerifiableDomainInput(
    Input$DeleteVerifiableDomainInput instance,
    TRes Function(Input$DeleteVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$DeleteVerifiableDomainInput;

  factory CopyWith$Input$DeleteVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteVerifiableDomainInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteVerifiableDomainInput<TRes>
    implements CopyWith$Input$DeleteVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$DeleteVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$DeleteVerifiableDomainInput _instance;

  final TRes Function(Input$DeleteVerifiableDomainInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteVerifiableDomainInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteVerifiableDomainInput<TRes>
    implements CopyWith$Input$DeleteVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$DeleteVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeploymentOrder {
  factory Input$DeploymentOrder({
    required Enum$DeploymentOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$DeploymentOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$DeploymentOrder._(this._$data);

  factory Input$DeploymentOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$DeploymentOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$DeploymentOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$DeploymentOrderField get field =>
      (_$data['field'] as Enum$DeploymentOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$DeploymentOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$DeploymentOrder<Input$DeploymentOrder> get copyWith =>
      CopyWith$Input$DeploymentOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeploymentOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$DeploymentOrder<TRes> {
  factory CopyWith$Input$DeploymentOrder(
    Input$DeploymentOrder instance,
    TRes Function(Input$DeploymentOrder) then,
  ) = _CopyWithImpl$Input$DeploymentOrder;

  factory CopyWith$Input$DeploymentOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$DeploymentOrder;

  TRes call({
    Enum$DeploymentOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$DeploymentOrder<TRes>
    implements CopyWith$Input$DeploymentOrder<TRes> {
  _CopyWithImpl$Input$DeploymentOrder(
    this._instance,
    this._then,
  );

  final Input$DeploymentOrder _instance;

  final TRes Function(Input$DeploymentOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$DeploymentOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$DeploymentOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$DeploymentOrder<TRes>
    implements CopyWith$Input$DeploymentOrder<TRes> {
  _CopyWithStubImpl$Input$DeploymentOrder(this._res);

  TRes _res;

  call({
    Enum$DeploymentOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$DisablePullRequestAutoMergeInput {
  factory Input$DisablePullRequestAutoMergeInput({
    required String pullRequestId,
    String? clientMutationId,
  }) =>
      Input$DisablePullRequestAutoMergeInput._({
        r'pullRequestId': pullRequestId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DisablePullRequestAutoMergeInput._(this._$data);

  factory Input$DisablePullRequestAutoMergeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DisablePullRequestAutoMergeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DisablePullRequestAutoMergeInput<
          Input$DisablePullRequestAutoMergeInput>
      get copyWith => CopyWith$Input$DisablePullRequestAutoMergeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DisablePullRequestAutoMergeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DisablePullRequestAutoMergeInput<TRes> {
  factory CopyWith$Input$DisablePullRequestAutoMergeInput(
    Input$DisablePullRequestAutoMergeInput instance,
    TRes Function(Input$DisablePullRequestAutoMergeInput) then,
  ) = _CopyWithImpl$Input$DisablePullRequestAutoMergeInput;

  factory CopyWith$Input$DisablePullRequestAutoMergeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DisablePullRequestAutoMergeInput;

  TRes call({
    String? pullRequestId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DisablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$DisablePullRequestAutoMergeInput<TRes> {
  _CopyWithImpl$Input$DisablePullRequestAutoMergeInput(
    this._instance,
    this._then,
  );

  final Input$DisablePullRequestAutoMergeInput _instance;

  final TRes Function(Input$DisablePullRequestAutoMergeInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DisablePullRequestAutoMergeInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DisablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$DisablePullRequestAutoMergeInput<TRes> {
  _CopyWithStubImpl$Input$DisablePullRequestAutoMergeInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DiscussionOrder {
  factory Input$DiscussionOrder({
    required Enum$DiscussionOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$DiscussionOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$DiscussionOrder._(this._$data);

  factory Input$DiscussionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$DiscussionOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$DiscussionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$DiscussionOrderField get field =>
      (_$data['field'] as Enum$DiscussionOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$DiscussionOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$DiscussionOrder<Input$DiscussionOrder> get copyWith =>
      CopyWith$Input$DiscussionOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DiscussionOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$DiscussionOrder<TRes> {
  factory CopyWith$Input$DiscussionOrder(
    Input$DiscussionOrder instance,
    TRes Function(Input$DiscussionOrder) then,
  ) = _CopyWithImpl$Input$DiscussionOrder;

  factory CopyWith$Input$DiscussionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$DiscussionOrder;

  TRes call({
    Enum$DiscussionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$DiscussionOrder<TRes>
    implements CopyWith$Input$DiscussionOrder<TRes> {
  _CopyWithImpl$Input$DiscussionOrder(
    this._instance,
    this._then,
  );

  final Input$DiscussionOrder _instance;

  final TRes Function(Input$DiscussionOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$DiscussionOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$DiscussionOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$DiscussionOrder<TRes>
    implements CopyWith$Input$DiscussionOrder<TRes> {
  _CopyWithStubImpl$Input$DiscussionOrder(this._res);

  TRes _res;

  call({
    Enum$DiscussionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$DiscussionPollOptionOrder {
  factory Input$DiscussionPollOptionOrder({
    required Enum$DiscussionPollOptionOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$DiscussionPollOptionOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$DiscussionPollOptionOrder._(this._$data);

  factory Input$DiscussionPollOptionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$DiscussionPollOptionOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$DiscussionPollOptionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$DiscussionPollOptionOrderField get field =>
      (_$data['field'] as Enum$DiscussionPollOptionOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$DiscussionPollOptionOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$DiscussionPollOptionOrder<Input$DiscussionPollOptionOrder>
      get copyWith => CopyWith$Input$DiscussionPollOptionOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DiscussionPollOptionOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$DiscussionPollOptionOrder<TRes> {
  factory CopyWith$Input$DiscussionPollOptionOrder(
    Input$DiscussionPollOptionOrder instance,
    TRes Function(Input$DiscussionPollOptionOrder) then,
  ) = _CopyWithImpl$Input$DiscussionPollOptionOrder;

  factory CopyWith$Input$DiscussionPollOptionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$DiscussionPollOptionOrder;

  TRes call({
    Enum$DiscussionPollOptionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$DiscussionPollOptionOrder<TRes>
    implements CopyWith$Input$DiscussionPollOptionOrder<TRes> {
  _CopyWithImpl$Input$DiscussionPollOptionOrder(
    this._instance,
    this._then,
  );

  final Input$DiscussionPollOptionOrder _instance;

  final TRes Function(Input$DiscussionPollOptionOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$DiscussionPollOptionOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$DiscussionPollOptionOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$DiscussionPollOptionOrder<TRes>
    implements CopyWith$Input$DiscussionPollOptionOrder<TRes> {
  _CopyWithStubImpl$Input$DiscussionPollOptionOrder(this._res);

  TRes _res;

  call({
    Enum$DiscussionPollOptionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$DismissPullRequestReviewInput {
  factory Input$DismissPullRequestReviewInput({
    required String pullRequestReviewId,
    required String message,
    String? clientMutationId,
  }) =>
      Input$DismissPullRequestReviewInput._({
        r'pullRequestReviewId': pullRequestReviewId,
        r'message': message,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DismissPullRequestReviewInput._(this._$data);

  factory Input$DismissPullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestReviewId = data['pullRequestReviewId'];
    result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String);
    final l$message = data['message'];
    result$data['message'] = (l$message as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DismissPullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestReviewId => (_$data['pullRequestReviewId'] as String);
  String get message => (_$data['message'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestReviewId = pullRequestReviewId;
    result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    final l$message = message;
    result$data['message'] = l$message;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DismissPullRequestReviewInput<
          Input$DismissPullRequestReviewInput>
      get copyWith => CopyWith$Input$DismissPullRequestReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DismissPullRequestReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$message = message;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestReviewId,
      l$message,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DismissPullRequestReviewInput<TRes> {
  factory CopyWith$Input$DismissPullRequestReviewInput(
    Input$DismissPullRequestReviewInput instance,
    TRes Function(Input$DismissPullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$DismissPullRequestReviewInput;

  factory CopyWith$Input$DismissPullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DismissPullRequestReviewInput;

  TRes call({
    String? pullRequestReviewId,
    String? message,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DismissPullRequestReviewInput<TRes>
    implements CopyWith$Input$DismissPullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$DismissPullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$DismissPullRequestReviewInput _instance;

  final TRes Function(Input$DismissPullRequestReviewInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestReviewId = _undefined,
    Object? message = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DismissPullRequestReviewInput._({
        ..._instance._$data,
        if (pullRequestReviewId != _undefined && pullRequestReviewId != null)
          'pullRequestReviewId': (pullRequestReviewId as String),
        if (message != _undefined && message != null)
          'message': (message as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DismissPullRequestReviewInput<TRes>
    implements CopyWith$Input$DismissPullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$DismissPullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? pullRequestReviewId,
    String? message,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DismissRepositoryVulnerabilityAlertInput {
  factory Input$DismissRepositoryVulnerabilityAlertInput({
    required String repositoryVulnerabilityAlertId,
    required Enum$DismissReason dismissReason,
    String? clientMutationId,
  }) =>
      Input$DismissRepositoryVulnerabilityAlertInput._({
        r'repositoryVulnerabilityAlertId': repositoryVulnerabilityAlertId,
        r'dismissReason': dismissReason,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DismissRepositoryVulnerabilityAlertInput._(this._$data);

  factory Input$DismissRepositoryVulnerabilityAlertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryVulnerabilityAlertId =
        data['repositoryVulnerabilityAlertId'];
    result$data['repositoryVulnerabilityAlertId'] =
        (l$repositoryVulnerabilityAlertId as String);
    final l$dismissReason = data['dismissReason'];
    result$data['dismissReason'] =
        fromJson$Enum$DismissReason((l$dismissReason as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DismissRepositoryVulnerabilityAlertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryVulnerabilityAlertId =>
      (_$data['repositoryVulnerabilityAlertId'] as String);
  Enum$DismissReason get dismissReason =>
      (_$data['dismissReason'] as Enum$DismissReason);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryVulnerabilityAlertId = repositoryVulnerabilityAlertId;
    result$data['repositoryVulnerabilityAlertId'] =
        l$repositoryVulnerabilityAlertId;
    final l$dismissReason = dismissReason;
    result$data['dismissReason'] = toJson$Enum$DismissReason(l$dismissReason);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<
          Input$DismissRepositoryVulnerabilityAlertInput>
      get copyWith => CopyWith$Input$DismissRepositoryVulnerabilityAlertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DismissRepositoryVulnerabilityAlertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryVulnerabilityAlertId = repositoryVulnerabilityAlertId;
    final lOther$repositoryVulnerabilityAlertId =
        other.repositoryVulnerabilityAlertId;
    if (l$repositoryVulnerabilityAlertId !=
        lOther$repositoryVulnerabilityAlertId) {
      return false;
    }
    final l$dismissReason = dismissReason;
    final lOther$dismissReason = other.dismissReason;
    if (l$dismissReason != lOther$dismissReason) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryVulnerabilityAlertId = repositoryVulnerabilityAlertId;
    final l$dismissReason = dismissReason;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryVulnerabilityAlertId,
      l$dismissReason,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<TRes> {
  factory CopyWith$Input$DismissRepositoryVulnerabilityAlertInput(
    Input$DismissRepositoryVulnerabilityAlertInput instance,
    TRes Function(Input$DismissRepositoryVulnerabilityAlertInput) then,
  ) = _CopyWithImpl$Input$DismissRepositoryVulnerabilityAlertInput;

  factory CopyWith$Input$DismissRepositoryVulnerabilityAlertInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$DismissRepositoryVulnerabilityAlertInput;

  TRes call({
    String? repositoryVulnerabilityAlertId,
    Enum$DismissReason? dismissReason,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DismissRepositoryVulnerabilityAlertInput<TRes>
    implements CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<TRes> {
  _CopyWithImpl$Input$DismissRepositoryVulnerabilityAlertInput(
    this._instance,
    this._then,
  );

  final Input$DismissRepositoryVulnerabilityAlertInput _instance;

  final TRes Function(Input$DismissRepositoryVulnerabilityAlertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryVulnerabilityAlertId = _undefined,
    Object? dismissReason = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DismissRepositoryVulnerabilityAlertInput._({
        ..._instance._$data,
        if (repositoryVulnerabilityAlertId != _undefined &&
            repositoryVulnerabilityAlertId != null)
          'repositoryVulnerabilityAlertId':
              (repositoryVulnerabilityAlertId as String),
        if (dismissReason != _undefined && dismissReason != null)
          'dismissReason': (dismissReason as Enum$DismissReason),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DismissRepositoryVulnerabilityAlertInput<TRes>
    implements CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<TRes> {
  _CopyWithStubImpl$Input$DismissRepositoryVulnerabilityAlertInput(this._res);

  TRes _res;

  call({
    String? repositoryVulnerabilityAlertId,
    Enum$DismissReason? dismissReason,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DraftPullRequestReviewComment {
  factory Input$DraftPullRequestReviewComment({
    required String path,
    required int position,
    required String body,
  }) =>
      Input$DraftPullRequestReviewComment._({
        r'path': path,
        r'position': position,
        r'body': body,
      });

  Input$DraftPullRequestReviewComment._(this._$data);

  factory Input$DraftPullRequestReviewComment.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    final l$position = data['position'];
    result$data['position'] = (l$position as int);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    return Input$DraftPullRequestReviewComment._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  int get position => (_$data['position'] as int);
  String get body => (_$data['body'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    final l$position = position;
    result$data['position'] = l$position;
    final l$body = body;
    result$data['body'] = l$body;
    return result$data;
  }

  CopyWith$Input$DraftPullRequestReviewComment<
          Input$DraftPullRequestReviewComment>
      get copyWith => CopyWith$Input$DraftPullRequestReviewComment(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DraftPullRequestReviewComment) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$position = position;
    final l$body = body;
    return Object.hashAll([
      l$path,
      l$position,
      l$body,
    ]);
  }
}

abstract class CopyWith$Input$DraftPullRequestReviewComment<TRes> {
  factory CopyWith$Input$DraftPullRequestReviewComment(
    Input$DraftPullRequestReviewComment instance,
    TRes Function(Input$DraftPullRequestReviewComment) then,
  ) = _CopyWithImpl$Input$DraftPullRequestReviewComment;

  factory CopyWith$Input$DraftPullRequestReviewComment.stub(TRes res) =
      _CopyWithStubImpl$Input$DraftPullRequestReviewComment;

  TRes call({
    String? path,
    int? position,
    String? body,
  });
}

class _CopyWithImpl$Input$DraftPullRequestReviewComment<TRes>
    implements CopyWith$Input$DraftPullRequestReviewComment<TRes> {
  _CopyWithImpl$Input$DraftPullRequestReviewComment(
    this._instance,
    this._then,
  );

  final Input$DraftPullRequestReviewComment _instance;

  final TRes Function(Input$DraftPullRequestReviewComment) _then;

  static const _undefined = {};

  TRes call({
    Object? path = _undefined,
    Object? position = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$DraftPullRequestReviewComment._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (position != _undefined && position != null)
          'position': (position as int),
        if (body != _undefined && body != null) 'body': (body as String),
      }));
}

class _CopyWithStubImpl$Input$DraftPullRequestReviewComment<TRes>
    implements CopyWith$Input$DraftPullRequestReviewComment<TRes> {
  _CopyWithStubImpl$Input$DraftPullRequestReviewComment(this._res);

  TRes _res;

  call({
    String? path,
    int? position,
    String? body,
  }) =>
      _res;
}

class Input$DraftPullRequestReviewThread {
  factory Input$DraftPullRequestReviewThread({
    required String path,
    required int line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    required String body,
  }) =>
      Input$DraftPullRequestReviewThread._({
        r'path': path,
        r'line': line,
        if (side != null) r'side': side,
        if (startLine != null) r'startLine': startLine,
        if (startSide != null) r'startSide': startSide,
        r'body': body,
      });

  Input$DraftPullRequestReviewThread._(this._$data);

  factory Input$DraftPullRequestReviewThread.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    final l$line = data['line'];
    result$data['line'] = (l$line as int);
    if (data.containsKey('side')) {
      final l$side = data['side'];
      result$data['side'] =
          l$side == null ? null : fromJson$Enum$DiffSide((l$side as String));
    }
    if (data.containsKey('startLine')) {
      final l$startLine = data['startLine'];
      result$data['startLine'] = (l$startLine as int?);
    }
    if (data.containsKey('startSide')) {
      final l$startSide = data['startSide'];
      result$data['startSide'] = l$startSide == null
          ? null
          : fromJson$Enum$DiffSide((l$startSide as String));
    }
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    return Input$DraftPullRequestReviewThread._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  int get line => (_$data['line'] as int);
  Enum$DiffSide? get side => (_$data['side'] as Enum$DiffSide?);
  int? get startLine => (_$data['startLine'] as int?);
  Enum$DiffSide? get startSide => (_$data['startSide'] as Enum$DiffSide?);
  String get body => (_$data['body'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    final l$line = line;
    result$data['line'] = l$line;
    if (_$data.containsKey('side')) {
      final l$side = side;
      result$data['side'] =
          l$side == null ? null : toJson$Enum$DiffSide(l$side);
    }
    if (_$data.containsKey('startLine')) {
      final l$startLine = startLine;
      result$data['startLine'] = l$startLine;
    }
    if (_$data.containsKey('startSide')) {
      final l$startSide = startSide;
      result$data['startSide'] =
          l$startSide == null ? null : toJson$Enum$DiffSide(l$startSide);
    }
    final l$body = body;
    result$data['body'] = l$body;
    return result$data;
  }

  CopyWith$Input$DraftPullRequestReviewThread<
          Input$DraftPullRequestReviewThread>
      get copyWith => CopyWith$Input$DraftPullRequestReviewThread(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DraftPullRequestReviewThread) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$line = line;
    final lOther$line = other.line;
    if (l$line != lOther$line) {
      return false;
    }
    final l$side = side;
    final lOther$side = other.side;
    if (_$data.containsKey('side') != other._$data.containsKey('side')) {
      return false;
    }
    if (l$side != lOther$side) {
      return false;
    }
    final l$startLine = startLine;
    final lOther$startLine = other.startLine;
    if (_$data.containsKey('startLine') !=
        other._$data.containsKey('startLine')) {
      return false;
    }
    if (l$startLine != lOther$startLine) {
      return false;
    }
    final l$startSide = startSide;
    final lOther$startSide = other.startSide;
    if (_$data.containsKey('startSide') !=
        other._$data.containsKey('startSide')) {
      return false;
    }
    if (l$startSide != lOther$startSide) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$line = line;
    final l$side = side;
    final l$startLine = startLine;
    final l$startSide = startSide;
    final l$body = body;
    return Object.hashAll([
      l$path,
      l$line,
      _$data.containsKey('side') ? l$side : const {},
      _$data.containsKey('startLine') ? l$startLine : const {},
      _$data.containsKey('startSide') ? l$startSide : const {},
      l$body,
    ]);
  }
}

abstract class CopyWith$Input$DraftPullRequestReviewThread<TRes> {
  factory CopyWith$Input$DraftPullRequestReviewThread(
    Input$DraftPullRequestReviewThread instance,
    TRes Function(Input$DraftPullRequestReviewThread) then,
  ) = _CopyWithImpl$Input$DraftPullRequestReviewThread;

  factory CopyWith$Input$DraftPullRequestReviewThread.stub(TRes res) =
      _CopyWithStubImpl$Input$DraftPullRequestReviewThread;

  TRes call({
    String? path,
    int? line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    String? body,
  });
}

class _CopyWithImpl$Input$DraftPullRequestReviewThread<TRes>
    implements CopyWith$Input$DraftPullRequestReviewThread<TRes> {
  _CopyWithImpl$Input$DraftPullRequestReviewThread(
    this._instance,
    this._then,
  );

  final Input$DraftPullRequestReviewThread _instance;

  final TRes Function(Input$DraftPullRequestReviewThread) _then;

  static const _undefined = {};

  TRes call({
    Object? path = _undefined,
    Object? line = _undefined,
    Object? side = _undefined,
    Object? startLine = _undefined,
    Object? startSide = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$DraftPullRequestReviewThread._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (line != _undefined && line != null) 'line': (line as int),
        if (side != _undefined) 'side': (side as Enum$DiffSide?),
        if (startLine != _undefined) 'startLine': (startLine as int?),
        if (startSide != _undefined) 'startSide': (startSide as Enum$DiffSide?),
        if (body != _undefined && body != null) 'body': (body as String),
      }));
}

class _CopyWithStubImpl$Input$DraftPullRequestReviewThread<TRes>
    implements CopyWith$Input$DraftPullRequestReviewThread<TRes> {
  _CopyWithStubImpl$Input$DraftPullRequestReviewThread(this._res);

  TRes _res;

  call({
    String? path,
    int? line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    String? body,
  }) =>
      _res;
}

class Input$EnablePullRequestAutoMergeInput {
  factory Input$EnablePullRequestAutoMergeInput({
    required String pullRequestId,
    String? commitHeadline,
    String? commitBody,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
    String? clientMutationId,
  }) =>
      Input$EnablePullRequestAutoMergeInput._({
        r'pullRequestId': pullRequestId,
        if (commitHeadline != null) r'commitHeadline': commitHeadline,
        if (commitBody != null) r'commitBody': commitBody,
        if (mergeMethod != null) r'mergeMethod': mergeMethod,
        if (authorEmail != null) r'authorEmail': authorEmail,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$EnablePullRequestAutoMergeInput._(this._$data);

  factory Input$EnablePullRequestAutoMergeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('commitHeadline')) {
      final l$commitHeadline = data['commitHeadline'];
      result$data['commitHeadline'] = (l$commitHeadline as String?);
    }
    if (data.containsKey('commitBody')) {
      final l$commitBody = data['commitBody'];
      result$data['commitBody'] = (l$commitBody as String?);
    }
    if (data.containsKey('mergeMethod')) {
      final l$mergeMethod = data['mergeMethod'];
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : fromJson$Enum$PullRequestMergeMethod((l$mergeMethod as String));
    }
    if (data.containsKey('authorEmail')) {
      final l$authorEmail = data['authorEmail'];
      result$data['authorEmail'] = (l$authorEmail as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$EnablePullRequestAutoMergeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String? get commitHeadline => (_$data['commitHeadline'] as String?);
  String? get commitBody => (_$data['commitBody'] as String?);
  Enum$PullRequestMergeMethod? get mergeMethod =>
      (_$data['mergeMethod'] as Enum$PullRequestMergeMethod?);
  String? get authorEmail => (_$data['authorEmail'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('commitHeadline')) {
      final l$commitHeadline = commitHeadline;
      result$data['commitHeadline'] = l$commitHeadline;
    }
    if (_$data.containsKey('commitBody')) {
      final l$commitBody = commitBody;
      result$data['commitBody'] = l$commitBody;
    }
    if (_$data.containsKey('mergeMethod')) {
      final l$mergeMethod = mergeMethod;
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : toJson$Enum$PullRequestMergeMethod(l$mergeMethod);
    }
    if (_$data.containsKey('authorEmail')) {
      final l$authorEmail = authorEmail;
      result$data['authorEmail'] = l$authorEmail;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$EnablePullRequestAutoMergeInput<
          Input$EnablePullRequestAutoMergeInput>
      get copyWith => CopyWith$Input$EnablePullRequestAutoMergeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnablePullRequestAutoMergeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$commitHeadline = commitHeadline;
    final lOther$commitHeadline = other.commitHeadline;
    if (_$data.containsKey('commitHeadline') !=
        other._$data.containsKey('commitHeadline')) {
      return false;
    }
    if (l$commitHeadline != lOther$commitHeadline) {
      return false;
    }
    final l$commitBody = commitBody;
    final lOther$commitBody = other.commitBody;
    if (_$data.containsKey('commitBody') !=
        other._$data.containsKey('commitBody')) {
      return false;
    }
    if (l$commitBody != lOther$commitBody) {
      return false;
    }
    final l$mergeMethod = mergeMethod;
    final lOther$mergeMethod = other.mergeMethod;
    if (_$data.containsKey('mergeMethod') !=
        other._$data.containsKey('mergeMethod')) {
      return false;
    }
    if (l$mergeMethod != lOther$mergeMethod) {
      return false;
    }
    final l$authorEmail = authorEmail;
    final lOther$authorEmail = other.authorEmail;
    if (_$data.containsKey('authorEmail') !=
        other._$data.containsKey('authorEmail')) {
      return false;
    }
    if (l$authorEmail != lOther$authorEmail) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$commitHeadline = commitHeadline;
    final l$commitBody = commitBody;
    final l$mergeMethod = mergeMethod;
    final l$authorEmail = authorEmail;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      _$data.containsKey('commitHeadline') ? l$commitHeadline : const {},
      _$data.containsKey('commitBody') ? l$commitBody : const {},
      _$data.containsKey('mergeMethod') ? l$mergeMethod : const {},
      _$data.containsKey('authorEmail') ? l$authorEmail : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnablePullRequestAutoMergeInput<TRes> {
  factory CopyWith$Input$EnablePullRequestAutoMergeInput(
    Input$EnablePullRequestAutoMergeInput instance,
    TRes Function(Input$EnablePullRequestAutoMergeInput) then,
  ) = _CopyWithImpl$Input$EnablePullRequestAutoMergeInput;

  factory CopyWith$Input$EnablePullRequestAutoMergeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnablePullRequestAutoMergeInput;

  TRes call({
    String? pullRequestId,
    String? commitHeadline,
    String? commitBody,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$EnablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$EnablePullRequestAutoMergeInput<TRes> {
  _CopyWithImpl$Input$EnablePullRequestAutoMergeInput(
    this._instance,
    this._then,
  );

  final Input$EnablePullRequestAutoMergeInput _instance;

  final TRes Function(Input$EnablePullRequestAutoMergeInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? commitHeadline = _undefined,
    Object? commitBody = _undefined,
    Object? mergeMethod = _undefined,
    Object? authorEmail = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$EnablePullRequestAutoMergeInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (commitHeadline != _undefined)
          'commitHeadline': (commitHeadline as String?),
        if (commitBody != _undefined) 'commitBody': (commitBody as String?),
        if (mergeMethod != _undefined)
          'mergeMethod': (mergeMethod as Enum$PullRequestMergeMethod?),
        if (authorEmail != _undefined) 'authorEmail': (authorEmail as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$EnablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$EnablePullRequestAutoMergeInput<TRes> {
  _CopyWithStubImpl$Input$EnablePullRequestAutoMergeInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? commitHeadline,
    String? commitBody,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$EnterpriseAdministratorInvitationOrder {
  factory Input$EnterpriseAdministratorInvitationOrder({
    required Enum$EnterpriseAdministratorInvitationOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseAdministratorInvitationOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseAdministratorInvitationOrder._(this._$data);

  factory Input$EnterpriseAdministratorInvitationOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseAdministratorInvitationOrderField(
            (l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseAdministratorInvitationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseAdministratorInvitationOrderField get field =>
      (_$data['field'] as Enum$EnterpriseAdministratorInvitationOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseAdministratorInvitationOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseAdministratorInvitationOrder<
          Input$EnterpriseAdministratorInvitationOrder>
      get copyWith => CopyWith$Input$EnterpriseAdministratorInvitationOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseAdministratorInvitationOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseAdministratorInvitationOrder<TRes> {
  factory CopyWith$Input$EnterpriseAdministratorInvitationOrder(
    Input$EnterpriseAdministratorInvitationOrder instance,
    TRes Function(Input$EnterpriseAdministratorInvitationOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseAdministratorInvitationOrder;

  factory CopyWith$Input$EnterpriseAdministratorInvitationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseAdministratorInvitationOrder;

  TRes call({
    Enum$EnterpriseAdministratorInvitationOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseAdministratorInvitationOrder<TRes>
    implements CopyWith$Input$EnterpriseAdministratorInvitationOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseAdministratorInvitationOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseAdministratorInvitationOrder _instance;

  final TRes Function(Input$EnterpriseAdministratorInvitationOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseAdministratorInvitationOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseAdministratorInvitationOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseAdministratorInvitationOrder<TRes>
    implements CopyWith$Input$EnterpriseAdministratorInvitationOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseAdministratorInvitationOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseAdministratorInvitationOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseMemberOrder {
  factory Input$EnterpriseMemberOrder({
    required Enum$EnterpriseMemberOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseMemberOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseMemberOrder._(this._$data);

  factory Input$EnterpriseMemberOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseMemberOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseMemberOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseMemberOrderField get field =>
      (_$data['field'] as Enum$EnterpriseMemberOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$EnterpriseMemberOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseMemberOrder<Input$EnterpriseMemberOrder>
      get copyWith => CopyWith$Input$EnterpriseMemberOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseMemberOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseMemberOrder<TRes> {
  factory CopyWith$Input$EnterpriseMemberOrder(
    Input$EnterpriseMemberOrder instance,
    TRes Function(Input$EnterpriseMemberOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseMemberOrder;

  factory CopyWith$Input$EnterpriseMemberOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseMemberOrder;

  TRes call({
    Enum$EnterpriseMemberOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseMemberOrder<TRes>
    implements CopyWith$Input$EnterpriseMemberOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseMemberOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseMemberOrder _instance;

  final TRes Function(Input$EnterpriseMemberOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseMemberOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseMemberOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseMemberOrder<TRes>
    implements CopyWith$Input$EnterpriseMemberOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseMemberOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseMemberOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseServerInstallationOrder {
  factory Input$EnterpriseServerInstallationOrder({
    required Enum$EnterpriseServerInstallationOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseServerInstallationOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseServerInstallationOrder._(this._$data);

  factory Input$EnterpriseServerInstallationOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$EnterpriseServerInstallationOrderField(
        (l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseServerInstallationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseServerInstallationOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerInstallationOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerInstallationOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerInstallationOrder<
          Input$EnterpriseServerInstallationOrder>
      get copyWith => CopyWith$Input$EnterpriseServerInstallationOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseServerInstallationOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerInstallationOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerInstallationOrder(
    Input$EnterpriseServerInstallationOrder instance,
    TRes Function(Input$EnterpriseServerInstallationOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerInstallationOrder;

  factory CopyWith$Input$EnterpriseServerInstallationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerInstallationOrder;

  TRes call({
    Enum$EnterpriseServerInstallationOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseServerInstallationOrder<TRes>
    implements CopyWith$Input$EnterpriseServerInstallationOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerInstallationOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerInstallationOrder _instance;

  final TRes Function(Input$EnterpriseServerInstallationOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseServerInstallationOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerInstallationOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerInstallationOrder<TRes>
    implements CopyWith$Input$EnterpriseServerInstallationOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerInstallationOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseServerInstallationOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseServerUserAccountEmailOrder {
  factory Input$EnterpriseServerUserAccountEmailOrder({
    required Enum$EnterpriseServerUserAccountEmailOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseServerUserAccountEmailOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseServerUserAccountEmailOrder._(this._$data);

  factory Input$EnterpriseServerUserAccountEmailOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseServerUserAccountEmailOrderField(
            (l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseServerUserAccountEmailOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseServerUserAccountEmailOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerUserAccountEmailOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerUserAccountEmailOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerUserAccountEmailOrder<
          Input$EnterpriseServerUserAccountEmailOrder>
      get copyWith => CopyWith$Input$EnterpriseServerUserAccountEmailOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseServerUserAccountEmailOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerUserAccountEmailOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerUserAccountEmailOrder(
    Input$EnterpriseServerUserAccountEmailOrder instance,
    TRes Function(Input$EnterpriseServerUserAccountEmailOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerUserAccountEmailOrder;

  factory CopyWith$Input$EnterpriseServerUserAccountEmailOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerUserAccountEmailOrder;

  TRes call({
    Enum$EnterpriseServerUserAccountEmailOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseServerUserAccountEmailOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountEmailOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerUserAccountEmailOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerUserAccountEmailOrder _instance;

  final TRes Function(Input$EnterpriseServerUserAccountEmailOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseServerUserAccountEmailOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerUserAccountEmailOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerUserAccountEmailOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountEmailOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerUserAccountEmailOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseServerUserAccountEmailOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseServerUserAccountOrder {
  factory Input$EnterpriseServerUserAccountOrder({
    required Enum$EnterpriseServerUserAccountOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseServerUserAccountOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseServerUserAccountOrder._(this._$data);

  factory Input$EnterpriseServerUserAccountOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$EnterpriseServerUserAccountOrderField(
        (l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseServerUserAccountOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseServerUserAccountOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerUserAccountOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerUserAccountOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerUserAccountOrder<
          Input$EnterpriseServerUserAccountOrder>
      get copyWith => CopyWith$Input$EnterpriseServerUserAccountOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseServerUserAccountOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerUserAccountOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerUserAccountOrder(
    Input$EnterpriseServerUserAccountOrder instance,
    TRes Function(Input$EnterpriseServerUserAccountOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerUserAccountOrder;

  factory CopyWith$Input$EnterpriseServerUserAccountOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerUserAccountOrder;

  TRes call({
    Enum$EnterpriseServerUserAccountOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseServerUserAccountOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerUserAccountOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerUserAccountOrder _instance;

  final TRes Function(Input$EnterpriseServerUserAccountOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseServerUserAccountOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerUserAccountOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerUserAccountOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerUserAccountOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseServerUserAccountOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseServerUserAccountsUploadOrder {
  factory Input$EnterpriseServerUserAccountsUploadOrder({
    required Enum$EnterpriseServerUserAccountsUploadOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseServerUserAccountsUploadOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseServerUserAccountsUploadOrder._(this._$data);

  factory Input$EnterpriseServerUserAccountsUploadOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseServerUserAccountsUploadOrderField(
            (l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseServerUserAccountsUploadOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseServerUserAccountsUploadOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerUserAccountsUploadOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerUserAccountsUploadOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<
          Input$EnterpriseServerUserAccountsUploadOrder>
      get copyWith => CopyWith$Input$EnterpriseServerUserAccountsUploadOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseServerUserAccountsUploadOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerUserAccountsUploadOrder(
    Input$EnterpriseServerUserAccountsUploadOrder instance,
    TRes Function(Input$EnterpriseServerUserAccountsUploadOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerUserAccountsUploadOrder;

  factory CopyWith$Input$EnterpriseServerUserAccountsUploadOrder.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerUserAccountsUploadOrder;

  TRes call({
    Enum$EnterpriseServerUserAccountsUploadOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseServerUserAccountsUploadOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerUserAccountsUploadOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerUserAccountsUploadOrder _instance;

  final TRes Function(Input$EnterpriseServerUserAccountsUploadOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseServerUserAccountsUploadOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerUserAccountsUploadOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerUserAccountsUploadOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerUserAccountsUploadOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseServerUserAccountsUploadOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$FileAddition {
  factory Input$FileAddition({
    required String path,
    required String contents,
  }) =>
      Input$FileAddition._({
        r'path': path,
        r'contents': contents,
      });

  Input$FileAddition._(this._$data);

  factory Input$FileAddition.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    final l$contents = data['contents'];
    result$data['contents'] = (l$contents as String);
    return Input$FileAddition._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  String get contents => (_$data['contents'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    final l$contents = contents;
    result$data['contents'] = l$contents;
    return result$data;
  }

  CopyWith$Input$FileAddition<Input$FileAddition> get copyWith =>
      CopyWith$Input$FileAddition(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FileAddition) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$contents = contents;
    final lOther$contents = other.contents;
    if (l$contents != lOther$contents) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$contents = contents;
    return Object.hashAll([
      l$path,
      l$contents,
    ]);
  }
}

abstract class CopyWith$Input$FileAddition<TRes> {
  factory CopyWith$Input$FileAddition(
    Input$FileAddition instance,
    TRes Function(Input$FileAddition) then,
  ) = _CopyWithImpl$Input$FileAddition;

  factory CopyWith$Input$FileAddition.stub(TRes res) =
      _CopyWithStubImpl$Input$FileAddition;

  TRes call({
    String? path,
    String? contents,
  });
}

class _CopyWithImpl$Input$FileAddition<TRes>
    implements CopyWith$Input$FileAddition<TRes> {
  _CopyWithImpl$Input$FileAddition(
    this._instance,
    this._then,
  );

  final Input$FileAddition _instance;

  final TRes Function(Input$FileAddition) _then;

  static const _undefined = {};

  TRes call({
    Object? path = _undefined,
    Object? contents = _undefined,
  }) =>
      _then(Input$FileAddition._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (contents != _undefined && contents != null)
          'contents': (contents as String),
      }));
}

class _CopyWithStubImpl$Input$FileAddition<TRes>
    implements CopyWith$Input$FileAddition<TRes> {
  _CopyWithStubImpl$Input$FileAddition(this._res);

  TRes _res;

  call({
    String? path,
    String? contents,
  }) =>
      _res;
}

class Input$FileChanges {
  factory Input$FileChanges({
    List<Input$FileDeletion>? deletions,
    List<Input$FileAddition>? additions,
  }) =>
      Input$FileChanges._({
        if (deletions != null) r'deletions': deletions,
        if (additions != null) r'additions': additions,
      });

  Input$FileChanges._(this._$data);

  factory Input$FileChanges.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('deletions')) {
      final l$deletions = data['deletions'];
      result$data['deletions'] = (l$deletions as List<dynamic>?)
          ?.map((e) => Input$FileDeletion.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('additions')) {
      final l$additions = data['additions'];
      result$data['additions'] = (l$additions as List<dynamic>?)
          ?.map((e) => Input$FileAddition.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$FileChanges._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$FileDeletion>? get deletions =>
      (_$data['deletions'] as List<Input$FileDeletion>?);
  List<Input$FileAddition>? get additions =>
      (_$data['additions'] as List<Input$FileAddition>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('deletions')) {
      final l$deletions = deletions;
      result$data['deletions'] = l$deletions?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('additions')) {
      final l$additions = additions;
      result$data['additions'] = l$additions?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$FileChanges<Input$FileChanges> get copyWith =>
      CopyWith$Input$FileChanges(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FileChanges) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$deletions = deletions;
    final lOther$deletions = other.deletions;
    if (_$data.containsKey('deletions') !=
        other._$data.containsKey('deletions')) {
      return false;
    }
    if (l$deletions != null && lOther$deletions != null) {
      if (l$deletions.length != lOther$deletions.length) {
        return false;
      }
      for (int i = 0; i < l$deletions.length; i++) {
        final l$deletions$entry = l$deletions[i];
        final lOther$deletions$entry = lOther$deletions[i];
        if (l$deletions$entry != lOther$deletions$entry) {
          return false;
        }
      }
    } else if (l$deletions != lOther$deletions) {
      return false;
    }
    final l$additions = additions;
    final lOther$additions = other.additions;
    if (_$data.containsKey('additions') !=
        other._$data.containsKey('additions')) {
      return false;
    }
    if (l$additions != null && lOther$additions != null) {
      if (l$additions.length != lOther$additions.length) {
        return false;
      }
      for (int i = 0; i < l$additions.length; i++) {
        final l$additions$entry = l$additions[i];
        final lOther$additions$entry = lOther$additions[i];
        if (l$additions$entry != lOther$additions$entry) {
          return false;
        }
      }
    } else if (l$additions != lOther$additions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$deletions = deletions;
    final l$additions = additions;
    return Object.hashAll([
      _$data.containsKey('deletions')
          ? l$deletions == null
              ? null
              : Object.hashAll(l$deletions.map((v) => v))
          : const {},
      _$data.containsKey('additions')
          ? l$additions == null
              ? null
              : Object.hashAll(l$additions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$FileChanges<TRes> {
  factory CopyWith$Input$FileChanges(
    Input$FileChanges instance,
    TRes Function(Input$FileChanges) then,
  ) = _CopyWithImpl$Input$FileChanges;

  factory CopyWith$Input$FileChanges.stub(TRes res) =
      _CopyWithStubImpl$Input$FileChanges;

  TRes call({
    List<Input$FileDeletion>? deletions,
    List<Input$FileAddition>? additions,
  });
  TRes deletions(
      Iterable<Input$FileDeletion>? Function(
              Iterable<CopyWith$Input$FileDeletion<Input$FileDeletion>>?)
          _fn);
  TRes additions(
      Iterable<Input$FileAddition>? Function(
              Iterable<CopyWith$Input$FileAddition<Input$FileAddition>>?)
          _fn);
}

class _CopyWithImpl$Input$FileChanges<TRes>
    implements CopyWith$Input$FileChanges<TRes> {
  _CopyWithImpl$Input$FileChanges(
    this._instance,
    this._then,
  );

  final Input$FileChanges _instance;

  final TRes Function(Input$FileChanges) _then;

  static const _undefined = {};

  TRes call({
    Object? deletions = _undefined,
    Object? additions = _undefined,
  }) =>
      _then(Input$FileChanges._({
        ..._instance._$data,
        if (deletions != _undefined)
          'deletions': (deletions as List<Input$FileDeletion>?),
        if (additions != _undefined)
          'additions': (additions as List<Input$FileAddition>?),
      }));
  TRes deletions(
          Iterable<Input$FileDeletion>? Function(
                  Iterable<CopyWith$Input$FileDeletion<Input$FileDeletion>>?)
              _fn) =>
      call(
          deletions:
              _fn(_instance.deletions?.map((e) => CopyWith$Input$FileDeletion(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes additions(
          Iterable<Input$FileAddition>? Function(
                  Iterable<CopyWith$Input$FileAddition<Input$FileAddition>>?)
              _fn) =>
      call(
          additions:
              _fn(_instance.additions?.map((e) => CopyWith$Input$FileAddition(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$FileChanges<TRes>
    implements CopyWith$Input$FileChanges<TRes> {
  _CopyWithStubImpl$Input$FileChanges(this._res);

  TRes _res;

  call({
    List<Input$FileDeletion>? deletions,
    List<Input$FileAddition>? additions,
  }) =>
      _res;
  deletions(_fn) => _res;
  additions(_fn) => _res;
}

class Input$FileDeletion {
  factory Input$FileDeletion({required String path}) => Input$FileDeletion._({
        r'path': path,
      });

  Input$FileDeletion._(this._$data);

  factory Input$FileDeletion.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    return Input$FileDeletion._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    return result$data;
  }

  CopyWith$Input$FileDeletion<Input$FileDeletion> get copyWith =>
      CopyWith$Input$FileDeletion(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FileDeletion) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    return Object.hashAll([l$path]);
  }
}

abstract class CopyWith$Input$FileDeletion<TRes> {
  factory CopyWith$Input$FileDeletion(
    Input$FileDeletion instance,
    TRes Function(Input$FileDeletion) then,
  ) = _CopyWithImpl$Input$FileDeletion;

  factory CopyWith$Input$FileDeletion.stub(TRes res) =
      _CopyWithStubImpl$Input$FileDeletion;

  TRes call({String? path});
}

class _CopyWithImpl$Input$FileDeletion<TRes>
    implements CopyWith$Input$FileDeletion<TRes> {
  _CopyWithImpl$Input$FileDeletion(
    this._instance,
    this._then,
  );

  final Input$FileDeletion _instance;

  final TRes Function(Input$FileDeletion) _then;

  static const _undefined = {};

  TRes call({Object? path = _undefined}) => _then(Input$FileDeletion._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
      }));
}

class _CopyWithStubImpl$Input$FileDeletion<TRes>
    implements CopyWith$Input$FileDeletion<TRes> {
  _CopyWithStubImpl$Input$FileDeletion(this._res);

  TRes _res;

  call({String? path}) => _res;
}

class Input$FollowOrganizationInput {
  factory Input$FollowOrganizationInput({
    required String organizationId,
    String? clientMutationId,
  }) =>
      Input$FollowOrganizationInput._({
        r'organizationId': organizationId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$FollowOrganizationInput._(this._$data);

  factory Input$FollowOrganizationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$FollowOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get organizationId => (_$data['organizationId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$FollowOrganizationInput<Input$FollowOrganizationInput>
      get copyWith => CopyWith$Input$FollowOrganizationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FollowOrganizationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$organizationId = organizationId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$organizationId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$FollowOrganizationInput<TRes> {
  factory CopyWith$Input$FollowOrganizationInput(
    Input$FollowOrganizationInput instance,
    TRes Function(Input$FollowOrganizationInput) then,
  ) = _CopyWithImpl$Input$FollowOrganizationInput;

  factory CopyWith$Input$FollowOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FollowOrganizationInput;

  TRes call({
    String? organizationId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$FollowOrganizationInput<TRes>
    implements CopyWith$Input$FollowOrganizationInput<TRes> {
  _CopyWithImpl$Input$FollowOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$FollowOrganizationInput _instance;

  final TRes Function(Input$FollowOrganizationInput) _then;

  static const _undefined = {};

  TRes call({
    Object? organizationId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$FollowOrganizationInput._({
        ..._instance._$data,
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$FollowOrganizationInput<TRes>
    implements CopyWith$Input$FollowOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$FollowOrganizationInput(this._res);

  TRes _res;

  call({
    String? organizationId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$FollowUserInput {
  factory Input$FollowUserInput({
    required String userId,
    String? clientMutationId,
  }) =>
      Input$FollowUserInput._({
        r'userId': userId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$FollowUserInput._(this._$data);

  factory Input$FollowUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$FollowUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get userId => (_$data['userId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$userId = userId;
    result$data['userId'] = l$userId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$FollowUserInput<Input$FollowUserInput> get copyWith =>
      CopyWith$Input$FollowUserInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FollowUserInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$userId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$FollowUserInput<TRes> {
  factory CopyWith$Input$FollowUserInput(
    Input$FollowUserInput instance,
    TRes Function(Input$FollowUserInput) then,
  ) = _CopyWithImpl$Input$FollowUserInput;

  factory CopyWith$Input$FollowUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FollowUserInput;

  TRes call({
    String? userId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$FollowUserInput<TRes>
    implements CopyWith$Input$FollowUserInput<TRes> {
  _CopyWithImpl$Input$FollowUserInput(
    this._instance,
    this._then,
  );

  final Input$FollowUserInput _instance;

  final TRes Function(Input$FollowUserInput) _then;

  static const _undefined = {};

  TRes call({
    Object? userId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$FollowUserInput._({
        ..._instance._$data,
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$FollowUserInput<TRes>
    implements CopyWith$Input$FollowUserInput<TRes> {
  _CopyWithStubImpl$Input$FollowUserInput(this._res);

  TRes _res;

  call({
    String? userId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$GistOrder {
  factory Input$GistOrder({
    required Enum$GistOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$GistOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$GistOrder._(this._$data);

  factory Input$GistOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$GistOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$GistOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$GistOrderField get field => (_$data['field'] as Enum$GistOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$GistOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$GistOrder<Input$GistOrder> get copyWith =>
      CopyWith$Input$GistOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GistOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$GistOrder<TRes> {
  factory CopyWith$Input$GistOrder(
    Input$GistOrder instance,
    TRes Function(Input$GistOrder) then,
  ) = _CopyWithImpl$Input$GistOrder;

  factory CopyWith$Input$GistOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$GistOrder;

  TRes call({
    Enum$GistOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$GistOrder<TRes>
    implements CopyWith$Input$GistOrder<TRes> {
  _CopyWithImpl$Input$GistOrder(
    this._instance,
    this._then,
  );

  final Input$GistOrder _instance;

  final TRes Function(Input$GistOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$GistOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$GistOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$GistOrder<TRes>
    implements CopyWith$Input$GistOrder<TRes> {
  _CopyWithStubImpl$Input$GistOrder(this._res);

  TRes _res;

  call({
    Enum$GistOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$GrantEnterpriseOrganizationsMigratorRoleInput {
  factory Input$GrantEnterpriseOrganizationsMigratorRoleInput({
    required String enterpriseId,
    required String login,
    String? clientMutationId,
  }) =>
      Input$GrantEnterpriseOrganizationsMigratorRoleInput._({
        r'enterpriseId': enterpriseId,
        r'login': login,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$GrantEnterpriseOrganizationsMigratorRoleInput._(this._$data);

  factory Input$GrantEnterpriseOrganizationsMigratorRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$GrantEnterpriseOrganizationsMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<
          Input$GrantEnterpriseOrganizationsMigratorRoleInput>
      get copyWith =>
          CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GrantEnterpriseOrganizationsMigratorRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$login,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<
    TRes> {
  factory CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
    Input$GrantEnterpriseOrganizationsMigratorRoleInput instance,
    TRes Function(Input$GrantEnterpriseOrganizationsMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput;

  factory CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput;

  TRes call({
    String? enterpriseId,
    String? login,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput<TRes>
    implements
        CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$GrantEnterpriseOrganizationsMigratorRoleInput _instance;

  final TRes Function(Input$GrantEnterpriseOrganizationsMigratorRoleInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$GrantEnterpriseOrganizationsMigratorRoleInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput<
        TRes>
    implements
        CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? login,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$GrantMigratorRoleInput {
  factory Input$GrantMigratorRoleInput({
    required String organizationId,
    required String actor,
    required Enum$ActorType actorType,
    String? clientMutationId,
  }) =>
      Input$GrantMigratorRoleInput._({
        r'organizationId': organizationId,
        r'actor': actor,
        r'actorType': actorType,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$GrantMigratorRoleInput._(this._$data);

  factory Input$GrantMigratorRoleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$actor = data['actor'];
    result$data['actor'] = (l$actor as String);
    final l$actorType = data['actorType'];
    result$data['actorType'] = fromJson$Enum$ActorType((l$actorType as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$GrantMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get organizationId => (_$data['organizationId'] as String);
  String get actor => (_$data['actor'] as String);
  Enum$ActorType get actorType => (_$data['actorType'] as Enum$ActorType);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$actor = actor;
    result$data['actor'] = l$actor;
    final l$actorType = actorType;
    result$data['actorType'] = toJson$Enum$ActorType(l$actorType);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$GrantMigratorRoleInput<Input$GrantMigratorRoleInput>
      get copyWith => CopyWith$Input$GrantMigratorRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GrantMigratorRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$actor = actor;
    final lOther$actor = other.actor;
    if (l$actor != lOther$actor) {
      return false;
    }
    final l$actorType = actorType;
    final lOther$actorType = other.actorType;
    if (l$actorType != lOther$actorType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$organizationId = organizationId;
    final l$actor = actor;
    final l$actorType = actorType;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$organizationId,
      l$actor,
      l$actorType,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$GrantMigratorRoleInput<TRes> {
  factory CopyWith$Input$GrantMigratorRoleInput(
    Input$GrantMigratorRoleInput instance,
    TRes Function(Input$GrantMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$GrantMigratorRoleInput;

  factory CopyWith$Input$GrantMigratorRoleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GrantMigratorRoleInput;

  TRes call({
    String? organizationId,
    String? actor,
    Enum$ActorType? actorType,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$GrantMigratorRoleInput<TRes>
    implements CopyWith$Input$GrantMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$GrantMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$GrantMigratorRoleInput _instance;

  final TRes Function(Input$GrantMigratorRoleInput) _then;

  static const _undefined = {};

  TRes call({
    Object? organizationId = _undefined,
    Object? actor = _undefined,
    Object? actorType = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$GrantMigratorRoleInput._({
        ..._instance._$data,
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (actor != _undefined && actor != null) 'actor': (actor as String),
        if (actorType != _undefined && actorType != null)
          'actorType': (actorType as Enum$ActorType),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$GrantMigratorRoleInput<TRes>
    implements CopyWith$Input$GrantMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$GrantMigratorRoleInput(this._res);

  TRes _res;

  call({
    String? organizationId,
    String? actor,
    Enum$ActorType? actorType,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$InviteEnterpriseAdminInput {
  factory Input$InviteEnterpriseAdminInput({
    required String enterpriseId,
    String? invitee,
    String? email,
    Enum$EnterpriseAdministratorRole? role,
    String? clientMutationId,
  }) =>
      Input$InviteEnterpriseAdminInput._({
        r'enterpriseId': enterpriseId,
        if (invitee != null) r'invitee': invitee,
        if (email != null) r'email': email,
        if (role != null) r'role': role,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$InviteEnterpriseAdminInput._(this._$data);

  factory Input$InviteEnterpriseAdminInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('invitee')) {
      final l$invitee = data['invitee'];
      result$data['invitee'] = (l$invitee as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : fromJson$Enum$EnterpriseAdministratorRole((l$role as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$InviteEnterpriseAdminInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String? get invitee => (_$data['invitee'] as String?);
  String? get email => (_$data['email'] as String?);
  Enum$EnterpriseAdministratorRole? get role =>
      (_$data['role'] as Enum$EnterpriseAdministratorRole?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('invitee')) {
      final l$invitee = invitee;
      result$data['invitee'] = l$invitee;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role == null
          ? null
          : toJson$Enum$EnterpriseAdministratorRole(l$role);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$InviteEnterpriseAdminInput<Input$InviteEnterpriseAdminInput>
      get copyWith => CopyWith$Input$InviteEnterpriseAdminInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InviteEnterpriseAdminInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$invitee = invitee;
    final lOther$invitee = other.invitee;
    if (_$data.containsKey('invitee') != other._$data.containsKey('invitee')) {
      return false;
    }
    if (l$invitee != lOther$invitee) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$invitee = invitee;
    final l$email = email;
    final l$role = role;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      _$data.containsKey('invitee') ? l$invitee : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$InviteEnterpriseAdminInput<TRes> {
  factory CopyWith$Input$InviteEnterpriseAdminInput(
    Input$InviteEnterpriseAdminInput instance,
    TRes Function(Input$InviteEnterpriseAdminInput) then,
  ) = _CopyWithImpl$Input$InviteEnterpriseAdminInput;

  factory CopyWith$Input$InviteEnterpriseAdminInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InviteEnterpriseAdminInput;

  TRes call({
    String? enterpriseId,
    String? invitee,
    String? email,
    Enum$EnterpriseAdministratorRole? role,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$InviteEnterpriseAdminInput<TRes>
    implements CopyWith$Input$InviteEnterpriseAdminInput<TRes> {
  _CopyWithImpl$Input$InviteEnterpriseAdminInput(
    this._instance,
    this._then,
  );

  final Input$InviteEnterpriseAdminInput _instance;

  final TRes Function(Input$InviteEnterpriseAdminInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? invitee = _undefined,
    Object? email = _undefined,
    Object? role = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$InviteEnterpriseAdminInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (invitee != _undefined) 'invitee': (invitee as String?),
        if (email != _undefined) 'email': (email as String?),
        if (role != _undefined)
          'role': (role as Enum$EnterpriseAdministratorRole?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$InviteEnterpriseAdminInput<TRes>
    implements CopyWith$Input$InviteEnterpriseAdminInput<TRes> {
  _CopyWithStubImpl$Input$InviteEnterpriseAdminInput(this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? invitee,
    String? email,
    Enum$EnterpriseAdministratorRole? role,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$IpAllowListEntryOrder {
  factory Input$IpAllowListEntryOrder({
    required Enum$IpAllowListEntryOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$IpAllowListEntryOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$IpAllowListEntryOrder._(this._$data);

  factory Input$IpAllowListEntryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$IpAllowListEntryOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$IpAllowListEntryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$IpAllowListEntryOrderField get field =>
      (_$data['field'] as Enum$IpAllowListEntryOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$IpAllowListEntryOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$IpAllowListEntryOrder<Input$IpAllowListEntryOrder>
      get copyWith => CopyWith$Input$IpAllowListEntryOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IpAllowListEntryOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$IpAllowListEntryOrder<TRes> {
  factory CopyWith$Input$IpAllowListEntryOrder(
    Input$IpAllowListEntryOrder instance,
    TRes Function(Input$IpAllowListEntryOrder) then,
  ) = _CopyWithImpl$Input$IpAllowListEntryOrder;

  factory CopyWith$Input$IpAllowListEntryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$IpAllowListEntryOrder;

  TRes call({
    Enum$IpAllowListEntryOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$IpAllowListEntryOrder<TRes>
    implements CopyWith$Input$IpAllowListEntryOrder<TRes> {
  _CopyWithImpl$Input$IpAllowListEntryOrder(
    this._instance,
    this._then,
  );

  final Input$IpAllowListEntryOrder _instance;

  final TRes Function(Input$IpAllowListEntryOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$IpAllowListEntryOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$IpAllowListEntryOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$IpAllowListEntryOrder<TRes>
    implements CopyWith$Input$IpAllowListEntryOrder<TRes> {
  _CopyWithStubImpl$Input$IpAllowListEntryOrder(this._res);

  TRes _res;

  call({
    Enum$IpAllowListEntryOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$IssueCommentOrder {
  factory Input$IssueCommentOrder({
    required Enum$IssueCommentOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$IssueCommentOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$IssueCommentOrder._(this._$data);

  factory Input$IssueCommentOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$IssueCommentOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$IssueCommentOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$IssueCommentOrderField get field =>
      (_$data['field'] as Enum$IssueCommentOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$IssueCommentOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$IssueCommentOrder<Input$IssueCommentOrder> get copyWith =>
      CopyWith$Input$IssueCommentOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueCommentOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$IssueCommentOrder<TRes> {
  factory CopyWith$Input$IssueCommentOrder(
    Input$IssueCommentOrder instance,
    TRes Function(Input$IssueCommentOrder) then,
  ) = _CopyWithImpl$Input$IssueCommentOrder;

  factory CopyWith$Input$IssueCommentOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueCommentOrder;

  TRes call({
    Enum$IssueCommentOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$IssueCommentOrder<TRes>
    implements CopyWith$Input$IssueCommentOrder<TRes> {
  _CopyWithImpl$Input$IssueCommentOrder(
    this._instance,
    this._then,
  );

  final Input$IssueCommentOrder _instance;

  final TRes Function(Input$IssueCommentOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$IssueCommentOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$IssueCommentOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$IssueCommentOrder<TRes>
    implements CopyWith$Input$IssueCommentOrder<TRes> {
  _CopyWithStubImpl$Input$IssueCommentOrder(this._res);

  TRes _res;

  call({
    Enum$IssueCommentOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$IssueFilters {
  factory Input$IssueFilters({
    String? assignee,
    String? createdBy,
    List<String>? labels,
    String? mentioned,
    String? milestone,
    String? milestoneNumber,
    String? since,
    List<Enum$IssueState>? states,
    bool? viewerSubscribed,
  }) =>
      Input$IssueFilters._({
        if (assignee != null) r'assignee': assignee,
        if (createdBy != null) r'createdBy': createdBy,
        if (labels != null) r'labels': labels,
        if (mentioned != null) r'mentioned': mentioned,
        if (milestone != null) r'milestone': milestone,
        if (milestoneNumber != null) r'milestoneNumber': milestoneNumber,
        if (since != null) r'since': since,
        if (states != null) r'states': states,
        if (viewerSubscribed != null) r'viewerSubscribed': viewerSubscribed,
      });

  Input$IssueFilters._(this._$data);

  factory Input$IssueFilters.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('assignee')) {
      final l$assignee = data['assignee'];
      result$data['assignee'] = (l$assignee as String?);
    }
    if (data.containsKey('createdBy')) {
      final l$createdBy = data['createdBy'];
      result$data['createdBy'] = (l$createdBy as String?);
    }
    if (data.containsKey('labels')) {
      final l$labels = data['labels'];
      result$data['labels'] =
          (l$labels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('mentioned')) {
      final l$mentioned = data['mentioned'];
      result$data['mentioned'] = (l$mentioned as String?);
    }
    if (data.containsKey('milestone')) {
      final l$milestone = data['milestone'];
      result$data['milestone'] = (l$milestone as String?);
    }
    if (data.containsKey('milestoneNumber')) {
      final l$milestoneNumber = data['milestoneNumber'];
      result$data['milestoneNumber'] = (l$milestoneNumber as String?);
    }
    if (data.containsKey('since')) {
      final l$since = data['since'];
      result$data['since'] = (l$since as String?);
    }
    if (data.containsKey('states')) {
      final l$states = data['states'];
      result$data['states'] = (l$states as List<dynamic>?)
          ?.map((e) => fromJson$Enum$IssueState((e as String)))
          .toList();
    }
    if (data.containsKey('viewerSubscribed')) {
      final l$viewerSubscribed = data['viewerSubscribed'];
      result$data['viewerSubscribed'] = (l$viewerSubscribed as bool?);
    }
    return Input$IssueFilters._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get assignee => (_$data['assignee'] as String?);
  String? get createdBy => (_$data['createdBy'] as String?);
  List<String>? get labels => (_$data['labels'] as List<String>?);
  String? get mentioned => (_$data['mentioned'] as String?);
  String? get milestone => (_$data['milestone'] as String?);
  String? get milestoneNumber => (_$data['milestoneNumber'] as String?);
  String? get since => (_$data['since'] as String?);
  List<Enum$IssueState>? get states =>
      (_$data['states'] as List<Enum$IssueState>?);
  bool? get viewerSubscribed => (_$data['viewerSubscribed'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('assignee')) {
      final l$assignee = assignee;
      result$data['assignee'] = l$assignee;
    }
    if (_$data.containsKey('createdBy')) {
      final l$createdBy = createdBy;
      result$data['createdBy'] = l$createdBy;
    }
    if (_$data.containsKey('labels')) {
      final l$labels = labels;
      result$data['labels'] = l$labels?.map((e) => e).toList();
    }
    if (_$data.containsKey('mentioned')) {
      final l$mentioned = mentioned;
      result$data['mentioned'] = l$mentioned;
    }
    if (_$data.containsKey('milestone')) {
      final l$milestone = milestone;
      result$data['milestone'] = l$milestone;
    }
    if (_$data.containsKey('milestoneNumber')) {
      final l$milestoneNumber = milestoneNumber;
      result$data['milestoneNumber'] = l$milestoneNumber;
    }
    if (_$data.containsKey('since')) {
      final l$since = since;
      result$data['since'] = l$since;
    }
    if (_$data.containsKey('states')) {
      final l$states = states;
      result$data['states'] =
          l$states?.map((e) => toJson$Enum$IssueState(e)).toList();
    }
    if (_$data.containsKey('viewerSubscribed')) {
      final l$viewerSubscribed = viewerSubscribed;
      result$data['viewerSubscribed'] = l$viewerSubscribed;
    }
    return result$data;
  }

  CopyWith$Input$IssueFilters<Input$IssueFilters> get copyWith =>
      CopyWith$Input$IssueFilters(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueFilters) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$assignee = assignee;
    final lOther$assignee = other.assignee;
    if (_$data.containsKey('assignee') !=
        other._$data.containsKey('assignee')) {
      return false;
    }
    if (l$assignee != lOther$assignee) {
      return false;
    }
    final l$createdBy = createdBy;
    final lOther$createdBy = other.createdBy;
    if (_$data.containsKey('createdBy') !=
        other._$data.containsKey('createdBy')) {
      return false;
    }
    if (l$createdBy != lOther$createdBy) {
      return false;
    }
    final l$labels = labels;
    final lOther$labels = other.labels;
    if (_$data.containsKey('labels') != other._$data.containsKey('labels')) {
      return false;
    }
    if (l$labels != null && lOther$labels != null) {
      if (l$labels.length != lOther$labels.length) {
        return false;
      }
      for (int i = 0; i < l$labels.length; i++) {
        final l$labels$entry = l$labels[i];
        final lOther$labels$entry = lOther$labels[i];
        if (l$labels$entry != lOther$labels$entry) {
          return false;
        }
      }
    } else if (l$labels != lOther$labels) {
      return false;
    }
    final l$mentioned = mentioned;
    final lOther$mentioned = other.mentioned;
    if (_$data.containsKey('mentioned') !=
        other._$data.containsKey('mentioned')) {
      return false;
    }
    if (l$mentioned != lOther$mentioned) {
      return false;
    }
    final l$milestone = milestone;
    final lOther$milestone = other.milestone;
    if (_$data.containsKey('milestone') !=
        other._$data.containsKey('milestone')) {
      return false;
    }
    if (l$milestone != lOther$milestone) {
      return false;
    }
    final l$milestoneNumber = milestoneNumber;
    final lOther$milestoneNumber = other.milestoneNumber;
    if (_$data.containsKey('milestoneNumber') !=
        other._$data.containsKey('milestoneNumber')) {
      return false;
    }
    if (l$milestoneNumber != lOther$milestoneNumber) {
      return false;
    }
    final l$since = since;
    final lOther$since = other.since;
    if (_$data.containsKey('since') != other._$data.containsKey('since')) {
      return false;
    }
    if (l$since != lOther$since) {
      return false;
    }
    final l$states = states;
    final lOther$states = other.states;
    if (_$data.containsKey('states') != other._$data.containsKey('states')) {
      return false;
    }
    if (l$states != null && lOther$states != null) {
      if (l$states.length != lOther$states.length) {
        return false;
      }
      for (int i = 0; i < l$states.length; i++) {
        final l$states$entry = l$states[i];
        final lOther$states$entry = lOther$states[i];
        if (l$states$entry != lOther$states$entry) {
          return false;
        }
      }
    } else if (l$states != lOther$states) {
      return false;
    }
    final l$viewerSubscribed = viewerSubscribed;
    final lOther$viewerSubscribed = other.viewerSubscribed;
    if (_$data.containsKey('viewerSubscribed') !=
        other._$data.containsKey('viewerSubscribed')) {
      return false;
    }
    if (l$viewerSubscribed != lOther$viewerSubscribed) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assignee = assignee;
    final l$createdBy = createdBy;
    final l$labels = labels;
    final l$mentioned = mentioned;
    final l$milestone = milestone;
    final l$milestoneNumber = milestoneNumber;
    final l$since = since;
    final l$states = states;
    final l$viewerSubscribed = viewerSubscribed;
    return Object.hashAll([
      _$data.containsKey('assignee') ? l$assignee : const {},
      _$data.containsKey('createdBy') ? l$createdBy : const {},
      _$data.containsKey('labels')
          ? l$labels == null
              ? null
              : Object.hashAll(l$labels.map((v) => v))
          : const {},
      _$data.containsKey('mentioned') ? l$mentioned : const {},
      _$data.containsKey('milestone') ? l$milestone : const {},
      _$data.containsKey('milestoneNumber') ? l$milestoneNumber : const {},
      _$data.containsKey('since') ? l$since : const {},
      _$data.containsKey('states')
          ? l$states == null
              ? null
              : Object.hashAll(l$states.map((v) => v))
          : const {},
      _$data.containsKey('viewerSubscribed') ? l$viewerSubscribed : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssueFilters<TRes> {
  factory CopyWith$Input$IssueFilters(
    Input$IssueFilters instance,
    TRes Function(Input$IssueFilters) then,
  ) = _CopyWithImpl$Input$IssueFilters;

  factory CopyWith$Input$IssueFilters.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueFilters;

  TRes call({
    String? assignee,
    String? createdBy,
    List<String>? labels,
    String? mentioned,
    String? milestone,
    String? milestoneNumber,
    String? since,
    List<Enum$IssueState>? states,
    bool? viewerSubscribed,
  });
}

class _CopyWithImpl$Input$IssueFilters<TRes>
    implements CopyWith$Input$IssueFilters<TRes> {
  _CopyWithImpl$Input$IssueFilters(
    this._instance,
    this._then,
  );

  final Input$IssueFilters _instance;

  final TRes Function(Input$IssueFilters) _then;

  static const _undefined = {};

  TRes call({
    Object? assignee = _undefined,
    Object? createdBy = _undefined,
    Object? labels = _undefined,
    Object? mentioned = _undefined,
    Object? milestone = _undefined,
    Object? milestoneNumber = _undefined,
    Object? since = _undefined,
    Object? states = _undefined,
    Object? viewerSubscribed = _undefined,
  }) =>
      _then(Input$IssueFilters._({
        ..._instance._$data,
        if (assignee != _undefined) 'assignee': (assignee as String?),
        if (createdBy != _undefined) 'createdBy': (createdBy as String?),
        if (labels != _undefined) 'labels': (labels as List<String>?),
        if (mentioned != _undefined) 'mentioned': (mentioned as String?),
        if (milestone != _undefined) 'milestone': (milestone as String?),
        if (milestoneNumber != _undefined)
          'milestoneNumber': (milestoneNumber as String?),
        if (since != _undefined) 'since': (since as String?),
        if (states != _undefined) 'states': (states as List<Enum$IssueState>?),
        if (viewerSubscribed != _undefined)
          'viewerSubscribed': (viewerSubscribed as bool?),
      }));
}

class _CopyWithStubImpl$Input$IssueFilters<TRes>
    implements CopyWith$Input$IssueFilters<TRes> {
  _CopyWithStubImpl$Input$IssueFilters(this._res);

  TRes _res;

  call({
    String? assignee,
    String? createdBy,
    List<String>? labels,
    String? mentioned,
    String? milestone,
    String? milestoneNumber,
    String? since,
    List<Enum$IssueState>? states,
    bool? viewerSubscribed,
  }) =>
      _res;
}

class Input$IssueOrder {
  factory Input$IssueOrder({
    required Enum$IssueOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$IssueOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$IssueOrder._(this._$data);

  factory Input$IssueOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$IssueOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$IssueOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$IssueOrderField get field => (_$data['field'] as Enum$IssueOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$IssueOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$IssueOrder<Input$IssueOrder> get copyWith =>
      CopyWith$Input$IssueOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$IssueOrder<TRes> {
  factory CopyWith$Input$IssueOrder(
    Input$IssueOrder instance,
    TRes Function(Input$IssueOrder) then,
  ) = _CopyWithImpl$Input$IssueOrder;

  factory CopyWith$Input$IssueOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueOrder;

  TRes call({
    Enum$IssueOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$IssueOrder<TRes>
    implements CopyWith$Input$IssueOrder<TRes> {
  _CopyWithImpl$Input$IssueOrder(
    this._instance,
    this._then,
  );

  final Input$IssueOrder _instance;

  final TRes Function(Input$IssueOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$IssueOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$IssueOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$IssueOrder<TRes>
    implements CopyWith$Input$IssueOrder<TRes> {
  _CopyWithStubImpl$Input$IssueOrder(this._res);

  TRes _res;

  call({
    Enum$IssueOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$LabelOrder {
  factory Input$LabelOrder({
    required Enum$LabelOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$LabelOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$LabelOrder._(this._$data);

  factory Input$LabelOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$LabelOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$LabelOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$LabelOrderField get field => (_$data['field'] as Enum$LabelOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$LabelOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$LabelOrder<Input$LabelOrder> get copyWith =>
      CopyWith$Input$LabelOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LabelOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$LabelOrder<TRes> {
  factory CopyWith$Input$LabelOrder(
    Input$LabelOrder instance,
    TRes Function(Input$LabelOrder) then,
  ) = _CopyWithImpl$Input$LabelOrder;

  factory CopyWith$Input$LabelOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$LabelOrder;

  TRes call({
    Enum$LabelOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$LabelOrder<TRes>
    implements CopyWith$Input$LabelOrder<TRes> {
  _CopyWithImpl$Input$LabelOrder(
    this._instance,
    this._then,
  );

  final Input$LabelOrder _instance;

  final TRes Function(Input$LabelOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$LabelOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$LabelOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$LabelOrder<TRes>
    implements CopyWith$Input$LabelOrder<TRes> {
  _CopyWithStubImpl$Input$LabelOrder(this._res);

  TRes _res;

  call({
    Enum$LabelOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$LanguageOrder {
  factory Input$LanguageOrder({
    required Enum$LanguageOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$LanguageOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$LanguageOrder._(this._$data);

  factory Input$LanguageOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$LanguageOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$LanguageOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$LanguageOrderField get field =>
      (_$data['field'] as Enum$LanguageOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$LanguageOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$LanguageOrder<Input$LanguageOrder> get copyWith =>
      CopyWith$Input$LanguageOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LanguageOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$LanguageOrder<TRes> {
  factory CopyWith$Input$LanguageOrder(
    Input$LanguageOrder instance,
    TRes Function(Input$LanguageOrder) then,
  ) = _CopyWithImpl$Input$LanguageOrder;

  factory CopyWith$Input$LanguageOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$LanguageOrder;

  TRes call({
    Enum$LanguageOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$LanguageOrder<TRes>
    implements CopyWith$Input$LanguageOrder<TRes> {
  _CopyWithImpl$Input$LanguageOrder(
    this._instance,
    this._then,
  );

  final Input$LanguageOrder _instance;

  final TRes Function(Input$LanguageOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$LanguageOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$LanguageOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$LanguageOrder<TRes>
    implements CopyWith$Input$LanguageOrder<TRes> {
  _CopyWithStubImpl$Input$LanguageOrder(this._res);

  TRes _res;

  call({
    Enum$LanguageOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$LinkProjectV2ToRepositoryInput {
  factory Input$LinkProjectV2ToRepositoryInput({
    required String projectId,
    required String repositoryId,
    String? clientMutationId,
  }) =>
      Input$LinkProjectV2ToRepositoryInput._({
        r'projectId': projectId,
        r'repositoryId': repositoryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$LinkProjectV2ToRepositoryInput._(this._$data);

  factory Input$LinkProjectV2ToRepositoryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$LinkProjectV2ToRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$LinkProjectV2ToRepositoryInput<
          Input$LinkProjectV2ToRepositoryInput>
      get copyWith => CopyWith$Input$LinkProjectV2ToRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LinkProjectV2ToRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$repositoryId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$LinkProjectV2ToRepositoryInput<TRes> {
  factory CopyWith$Input$LinkProjectV2ToRepositoryInput(
    Input$LinkProjectV2ToRepositoryInput instance,
    TRes Function(Input$LinkProjectV2ToRepositoryInput) then,
  ) = _CopyWithImpl$Input$LinkProjectV2ToRepositoryInput;

  factory CopyWith$Input$LinkProjectV2ToRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LinkProjectV2ToRepositoryInput;

  TRes call({
    String? projectId,
    String? repositoryId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$LinkProjectV2ToRepositoryInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToRepositoryInput<TRes> {
  _CopyWithImpl$Input$LinkProjectV2ToRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$LinkProjectV2ToRepositoryInput _instance;

  final TRes Function(Input$LinkProjectV2ToRepositoryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$LinkProjectV2ToRepositoryInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$LinkProjectV2ToRepositoryInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$LinkProjectV2ToRepositoryInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? repositoryId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$LinkProjectV2ToTeamInput {
  factory Input$LinkProjectV2ToTeamInput({
    required String projectId,
    required String teamId,
    String? clientMutationId,
  }) =>
      Input$LinkProjectV2ToTeamInput._({
        r'projectId': projectId,
        r'teamId': teamId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$LinkProjectV2ToTeamInput._(this._$data);

  factory Input$LinkProjectV2ToTeamInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$teamId = data['teamId'];
    result$data['teamId'] = (l$teamId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$LinkProjectV2ToTeamInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get teamId => (_$data['teamId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$teamId = teamId;
    result$data['teamId'] = l$teamId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$LinkProjectV2ToTeamInput<Input$LinkProjectV2ToTeamInput>
      get copyWith => CopyWith$Input$LinkProjectV2ToTeamInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LinkProjectV2ToTeamInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (l$teamId != lOther$teamId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$teamId = teamId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$teamId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$LinkProjectV2ToTeamInput<TRes> {
  factory CopyWith$Input$LinkProjectV2ToTeamInput(
    Input$LinkProjectV2ToTeamInput instance,
    TRes Function(Input$LinkProjectV2ToTeamInput) then,
  ) = _CopyWithImpl$Input$LinkProjectV2ToTeamInput;

  factory CopyWith$Input$LinkProjectV2ToTeamInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LinkProjectV2ToTeamInput;

  TRes call({
    String? projectId,
    String? teamId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$LinkProjectV2ToTeamInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToTeamInput<TRes> {
  _CopyWithImpl$Input$LinkProjectV2ToTeamInput(
    this._instance,
    this._then,
  );

  final Input$LinkProjectV2ToTeamInput _instance;

  final TRes Function(Input$LinkProjectV2ToTeamInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? teamId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$LinkProjectV2ToTeamInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (teamId != _undefined && teamId != null)
          'teamId': (teamId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$LinkProjectV2ToTeamInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToTeamInput<TRes> {
  _CopyWithStubImpl$Input$LinkProjectV2ToTeamInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? teamId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$LinkRepositoryToProjectInput {
  factory Input$LinkRepositoryToProjectInput({
    required String projectId,
    required String repositoryId,
    String? clientMutationId,
  }) =>
      Input$LinkRepositoryToProjectInput._({
        r'projectId': projectId,
        r'repositoryId': repositoryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$LinkRepositoryToProjectInput._(this._$data);

  factory Input$LinkRepositoryToProjectInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$LinkRepositoryToProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$LinkRepositoryToProjectInput<
          Input$LinkRepositoryToProjectInput>
      get copyWith => CopyWith$Input$LinkRepositoryToProjectInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LinkRepositoryToProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$repositoryId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$LinkRepositoryToProjectInput<TRes> {
  factory CopyWith$Input$LinkRepositoryToProjectInput(
    Input$LinkRepositoryToProjectInput instance,
    TRes Function(Input$LinkRepositoryToProjectInput) then,
  ) = _CopyWithImpl$Input$LinkRepositoryToProjectInput;

  factory CopyWith$Input$LinkRepositoryToProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LinkRepositoryToProjectInput;

  TRes call({
    String? projectId,
    String? repositoryId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$LinkRepositoryToProjectInput<TRes>
    implements CopyWith$Input$LinkRepositoryToProjectInput<TRes> {
  _CopyWithImpl$Input$LinkRepositoryToProjectInput(
    this._instance,
    this._then,
  );

  final Input$LinkRepositoryToProjectInput _instance;

  final TRes Function(Input$LinkRepositoryToProjectInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$LinkRepositoryToProjectInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$LinkRepositoryToProjectInput<TRes>
    implements CopyWith$Input$LinkRepositoryToProjectInput<TRes> {
  _CopyWithStubImpl$Input$LinkRepositoryToProjectInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? repositoryId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$LockLockableInput {
  factory Input$LockLockableInput({
    required String lockableId,
    Enum$LockReason? lockReason,
    String? clientMutationId,
  }) =>
      Input$LockLockableInput._({
        r'lockableId': lockableId,
        if (lockReason != null) r'lockReason': lockReason,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$LockLockableInput._(this._$data);

  factory Input$LockLockableInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$lockableId = data['lockableId'];
    result$data['lockableId'] = (l$lockableId as String);
    if (data.containsKey('lockReason')) {
      final l$lockReason = data['lockReason'];
      result$data['lockReason'] = l$lockReason == null
          ? null
          : fromJson$Enum$LockReason((l$lockReason as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$LockLockableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get lockableId => (_$data['lockableId'] as String);
  Enum$LockReason? get lockReason => (_$data['lockReason'] as Enum$LockReason?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$lockableId = lockableId;
    result$data['lockableId'] = l$lockableId;
    if (_$data.containsKey('lockReason')) {
      final l$lockReason = lockReason;
      result$data['lockReason'] =
          l$lockReason == null ? null : toJson$Enum$LockReason(l$lockReason);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$LockLockableInput<Input$LockLockableInput> get copyWith =>
      CopyWith$Input$LockLockableInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LockLockableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$lockableId = lockableId;
    final lOther$lockableId = other.lockableId;
    if (l$lockableId != lOther$lockableId) {
      return false;
    }
    final l$lockReason = lockReason;
    final lOther$lockReason = other.lockReason;
    if (_$data.containsKey('lockReason') !=
        other._$data.containsKey('lockReason')) {
      return false;
    }
    if (l$lockReason != lOther$lockReason) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$lockableId = lockableId;
    final l$lockReason = lockReason;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$lockableId,
      _$data.containsKey('lockReason') ? l$lockReason : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$LockLockableInput<TRes> {
  factory CopyWith$Input$LockLockableInput(
    Input$LockLockableInput instance,
    TRes Function(Input$LockLockableInput) then,
  ) = _CopyWithImpl$Input$LockLockableInput;

  factory CopyWith$Input$LockLockableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LockLockableInput;

  TRes call({
    String? lockableId,
    Enum$LockReason? lockReason,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$LockLockableInput<TRes>
    implements CopyWith$Input$LockLockableInput<TRes> {
  _CopyWithImpl$Input$LockLockableInput(
    this._instance,
    this._then,
  );

  final Input$LockLockableInput _instance;

  final TRes Function(Input$LockLockableInput) _then;

  static const _undefined = {};

  TRes call({
    Object? lockableId = _undefined,
    Object? lockReason = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$LockLockableInput._({
        ..._instance._$data,
        if (lockableId != _undefined && lockableId != null)
          'lockableId': (lockableId as String),
        if (lockReason != _undefined)
          'lockReason': (lockReason as Enum$LockReason?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$LockLockableInput<TRes>
    implements CopyWith$Input$LockLockableInput<TRes> {
  _CopyWithStubImpl$Input$LockLockableInput(this._res);

  TRes _res;

  call({
    String? lockableId,
    Enum$LockReason? lockReason,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$MarkDiscussionCommentAsAnswerInput {
  factory Input$MarkDiscussionCommentAsAnswerInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$MarkDiscussionCommentAsAnswerInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$MarkDiscussionCommentAsAnswerInput._(this._$data);

  factory Input$MarkDiscussionCommentAsAnswerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$MarkDiscussionCommentAsAnswerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$MarkDiscussionCommentAsAnswerInput<
          Input$MarkDiscussionCommentAsAnswerInput>
      get copyWith => CopyWith$Input$MarkDiscussionCommentAsAnswerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MarkDiscussionCommentAsAnswerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MarkDiscussionCommentAsAnswerInput<TRes> {
  factory CopyWith$Input$MarkDiscussionCommentAsAnswerInput(
    Input$MarkDiscussionCommentAsAnswerInput instance,
    TRes Function(Input$MarkDiscussionCommentAsAnswerInput) then,
  ) = _CopyWithImpl$Input$MarkDiscussionCommentAsAnswerInput;

  factory CopyWith$Input$MarkDiscussionCommentAsAnswerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkDiscussionCommentAsAnswerInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$MarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$MarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithImpl$Input$MarkDiscussionCommentAsAnswerInput(
    this._instance,
    this._then,
  );

  final Input$MarkDiscussionCommentAsAnswerInput _instance;

  final TRes Function(Input$MarkDiscussionCommentAsAnswerInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$MarkDiscussionCommentAsAnswerInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$MarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$MarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithStubImpl$Input$MarkDiscussionCommentAsAnswerInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$MarkFileAsViewedInput {
  factory Input$MarkFileAsViewedInput({
    required String pullRequestId,
    required String path,
    String? clientMutationId,
  }) =>
      Input$MarkFileAsViewedInput._({
        r'pullRequestId': pullRequestId,
        r'path': path,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$MarkFileAsViewedInput._(this._$data);

  factory Input$MarkFileAsViewedInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$MarkFileAsViewedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String get path => (_$data['path'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$MarkFileAsViewedInput<Input$MarkFileAsViewedInput>
      get copyWith => CopyWith$Input$MarkFileAsViewedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MarkFileAsViewedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$path = path;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      l$path,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MarkFileAsViewedInput<TRes> {
  factory CopyWith$Input$MarkFileAsViewedInput(
    Input$MarkFileAsViewedInput instance,
    TRes Function(Input$MarkFileAsViewedInput) then,
  ) = _CopyWithImpl$Input$MarkFileAsViewedInput;

  factory CopyWith$Input$MarkFileAsViewedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkFileAsViewedInput;

  TRes call({
    String? pullRequestId,
    String? path,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$MarkFileAsViewedInput<TRes>
    implements CopyWith$Input$MarkFileAsViewedInput<TRes> {
  _CopyWithImpl$Input$MarkFileAsViewedInput(
    this._instance,
    this._then,
  );

  final Input$MarkFileAsViewedInput _instance;

  final TRes Function(Input$MarkFileAsViewedInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? path = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$MarkFileAsViewedInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (path != _undefined && path != null) 'path': (path as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$MarkFileAsViewedInput<TRes>
    implements CopyWith$Input$MarkFileAsViewedInput<TRes> {
  _CopyWithStubImpl$Input$MarkFileAsViewedInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? path,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$MarkPullRequestReadyForReviewInput {
  factory Input$MarkPullRequestReadyForReviewInput({
    required String pullRequestId,
    String? clientMutationId,
  }) =>
      Input$MarkPullRequestReadyForReviewInput._({
        r'pullRequestId': pullRequestId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$MarkPullRequestReadyForReviewInput._(this._$data);

  factory Input$MarkPullRequestReadyForReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$MarkPullRequestReadyForReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$MarkPullRequestReadyForReviewInput<
          Input$MarkPullRequestReadyForReviewInput>
      get copyWith => CopyWith$Input$MarkPullRequestReadyForReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MarkPullRequestReadyForReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MarkPullRequestReadyForReviewInput<TRes> {
  factory CopyWith$Input$MarkPullRequestReadyForReviewInput(
    Input$MarkPullRequestReadyForReviewInput instance,
    TRes Function(Input$MarkPullRequestReadyForReviewInput) then,
  ) = _CopyWithImpl$Input$MarkPullRequestReadyForReviewInput;

  factory CopyWith$Input$MarkPullRequestReadyForReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkPullRequestReadyForReviewInput;

  TRes call({
    String? pullRequestId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$MarkPullRequestReadyForReviewInput<TRes>
    implements CopyWith$Input$MarkPullRequestReadyForReviewInput<TRes> {
  _CopyWithImpl$Input$MarkPullRequestReadyForReviewInput(
    this._instance,
    this._then,
  );

  final Input$MarkPullRequestReadyForReviewInput _instance;

  final TRes Function(Input$MarkPullRequestReadyForReviewInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$MarkPullRequestReadyForReviewInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$MarkPullRequestReadyForReviewInput<TRes>
    implements CopyWith$Input$MarkPullRequestReadyForReviewInput<TRes> {
  _CopyWithStubImpl$Input$MarkPullRequestReadyForReviewInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$MergeBranchInput {
  factory Input$MergeBranchInput({
    required String repositoryId,
    required String base,
    required String head,
    String? commitMessage,
    String? authorEmail,
    String? clientMutationId,
  }) =>
      Input$MergeBranchInput._({
        r'repositoryId': repositoryId,
        r'base': base,
        r'head': head,
        if (commitMessage != null) r'commitMessage': commitMessage,
        if (authorEmail != null) r'authorEmail': authorEmail,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$MergeBranchInput._(this._$data);

  factory Input$MergeBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$base = data['base'];
    result$data['base'] = (l$base as String);
    final l$head = data['head'];
    result$data['head'] = (l$head as String);
    if (data.containsKey('commitMessage')) {
      final l$commitMessage = data['commitMessage'];
      result$data['commitMessage'] = (l$commitMessage as String?);
    }
    if (data.containsKey('authorEmail')) {
      final l$authorEmail = data['authorEmail'];
      result$data['authorEmail'] = (l$authorEmail as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$MergeBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get base => (_$data['base'] as String);
  String get head => (_$data['head'] as String);
  String? get commitMessage => (_$data['commitMessage'] as String?);
  String? get authorEmail => (_$data['authorEmail'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$base = base;
    result$data['base'] = l$base;
    final l$head = head;
    result$data['head'] = l$head;
    if (_$data.containsKey('commitMessage')) {
      final l$commitMessage = commitMessage;
      result$data['commitMessage'] = l$commitMessage;
    }
    if (_$data.containsKey('authorEmail')) {
      final l$authorEmail = authorEmail;
      result$data['authorEmail'] = l$authorEmail;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$MergeBranchInput<Input$MergeBranchInput> get copyWith =>
      CopyWith$Input$MergeBranchInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeBranchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$base = base;
    final lOther$base = other.base;
    if (l$base != lOther$base) {
      return false;
    }
    final l$head = head;
    final lOther$head = other.head;
    if (l$head != lOther$head) {
      return false;
    }
    final l$commitMessage = commitMessage;
    final lOther$commitMessage = other.commitMessage;
    if (_$data.containsKey('commitMessage') !=
        other._$data.containsKey('commitMessage')) {
      return false;
    }
    if (l$commitMessage != lOther$commitMessage) {
      return false;
    }
    final l$authorEmail = authorEmail;
    final lOther$authorEmail = other.authorEmail;
    if (_$data.containsKey('authorEmail') !=
        other._$data.containsKey('authorEmail')) {
      return false;
    }
    if (l$authorEmail != lOther$authorEmail) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$base = base;
    final l$head = head;
    final l$commitMessage = commitMessage;
    final l$authorEmail = authorEmail;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$base,
      l$head,
      _$data.containsKey('commitMessage') ? l$commitMessage : const {},
      _$data.containsKey('authorEmail') ? l$authorEmail : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergeBranchInput<TRes> {
  factory CopyWith$Input$MergeBranchInput(
    Input$MergeBranchInput instance,
    TRes Function(Input$MergeBranchInput) then,
  ) = _CopyWithImpl$Input$MergeBranchInput;

  factory CopyWith$Input$MergeBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeBranchInput;

  TRes call({
    String? repositoryId,
    String? base,
    String? head,
    String? commitMessage,
    String? authorEmail,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$MergeBranchInput<TRes>
    implements CopyWith$Input$MergeBranchInput<TRes> {
  _CopyWithImpl$Input$MergeBranchInput(
    this._instance,
    this._then,
  );

  final Input$MergeBranchInput _instance;

  final TRes Function(Input$MergeBranchInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? base = _undefined,
    Object? head = _undefined,
    Object? commitMessage = _undefined,
    Object? authorEmail = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$MergeBranchInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (base != _undefined && base != null) 'base': (base as String),
        if (head != _undefined && head != null) 'head': (head as String),
        if (commitMessage != _undefined)
          'commitMessage': (commitMessage as String?),
        if (authorEmail != _undefined) 'authorEmail': (authorEmail as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$MergeBranchInput<TRes>
    implements CopyWith$Input$MergeBranchInput<TRes> {
  _CopyWithStubImpl$Input$MergeBranchInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? base,
    String? head,
    String? commitMessage,
    String? authorEmail,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$MergePullRequestInput {
  factory Input$MergePullRequestInput({
    required String pullRequestId,
    String? commitHeadline,
    String? commitBody,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
    String? clientMutationId,
  }) =>
      Input$MergePullRequestInput._({
        r'pullRequestId': pullRequestId,
        if (commitHeadline != null) r'commitHeadline': commitHeadline,
        if (commitBody != null) r'commitBody': commitBody,
        if (expectedHeadOid != null) r'expectedHeadOid': expectedHeadOid,
        if (mergeMethod != null) r'mergeMethod': mergeMethod,
        if (authorEmail != null) r'authorEmail': authorEmail,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$MergePullRequestInput._(this._$data);

  factory Input$MergePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('commitHeadline')) {
      final l$commitHeadline = data['commitHeadline'];
      result$data['commitHeadline'] = (l$commitHeadline as String?);
    }
    if (data.containsKey('commitBody')) {
      final l$commitBody = data['commitBody'];
      result$data['commitBody'] = (l$commitBody as String?);
    }
    if (data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = data['expectedHeadOid'];
      result$data['expectedHeadOid'] = (l$expectedHeadOid as String?);
    }
    if (data.containsKey('mergeMethod')) {
      final l$mergeMethod = data['mergeMethod'];
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : fromJson$Enum$PullRequestMergeMethod((l$mergeMethod as String));
    }
    if (data.containsKey('authorEmail')) {
      final l$authorEmail = data['authorEmail'];
      result$data['authorEmail'] = (l$authorEmail as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$MergePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String? get commitHeadline => (_$data['commitHeadline'] as String?);
  String? get commitBody => (_$data['commitBody'] as String?);
  String? get expectedHeadOid => (_$data['expectedHeadOid'] as String?);
  Enum$PullRequestMergeMethod? get mergeMethod =>
      (_$data['mergeMethod'] as Enum$PullRequestMergeMethod?);
  String? get authorEmail => (_$data['authorEmail'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('commitHeadline')) {
      final l$commitHeadline = commitHeadline;
      result$data['commitHeadline'] = l$commitHeadline;
    }
    if (_$data.containsKey('commitBody')) {
      final l$commitBody = commitBody;
      result$data['commitBody'] = l$commitBody;
    }
    if (_$data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = expectedHeadOid;
      result$data['expectedHeadOid'] = l$expectedHeadOid;
    }
    if (_$data.containsKey('mergeMethod')) {
      final l$mergeMethod = mergeMethod;
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : toJson$Enum$PullRequestMergeMethod(l$mergeMethod);
    }
    if (_$data.containsKey('authorEmail')) {
      final l$authorEmail = authorEmail;
      result$data['authorEmail'] = l$authorEmail;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$MergePullRequestInput<Input$MergePullRequestInput>
      get copyWith => CopyWith$Input$MergePullRequestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergePullRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$commitHeadline = commitHeadline;
    final lOther$commitHeadline = other.commitHeadline;
    if (_$data.containsKey('commitHeadline') !=
        other._$data.containsKey('commitHeadline')) {
      return false;
    }
    if (l$commitHeadline != lOther$commitHeadline) {
      return false;
    }
    final l$commitBody = commitBody;
    final lOther$commitBody = other.commitBody;
    if (_$data.containsKey('commitBody') !=
        other._$data.containsKey('commitBody')) {
      return false;
    }
    if (l$commitBody != lOther$commitBody) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (_$data.containsKey('expectedHeadOid') !=
        other._$data.containsKey('expectedHeadOid')) {
      return false;
    }
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    final l$mergeMethod = mergeMethod;
    final lOther$mergeMethod = other.mergeMethod;
    if (_$data.containsKey('mergeMethod') !=
        other._$data.containsKey('mergeMethod')) {
      return false;
    }
    if (l$mergeMethod != lOther$mergeMethod) {
      return false;
    }
    final l$authorEmail = authorEmail;
    final lOther$authorEmail = other.authorEmail;
    if (_$data.containsKey('authorEmail') !=
        other._$data.containsKey('authorEmail')) {
      return false;
    }
    if (l$authorEmail != lOther$authorEmail) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$commitHeadline = commitHeadline;
    final l$commitBody = commitBody;
    final l$expectedHeadOid = expectedHeadOid;
    final l$mergeMethod = mergeMethod;
    final l$authorEmail = authorEmail;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      _$data.containsKey('commitHeadline') ? l$commitHeadline : const {},
      _$data.containsKey('commitBody') ? l$commitBody : const {},
      _$data.containsKey('expectedHeadOid') ? l$expectedHeadOid : const {},
      _$data.containsKey('mergeMethod') ? l$mergeMethod : const {},
      _$data.containsKey('authorEmail') ? l$authorEmail : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergePullRequestInput<TRes> {
  factory CopyWith$Input$MergePullRequestInput(
    Input$MergePullRequestInput instance,
    TRes Function(Input$MergePullRequestInput) then,
  ) = _CopyWithImpl$Input$MergePullRequestInput;

  factory CopyWith$Input$MergePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergePullRequestInput;

  TRes call({
    String? pullRequestId,
    String? commitHeadline,
    String? commitBody,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$MergePullRequestInput<TRes>
    implements CopyWith$Input$MergePullRequestInput<TRes> {
  _CopyWithImpl$Input$MergePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$MergePullRequestInput _instance;

  final TRes Function(Input$MergePullRequestInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? commitHeadline = _undefined,
    Object? commitBody = _undefined,
    Object? expectedHeadOid = _undefined,
    Object? mergeMethod = _undefined,
    Object? authorEmail = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$MergePullRequestInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (commitHeadline != _undefined)
          'commitHeadline': (commitHeadline as String?),
        if (commitBody != _undefined) 'commitBody': (commitBody as String?),
        if (expectedHeadOid != _undefined)
          'expectedHeadOid': (expectedHeadOid as String?),
        if (mergeMethod != _undefined)
          'mergeMethod': (mergeMethod as Enum$PullRequestMergeMethod?),
        if (authorEmail != _undefined) 'authorEmail': (authorEmail as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$MergePullRequestInput<TRes>
    implements CopyWith$Input$MergePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$MergePullRequestInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? commitHeadline,
    String? commitBody,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$MilestoneOrder {
  factory Input$MilestoneOrder({
    required Enum$MilestoneOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$MilestoneOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$MilestoneOrder._(this._$data);

  factory Input$MilestoneOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$MilestoneOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$MilestoneOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$MilestoneOrderField get field =>
      (_$data['field'] as Enum$MilestoneOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$MilestoneOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$MilestoneOrder<Input$MilestoneOrder> get copyWith =>
      CopyWith$Input$MilestoneOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MilestoneOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$MilestoneOrder<TRes> {
  factory CopyWith$Input$MilestoneOrder(
    Input$MilestoneOrder instance,
    TRes Function(Input$MilestoneOrder) then,
  ) = _CopyWithImpl$Input$MilestoneOrder;

  factory CopyWith$Input$MilestoneOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$MilestoneOrder;

  TRes call({
    Enum$MilestoneOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$MilestoneOrder<TRes>
    implements CopyWith$Input$MilestoneOrder<TRes> {
  _CopyWithImpl$Input$MilestoneOrder(
    this._instance,
    this._then,
  );

  final Input$MilestoneOrder _instance;

  final TRes Function(Input$MilestoneOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$MilestoneOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$MilestoneOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$MilestoneOrder<TRes>
    implements CopyWith$Input$MilestoneOrder<TRes> {
  _CopyWithStubImpl$Input$MilestoneOrder(this._res);

  TRes _res;

  call({
    Enum$MilestoneOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$MinimizeCommentInput {
  factory Input$MinimizeCommentInput({
    required String subjectId,
    required Enum$ReportedContentClassifiers classifier,
    String? clientMutationId,
  }) =>
      Input$MinimizeCommentInput._({
        r'subjectId': subjectId,
        r'classifier': classifier,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$MinimizeCommentInput._(this._$data);

  factory Input$MinimizeCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    final l$classifier = data['classifier'];
    result$data['classifier'] =
        fromJson$Enum$ReportedContentClassifiers((l$classifier as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$MinimizeCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get subjectId => (_$data['subjectId'] as String);
  Enum$ReportedContentClassifiers get classifier =>
      (_$data['classifier'] as Enum$ReportedContentClassifiers);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    final l$classifier = classifier;
    result$data['classifier'] =
        toJson$Enum$ReportedContentClassifiers(l$classifier);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$MinimizeCommentInput<Input$MinimizeCommentInput>
      get copyWith => CopyWith$Input$MinimizeCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MinimizeCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    final l$classifier = classifier;
    final lOther$classifier = other.classifier;
    if (l$classifier != lOther$classifier) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subjectId = subjectId;
    final l$classifier = classifier;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$subjectId,
      l$classifier,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MinimizeCommentInput<TRes> {
  factory CopyWith$Input$MinimizeCommentInput(
    Input$MinimizeCommentInput instance,
    TRes Function(Input$MinimizeCommentInput) then,
  ) = _CopyWithImpl$Input$MinimizeCommentInput;

  factory CopyWith$Input$MinimizeCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MinimizeCommentInput;

  TRes call({
    String? subjectId,
    Enum$ReportedContentClassifiers? classifier,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$MinimizeCommentInput<TRes>
    implements CopyWith$Input$MinimizeCommentInput<TRes> {
  _CopyWithImpl$Input$MinimizeCommentInput(
    this._instance,
    this._then,
  );

  final Input$MinimizeCommentInput _instance;

  final TRes Function(Input$MinimizeCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? subjectId = _undefined,
    Object? classifier = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$MinimizeCommentInput._({
        ..._instance._$data,
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
        if (classifier != _undefined && classifier != null)
          'classifier': (classifier as Enum$ReportedContentClassifiers),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$MinimizeCommentInput<TRes>
    implements CopyWith$Input$MinimizeCommentInput<TRes> {
  _CopyWithStubImpl$Input$MinimizeCommentInput(this._res);

  TRes _res;

  call({
    String? subjectId,
    Enum$ReportedContentClassifiers? classifier,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$MoveProjectCardInput {
  factory Input$MoveProjectCardInput({
    required String cardId,
    required String columnId,
    String? afterCardId,
    String? clientMutationId,
  }) =>
      Input$MoveProjectCardInput._({
        r'cardId': cardId,
        r'columnId': columnId,
        if (afterCardId != null) r'afterCardId': afterCardId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$MoveProjectCardInput._(this._$data);

  factory Input$MoveProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$cardId = data['cardId'];
    result$data['cardId'] = (l$cardId as String);
    final l$columnId = data['columnId'];
    result$data['columnId'] = (l$columnId as String);
    if (data.containsKey('afterCardId')) {
      final l$afterCardId = data['afterCardId'];
      result$data['afterCardId'] = (l$afterCardId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$MoveProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get cardId => (_$data['cardId'] as String);
  String get columnId => (_$data['columnId'] as String);
  String? get afterCardId => (_$data['afterCardId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$cardId = cardId;
    result$data['cardId'] = l$cardId;
    final l$columnId = columnId;
    result$data['columnId'] = l$columnId;
    if (_$data.containsKey('afterCardId')) {
      final l$afterCardId = afterCardId;
      result$data['afterCardId'] = l$afterCardId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$MoveProjectCardInput<Input$MoveProjectCardInput>
      get copyWith => CopyWith$Input$MoveProjectCardInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MoveProjectCardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$cardId = cardId;
    final lOther$cardId = other.cardId;
    if (l$cardId != lOther$cardId) {
      return false;
    }
    final l$columnId = columnId;
    final lOther$columnId = other.columnId;
    if (l$columnId != lOther$columnId) {
      return false;
    }
    final l$afterCardId = afterCardId;
    final lOther$afterCardId = other.afterCardId;
    if (_$data.containsKey('afterCardId') !=
        other._$data.containsKey('afterCardId')) {
      return false;
    }
    if (l$afterCardId != lOther$afterCardId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$cardId = cardId;
    final l$columnId = columnId;
    final l$afterCardId = afterCardId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$cardId,
      l$columnId,
      _$data.containsKey('afterCardId') ? l$afterCardId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MoveProjectCardInput<TRes> {
  factory CopyWith$Input$MoveProjectCardInput(
    Input$MoveProjectCardInput instance,
    TRes Function(Input$MoveProjectCardInput) then,
  ) = _CopyWithImpl$Input$MoveProjectCardInput;

  factory CopyWith$Input$MoveProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MoveProjectCardInput;

  TRes call({
    String? cardId,
    String? columnId,
    String? afterCardId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$MoveProjectCardInput<TRes>
    implements CopyWith$Input$MoveProjectCardInput<TRes> {
  _CopyWithImpl$Input$MoveProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$MoveProjectCardInput _instance;

  final TRes Function(Input$MoveProjectCardInput) _then;

  static const _undefined = {};

  TRes call({
    Object? cardId = _undefined,
    Object? columnId = _undefined,
    Object? afterCardId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$MoveProjectCardInput._({
        ..._instance._$data,
        if (cardId != _undefined && cardId != null)
          'cardId': (cardId as String),
        if (columnId != _undefined && columnId != null)
          'columnId': (columnId as String),
        if (afterCardId != _undefined) 'afterCardId': (afterCardId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$MoveProjectCardInput<TRes>
    implements CopyWith$Input$MoveProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$MoveProjectCardInput(this._res);

  TRes _res;

  call({
    String? cardId,
    String? columnId,
    String? afterCardId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$MoveProjectColumnInput {
  factory Input$MoveProjectColumnInput({
    required String columnId,
    String? afterColumnId,
    String? clientMutationId,
  }) =>
      Input$MoveProjectColumnInput._({
        r'columnId': columnId,
        if (afterColumnId != null) r'afterColumnId': afterColumnId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$MoveProjectColumnInput._(this._$data);

  factory Input$MoveProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$columnId = data['columnId'];
    result$data['columnId'] = (l$columnId as String);
    if (data.containsKey('afterColumnId')) {
      final l$afterColumnId = data['afterColumnId'];
      result$data['afterColumnId'] = (l$afterColumnId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$MoveProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get columnId => (_$data['columnId'] as String);
  String? get afterColumnId => (_$data['afterColumnId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$columnId = columnId;
    result$data['columnId'] = l$columnId;
    if (_$data.containsKey('afterColumnId')) {
      final l$afterColumnId = afterColumnId;
      result$data['afterColumnId'] = l$afterColumnId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$MoveProjectColumnInput<Input$MoveProjectColumnInput>
      get copyWith => CopyWith$Input$MoveProjectColumnInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MoveProjectColumnInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$columnId = columnId;
    final lOther$columnId = other.columnId;
    if (l$columnId != lOther$columnId) {
      return false;
    }
    final l$afterColumnId = afterColumnId;
    final lOther$afterColumnId = other.afterColumnId;
    if (_$data.containsKey('afterColumnId') !=
        other._$data.containsKey('afterColumnId')) {
      return false;
    }
    if (l$afterColumnId != lOther$afterColumnId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$columnId = columnId;
    final l$afterColumnId = afterColumnId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$columnId,
      _$data.containsKey('afterColumnId') ? l$afterColumnId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MoveProjectColumnInput<TRes> {
  factory CopyWith$Input$MoveProjectColumnInput(
    Input$MoveProjectColumnInput instance,
    TRes Function(Input$MoveProjectColumnInput) then,
  ) = _CopyWithImpl$Input$MoveProjectColumnInput;

  factory CopyWith$Input$MoveProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MoveProjectColumnInput;

  TRes call({
    String? columnId,
    String? afterColumnId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$MoveProjectColumnInput<TRes>
    implements CopyWith$Input$MoveProjectColumnInput<TRes> {
  _CopyWithImpl$Input$MoveProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$MoveProjectColumnInput _instance;

  final TRes Function(Input$MoveProjectColumnInput) _then;

  static const _undefined = {};

  TRes call({
    Object? columnId = _undefined,
    Object? afterColumnId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$MoveProjectColumnInput._({
        ..._instance._$data,
        if (columnId != _undefined && columnId != null)
          'columnId': (columnId as String),
        if (afterColumnId != _undefined)
          'afterColumnId': (afterColumnId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$MoveProjectColumnInput<TRes>
    implements CopyWith$Input$MoveProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$MoveProjectColumnInput(this._res);

  TRes _res;

  call({
    String? columnId,
    String? afterColumnId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$OrganizationOrder {
  factory Input$OrganizationOrder({
    required Enum$OrganizationOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$OrganizationOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$OrganizationOrder._(this._$data);

  factory Input$OrganizationOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$OrganizationOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$OrganizationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrganizationOrderField get field =>
      (_$data['field'] as Enum$OrganizationOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$OrganizationOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$OrganizationOrder<Input$OrganizationOrder> get copyWith =>
      CopyWith$Input$OrganizationOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OrganizationOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$OrganizationOrder<TRes> {
  factory CopyWith$Input$OrganizationOrder(
    Input$OrganizationOrder instance,
    TRes Function(Input$OrganizationOrder) then,
  ) = _CopyWithImpl$Input$OrganizationOrder;

  factory CopyWith$Input$OrganizationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$OrganizationOrder;

  TRes call({
    Enum$OrganizationOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$OrganizationOrder<TRes>
    implements CopyWith$Input$OrganizationOrder<TRes> {
  _CopyWithImpl$Input$OrganizationOrder(
    this._instance,
    this._then,
  );

  final Input$OrganizationOrder _instance;

  final TRes Function(Input$OrganizationOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$OrganizationOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$OrganizationOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$OrganizationOrder<TRes>
    implements CopyWith$Input$OrganizationOrder<TRes> {
  _CopyWithStubImpl$Input$OrganizationOrder(this._res);

  TRes _res;

  call({
    Enum$OrganizationOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$OrgEnterpriseOwnerOrder {
  factory Input$OrgEnterpriseOwnerOrder({
    required Enum$OrgEnterpriseOwnerOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$OrgEnterpriseOwnerOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$OrgEnterpriseOwnerOrder._(this._$data);

  factory Input$OrgEnterpriseOwnerOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$OrgEnterpriseOwnerOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$OrgEnterpriseOwnerOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrgEnterpriseOwnerOrderField get field =>
      (_$data['field'] as Enum$OrgEnterpriseOwnerOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$OrgEnterpriseOwnerOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$OrgEnterpriseOwnerOrder<Input$OrgEnterpriseOwnerOrder>
      get copyWith => CopyWith$Input$OrgEnterpriseOwnerOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OrgEnterpriseOwnerOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$OrgEnterpriseOwnerOrder<TRes> {
  factory CopyWith$Input$OrgEnterpriseOwnerOrder(
    Input$OrgEnterpriseOwnerOrder instance,
    TRes Function(Input$OrgEnterpriseOwnerOrder) then,
  ) = _CopyWithImpl$Input$OrgEnterpriseOwnerOrder;

  factory CopyWith$Input$OrgEnterpriseOwnerOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$OrgEnterpriseOwnerOrder;

  TRes call({
    Enum$OrgEnterpriseOwnerOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$OrgEnterpriseOwnerOrder<TRes>
    implements CopyWith$Input$OrgEnterpriseOwnerOrder<TRes> {
  _CopyWithImpl$Input$OrgEnterpriseOwnerOrder(
    this._instance,
    this._then,
  );

  final Input$OrgEnterpriseOwnerOrder _instance;

  final TRes Function(Input$OrgEnterpriseOwnerOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$OrgEnterpriseOwnerOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$OrgEnterpriseOwnerOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$OrgEnterpriseOwnerOrder<TRes>
    implements CopyWith$Input$OrgEnterpriseOwnerOrder<TRes> {
  _CopyWithStubImpl$Input$OrgEnterpriseOwnerOrder(this._res);

  TRes _res;

  call({
    Enum$OrgEnterpriseOwnerOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$PackageFileOrder {
  factory Input$PackageFileOrder({
    Enum$PackageFileOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      Input$PackageFileOrder._({
        if (field != null) r'field': field,
        if (direction != null) r'direction': direction,
      });

  Input$PackageFileOrder._(this._$data);

  factory Input$PackageFileOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$PackageFileOrderField((l$field as String));
    }
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    return Input$PackageFileOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PackageFileOrderField? get field =>
      (_$data['field'] as Enum$PackageFileOrderField?);
  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] =
          l$field == null ? null : toJson$Enum$PackageFileOrderField(l$field);
    }
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    return result$data;
  }

  CopyWith$Input$PackageFileOrder<Input$PackageFileOrder> get copyWith =>
      CopyWith$Input$PackageFileOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PackageFileOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      _$data.containsKey('field') ? l$field : const {},
      _$data.containsKey('direction') ? l$direction : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageFileOrder<TRes> {
  factory CopyWith$Input$PackageFileOrder(
    Input$PackageFileOrder instance,
    TRes Function(Input$PackageFileOrder) then,
  ) = _CopyWithImpl$Input$PackageFileOrder;

  factory CopyWith$Input$PackageFileOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageFileOrder;

  TRes call({
    Enum$PackageFileOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$PackageFileOrder<TRes>
    implements CopyWith$Input$PackageFileOrder<TRes> {
  _CopyWithImpl$Input$PackageFileOrder(
    this._instance,
    this._then,
  );

  final Input$PackageFileOrder _instance;

  final TRes Function(Input$PackageFileOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$PackageFileOrder._({
        ..._instance._$data,
        if (field != _undefined)
          'field': (field as Enum$PackageFileOrderField?),
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
      }));
}

class _CopyWithStubImpl$Input$PackageFileOrder<TRes>
    implements CopyWith$Input$PackageFileOrder<TRes> {
  _CopyWithStubImpl$Input$PackageFileOrder(this._res);

  TRes _res;

  call({
    Enum$PackageFileOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$PackageOrder {
  factory Input$PackageOrder({
    Enum$PackageOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      Input$PackageOrder._({
        if (field != null) r'field': field,
        if (direction != null) r'direction': direction,
      });

  Input$PackageOrder._(this._$data);

  factory Input$PackageOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$PackageOrderField((l$field as String));
    }
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    return Input$PackageOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PackageOrderField? get field =>
      (_$data['field'] as Enum$PackageOrderField?);
  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] =
          l$field == null ? null : toJson$Enum$PackageOrderField(l$field);
    }
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    return result$data;
  }

  CopyWith$Input$PackageOrder<Input$PackageOrder> get copyWith =>
      CopyWith$Input$PackageOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PackageOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      _$data.containsKey('field') ? l$field : const {},
      _$data.containsKey('direction') ? l$direction : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageOrder<TRes> {
  factory CopyWith$Input$PackageOrder(
    Input$PackageOrder instance,
    TRes Function(Input$PackageOrder) then,
  ) = _CopyWithImpl$Input$PackageOrder;

  factory CopyWith$Input$PackageOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageOrder;

  TRes call({
    Enum$PackageOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$PackageOrder<TRes>
    implements CopyWith$Input$PackageOrder<TRes> {
  _CopyWithImpl$Input$PackageOrder(
    this._instance,
    this._then,
  );

  final Input$PackageOrder _instance;

  final TRes Function(Input$PackageOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$PackageOrder._({
        ..._instance._$data,
        if (field != _undefined) 'field': (field as Enum$PackageOrderField?),
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
      }));
}

class _CopyWithStubImpl$Input$PackageOrder<TRes>
    implements CopyWith$Input$PackageOrder<TRes> {
  _CopyWithStubImpl$Input$PackageOrder(this._res);

  TRes _res;

  call({
    Enum$PackageOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$PackageVersionOrder {
  factory Input$PackageVersionOrder({
    Enum$PackageVersionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      Input$PackageVersionOrder._({
        if (field != null) r'field': field,
        if (direction != null) r'direction': direction,
      });

  Input$PackageVersionOrder._(this._$data);

  factory Input$PackageVersionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$PackageVersionOrderField((l$field as String));
    }
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    return Input$PackageVersionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PackageVersionOrderField? get field =>
      (_$data['field'] as Enum$PackageVersionOrderField?);
  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] = l$field == null
          ? null
          : toJson$Enum$PackageVersionOrderField(l$field);
    }
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    return result$data;
  }

  CopyWith$Input$PackageVersionOrder<Input$PackageVersionOrder> get copyWith =>
      CopyWith$Input$PackageVersionOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PackageVersionOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      _$data.containsKey('field') ? l$field : const {},
      _$data.containsKey('direction') ? l$direction : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageVersionOrder<TRes> {
  factory CopyWith$Input$PackageVersionOrder(
    Input$PackageVersionOrder instance,
    TRes Function(Input$PackageVersionOrder) then,
  ) = _CopyWithImpl$Input$PackageVersionOrder;

  factory CopyWith$Input$PackageVersionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageVersionOrder;

  TRes call({
    Enum$PackageVersionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$PackageVersionOrder<TRes>
    implements CopyWith$Input$PackageVersionOrder<TRes> {
  _CopyWithImpl$Input$PackageVersionOrder(
    this._instance,
    this._then,
  );

  final Input$PackageVersionOrder _instance;

  final TRes Function(Input$PackageVersionOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$PackageVersionOrder._({
        ..._instance._$data,
        if (field != _undefined)
          'field': (field as Enum$PackageVersionOrderField?),
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
      }));
}

class _CopyWithStubImpl$Input$PackageVersionOrder<TRes>
    implements CopyWith$Input$PackageVersionOrder<TRes> {
  _CopyWithStubImpl$Input$PackageVersionOrder(this._res);

  TRes _res;

  call({
    Enum$PackageVersionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$PinIssueInput {
  factory Input$PinIssueInput({
    required String issueId,
    String? clientMutationId,
  }) =>
      Input$PinIssueInput._({
        r'issueId': issueId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$PinIssueInput._(this._$data);

  factory Input$PinIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$PinIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get issueId => (_$data['issueId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$PinIssueInput<Input$PinIssueInput> get copyWith =>
      CopyWith$Input$PinIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PinIssueInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$issueId = issueId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$issueId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$PinIssueInput<TRes> {
  factory CopyWith$Input$PinIssueInput(
    Input$PinIssueInput instance,
    TRes Function(Input$PinIssueInput) then,
  ) = _CopyWithImpl$Input$PinIssueInput;

  factory CopyWith$Input$PinIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PinIssueInput;

  TRes call({
    String? issueId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$PinIssueInput<TRes>
    implements CopyWith$Input$PinIssueInput<TRes> {
  _CopyWithImpl$Input$PinIssueInput(
    this._instance,
    this._then,
  );

  final Input$PinIssueInput _instance;

  final TRes Function(Input$PinIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? issueId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$PinIssueInput._({
        ..._instance._$data,
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$PinIssueInput<TRes>
    implements CopyWith$Input$PinIssueInput<TRes> {
  _CopyWithStubImpl$Input$PinIssueInput(this._res);

  TRes _res;

  call({
    String? issueId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ProjectOrder {
  factory Input$ProjectOrder({
    required Enum$ProjectOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectOrder._(this._$data);

  factory Input$ProjectOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$ProjectOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectOrderField get field =>
      (_$data['field'] as Enum$ProjectOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectOrder<Input$ProjectOrder> get copyWith =>
      CopyWith$Input$ProjectOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectOrder<TRes> {
  factory CopyWith$Input$ProjectOrder(
    Input$ProjectOrder instance,
    TRes Function(Input$ProjectOrder) then,
  ) = _CopyWithImpl$Input$ProjectOrder;

  factory CopyWith$Input$ProjectOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectOrder;

  TRes call({
    Enum$ProjectOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectOrder<TRes>
    implements CopyWith$Input$ProjectOrder<TRes> {
  _CopyWithImpl$Input$ProjectOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectOrder _instance;

  final TRes Function(Input$ProjectOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectOrder<TRes>
    implements CopyWith$Input$ProjectOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2FieldOrder {
  factory Input$ProjectV2FieldOrder({
    required Enum$ProjectV2FieldOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2FieldOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2FieldOrder._(this._$data);

  factory Input$ProjectV2FieldOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2FieldOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2FieldOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2FieldOrderField get field =>
      (_$data['field'] as Enum$ProjectV2FieldOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2FieldOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2FieldOrder<Input$ProjectV2FieldOrder> get copyWith =>
      CopyWith$Input$ProjectV2FieldOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2FieldOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2FieldOrder<TRes> {
  factory CopyWith$Input$ProjectV2FieldOrder(
    Input$ProjectV2FieldOrder instance,
    TRes Function(Input$ProjectV2FieldOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2FieldOrder;

  factory CopyWith$Input$ProjectV2FieldOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2FieldOrder;

  TRes call({
    Enum$ProjectV2FieldOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2FieldOrder<TRes>
    implements CopyWith$Input$ProjectV2FieldOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2FieldOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2FieldOrder _instance;

  final TRes Function(Input$ProjectV2FieldOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2FieldOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2FieldOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2FieldOrder<TRes>
    implements CopyWith$Input$ProjectV2FieldOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2FieldOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectV2FieldOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2FieldValue {
  factory Input$ProjectV2FieldValue({
    String? text,
    double? number,
    String? date,
    String? singleSelectOptionId,
    String? iterationId,
  }) =>
      Input$ProjectV2FieldValue._({
        if (text != null) r'text': text,
        if (number != null) r'number': number,
        if (date != null) r'date': date,
        if (singleSelectOptionId != null)
          r'singleSelectOptionId': singleSelectOptionId,
        if (iterationId != null) r'iterationId': iterationId,
      });

  Input$ProjectV2FieldValue._(this._$data);

  factory Input$ProjectV2FieldValue.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('text')) {
      final l$text = data['text'];
      result$data['text'] = (l$text as String?);
    }
    if (data.containsKey('number')) {
      final l$number = data['number'];
      result$data['number'] = (l$number as num?)?.toDouble();
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = (l$date as String?);
    }
    if (data.containsKey('singleSelectOptionId')) {
      final l$singleSelectOptionId = data['singleSelectOptionId'];
      result$data['singleSelectOptionId'] = (l$singleSelectOptionId as String?);
    }
    if (data.containsKey('iterationId')) {
      final l$iterationId = data['iterationId'];
      result$data['iterationId'] = (l$iterationId as String?);
    }
    return Input$ProjectV2FieldValue._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get text => (_$data['text'] as String?);
  double? get number => (_$data['number'] as double?);
  String? get date => (_$data['date'] as String?);
  String? get singleSelectOptionId =>
      (_$data['singleSelectOptionId'] as String?);
  String? get iterationId => (_$data['iterationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('text')) {
      final l$text = text;
      result$data['text'] = l$text;
    }
    if (_$data.containsKey('number')) {
      final l$number = number;
      result$data['number'] = l$number;
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date;
    }
    if (_$data.containsKey('singleSelectOptionId')) {
      final l$singleSelectOptionId = singleSelectOptionId;
      result$data['singleSelectOptionId'] = l$singleSelectOptionId;
    }
    if (_$data.containsKey('iterationId')) {
      final l$iterationId = iterationId;
      result$data['iterationId'] = l$iterationId;
    }
    return result$data;
  }

  CopyWith$Input$ProjectV2FieldValue<Input$ProjectV2FieldValue> get copyWith =>
      CopyWith$Input$ProjectV2FieldValue(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2FieldValue) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$text = text;
    final lOther$text = other.text;
    if (_$data.containsKey('text') != other._$data.containsKey('text')) {
      return false;
    }
    if (l$text != lOther$text) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (_$data.containsKey('number') != other._$data.containsKey('number')) {
      return false;
    }
    if (l$number != lOther$number) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$singleSelectOptionId = singleSelectOptionId;
    final lOther$singleSelectOptionId = other.singleSelectOptionId;
    if (_$data.containsKey('singleSelectOptionId') !=
        other._$data.containsKey('singleSelectOptionId')) {
      return false;
    }
    if (l$singleSelectOptionId != lOther$singleSelectOptionId) {
      return false;
    }
    final l$iterationId = iterationId;
    final lOther$iterationId = other.iterationId;
    if (_$data.containsKey('iterationId') !=
        other._$data.containsKey('iterationId')) {
      return false;
    }
    if (l$iterationId != lOther$iterationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$text = text;
    final l$number = number;
    final l$date = date;
    final l$singleSelectOptionId = singleSelectOptionId;
    final l$iterationId = iterationId;
    return Object.hashAll([
      _$data.containsKey('text') ? l$text : const {},
      _$data.containsKey('number') ? l$number : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('singleSelectOptionId')
          ? l$singleSelectOptionId
          : const {},
      _$data.containsKey('iterationId') ? l$iterationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2FieldValue<TRes> {
  factory CopyWith$Input$ProjectV2FieldValue(
    Input$ProjectV2FieldValue instance,
    TRes Function(Input$ProjectV2FieldValue) then,
  ) = _CopyWithImpl$Input$ProjectV2FieldValue;

  factory CopyWith$Input$ProjectV2FieldValue.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2FieldValue;

  TRes call({
    String? text,
    double? number,
    String? date,
    String? singleSelectOptionId,
    String? iterationId,
  });
}

class _CopyWithImpl$Input$ProjectV2FieldValue<TRes>
    implements CopyWith$Input$ProjectV2FieldValue<TRes> {
  _CopyWithImpl$Input$ProjectV2FieldValue(
    this._instance,
    this._then,
  );

  final Input$ProjectV2FieldValue _instance;

  final TRes Function(Input$ProjectV2FieldValue) _then;

  static const _undefined = {};

  TRes call({
    Object? text = _undefined,
    Object? number = _undefined,
    Object? date = _undefined,
    Object? singleSelectOptionId = _undefined,
    Object? iterationId = _undefined,
  }) =>
      _then(Input$ProjectV2FieldValue._({
        ..._instance._$data,
        if (text != _undefined) 'text': (text as String?),
        if (number != _undefined) 'number': (number as double?),
        if (date != _undefined) 'date': (date as String?),
        if (singleSelectOptionId != _undefined)
          'singleSelectOptionId': (singleSelectOptionId as String?),
        if (iterationId != _undefined) 'iterationId': (iterationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2FieldValue<TRes>
    implements CopyWith$Input$ProjectV2FieldValue<TRes> {
  _CopyWithStubImpl$Input$ProjectV2FieldValue(this._res);

  TRes _res;

  call({
    String? text,
    double? number,
    String? date,
    String? singleSelectOptionId,
    String? iterationId,
  }) =>
      _res;
}

class Input$ProjectV2Filters {
  factory Input$ProjectV2Filters({Enum$ProjectV2State? state}) =>
      Input$ProjectV2Filters._({
        if (state != null) r'state': state,
      });

  Input$ProjectV2Filters._(this._$data);

  factory Input$ProjectV2Filters.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$ProjectV2State((l$state as String));
    }
    return Input$ProjectV2Filters._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2State? get state => (_$data['state'] as Enum$ProjectV2State?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$ProjectV2State(l$state);
    }
    return result$data;
  }

  CopyWith$Input$ProjectV2Filters<Input$ProjectV2Filters> get copyWith =>
      CopyWith$Input$ProjectV2Filters(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2Filters) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$state = state;
    return Object.hashAll([_$data.containsKey('state') ? l$state : const {}]);
  }
}

abstract class CopyWith$Input$ProjectV2Filters<TRes> {
  factory CopyWith$Input$ProjectV2Filters(
    Input$ProjectV2Filters instance,
    TRes Function(Input$ProjectV2Filters) then,
  ) = _CopyWithImpl$Input$ProjectV2Filters;

  factory CopyWith$Input$ProjectV2Filters.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2Filters;

  TRes call({Enum$ProjectV2State? state});
}

class _CopyWithImpl$Input$ProjectV2Filters<TRes>
    implements CopyWith$Input$ProjectV2Filters<TRes> {
  _CopyWithImpl$Input$ProjectV2Filters(
    this._instance,
    this._then,
  );

  final Input$ProjectV2Filters _instance;

  final TRes Function(Input$ProjectV2Filters) _then;

  static const _undefined = {};

  TRes call({Object? state = _undefined}) => _then(Input$ProjectV2Filters._({
        ..._instance._$data,
        if (state != _undefined) 'state': (state as Enum$ProjectV2State?),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2Filters<TRes>
    implements CopyWith$Input$ProjectV2Filters<TRes> {
  _CopyWithStubImpl$Input$ProjectV2Filters(this._res);

  TRes _res;

  call({Enum$ProjectV2State? state}) => _res;
}

class Input$ProjectV2ItemFieldValueOrder {
  factory Input$ProjectV2ItemFieldValueOrder({
    required Enum$ProjectV2ItemFieldValueOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2ItemFieldValueOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2ItemFieldValueOrder._(this._$data);

  factory Input$ProjectV2ItemFieldValueOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2ItemFieldValueOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2ItemFieldValueOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2ItemFieldValueOrderField get field =>
      (_$data['field'] as Enum$ProjectV2ItemFieldValueOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$ProjectV2ItemFieldValueOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2ItemFieldValueOrder<
          Input$ProjectV2ItemFieldValueOrder>
      get copyWith => CopyWith$Input$ProjectV2ItemFieldValueOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2ItemFieldValueOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2ItemFieldValueOrder<TRes> {
  factory CopyWith$Input$ProjectV2ItemFieldValueOrder(
    Input$ProjectV2ItemFieldValueOrder instance,
    TRes Function(Input$ProjectV2ItemFieldValueOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2ItemFieldValueOrder;

  factory CopyWith$Input$ProjectV2ItemFieldValueOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2ItemFieldValueOrder;

  TRes call({
    Enum$ProjectV2ItemFieldValueOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2ItemFieldValueOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemFieldValueOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2ItemFieldValueOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2ItemFieldValueOrder _instance;

  final TRes Function(Input$ProjectV2ItemFieldValueOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2ItemFieldValueOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2ItemFieldValueOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2ItemFieldValueOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemFieldValueOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2ItemFieldValueOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectV2ItemFieldValueOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2ItemOrder {
  factory Input$ProjectV2ItemOrder({
    required Enum$ProjectV2ItemOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2ItemOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2ItemOrder._(this._$data);

  factory Input$ProjectV2ItemOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2ItemOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2ItemOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2ItemOrderField get field =>
      (_$data['field'] as Enum$ProjectV2ItemOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2ItemOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2ItemOrder<Input$ProjectV2ItemOrder> get copyWith =>
      CopyWith$Input$ProjectV2ItemOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2ItemOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2ItemOrder<TRes> {
  factory CopyWith$Input$ProjectV2ItemOrder(
    Input$ProjectV2ItemOrder instance,
    TRes Function(Input$ProjectV2ItemOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2ItemOrder;

  factory CopyWith$Input$ProjectV2ItemOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2ItemOrder;

  TRes call({
    Enum$ProjectV2ItemOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2ItemOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2ItemOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2ItemOrder _instance;

  final TRes Function(Input$ProjectV2ItemOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2ItemOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2ItemOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2ItemOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2ItemOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectV2ItemOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2Order {
  factory Input$ProjectV2Order({
    required Enum$ProjectV2OrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2Order._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2Order._(this._$data);

  factory Input$ProjectV2Order.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2OrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2Order._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2OrderField get field =>
      (_$data['field'] as Enum$ProjectV2OrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2OrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2Order<Input$ProjectV2Order> get copyWith =>
      CopyWith$Input$ProjectV2Order(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2Order) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2Order<TRes> {
  factory CopyWith$Input$ProjectV2Order(
    Input$ProjectV2Order instance,
    TRes Function(Input$ProjectV2Order) then,
  ) = _CopyWithImpl$Input$ProjectV2Order;

  factory CopyWith$Input$ProjectV2Order.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2Order;

  TRes call({
    Enum$ProjectV2OrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2Order<TRes>
    implements CopyWith$Input$ProjectV2Order<TRes> {
  _CopyWithImpl$Input$ProjectV2Order(
    this._instance,
    this._then,
  );

  final Input$ProjectV2Order _instance;

  final TRes Function(Input$ProjectV2Order) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2Order._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2OrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2Order<TRes>
    implements CopyWith$Input$ProjectV2Order<TRes> {
  _CopyWithStubImpl$Input$ProjectV2Order(this._res);

  TRes _res;

  call({
    Enum$ProjectV2OrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2ViewOrder {
  factory Input$ProjectV2ViewOrder({
    required Enum$ProjectV2ViewOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2ViewOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2ViewOrder._(this._$data);

  factory Input$ProjectV2ViewOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2ViewOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2ViewOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2ViewOrderField get field =>
      (_$data['field'] as Enum$ProjectV2ViewOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2ViewOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2ViewOrder<Input$ProjectV2ViewOrder> get copyWith =>
      CopyWith$Input$ProjectV2ViewOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2ViewOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2ViewOrder<TRes> {
  factory CopyWith$Input$ProjectV2ViewOrder(
    Input$ProjectV2ViewOrder instance,
    TRes Function(Input$ProjectV2ViewOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2ViewOrder;

  factory CopyWith$Input$ProjectV2ViewOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2ViewOrder;

  TRes call({
    Enum$ProjectV2ViewOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2ViewOrder<TRes>
    implements CopyWith$Input$ProjectV2ViewOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2ViewOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2ViewOrder _instance;

  final TRes Function(Input$ProjectV2ViewOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2ViewOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2ViewOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2ViewOrder<TRes>
    implements CopyWith$Input$ProjectV2ViewOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2ViewOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectV2ViewOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$PullRequestOrder {
  factory Input$PullRequestOrder({
    required Enum$PullRequestOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$PullRequestOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$PullRequestOrder._(this._$data);

  factory Input$PullRequestOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$PullRequestOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$PullRequestOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PullRequestOrderField get field =>
      (_$data['field'] as Enum$PullRequestOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$PullRequestOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$PullRequestOrder<Input$PullRequestOrder> get copyWith =>
      CopyWith$Input$PullRequestOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PullRequestOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$PullRequestOrder<TRes> {
  factory CopyWith$Input$PullRequestOrder(
    Input$PullRequestOrder instance,
    TRes Function(Input$PullRequestOrder) then,
  ) = _CopyWithImpl$Input$PullRequestOrder;

  factory CopyWith$Input$PullRequestOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PullRequestOrder;

  TRes call({
    Enum$PullRequestOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$PullRequestOrder<TRes>
    implements CopyWith$Input$PullRequestOrder<TRes> {
  _CopyWithImpl$Input$PullRequestOrder(
    this._instance,
    this._then,
  );

  final Input$PullRequestOrder _instance;

  final TRes Function(Input$PullRequestOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$PullRequestOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$PullRequestOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$PullRequestOrder<TRes>
    implements CopyWith$Input$PullRequestOrder<TRes> {
  _CopyWithStubImpl$Input$PullRequestOrder(this._res);

  TRes _res;

  call({
    Enum$PullRequestOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ReactionOrder {
  factory Input$ReactionOrder({
    required Enum$ReactionOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ReactionOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ReactionOrder._(this._$data);

  factory Input$ReactionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ReactionOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ReactionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ReactionOrderField get field =>
      (_$data['field'] as Enum$ReactionOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ReactionOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ReactionOrder<Input$ReactionOrder> get copyWith =>
      CopyWith$Input$ReactionOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReactionOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ReactionOrder<TRes> {
  factory CopyWith$Input$ReactionOrder(
    Input$ReactionOrder instance,
    TRes Function(Input$ReactionOrder) then,
  ) = _CopyWithImpl$Input$ReactionOrder;

  factory CopyWith$Input$ReactionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ReactionOrder;

  TRes call({
    Enum$ReactionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ReactionOrder<TRes>
    implements CopyWith$Input$ReactionOrder<TRes> {
  _CopyWithImpl$Input$ReactionOrder(
    this._instance,
    this._then,
  );

  final Input$ReactionOrder _instance;

  final TRes Function(Input$ReactionOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ReactionOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ReactionOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ReactionOrder<TRes>
    implements CopyWith$Input$ReactionOrder<TRes> {
  _CopyWithStubImpl$Input$ReactionOrder(this._res);

  TRes _res;

  call({
    Enum$ReactionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$RefOrder {
  factory Input$RefOrder({
    required Enum$RefOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$RefOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$RefOrder._(this._$data);

  factory Input$RefOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$RefOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$RefOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RefOrderField get field => (_$data['field'] as Enum$RefOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$RefOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$RefOrder<Input$RefOrder> get copyWith =>
      CopyWith$Input$RefOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RefOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$RefOrder<TRes> {
  factory CopyWith$Input$RefOrder(
    Input$RefOrder instance,
    TRes Function(Input$RefOrder) then,
  ) = _CopyWithImpl$Input$RefOrder;

  factory CopyWith$Input$RefOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RefOrder;

  TRes call({
    Enum$RefOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$RefOrder<TRes>
    implements CopyWith$Input$RefOrder<TRes> {
  _CopyWithImpl$Input$RefOrder(
    this._instance,
    this._then,
  );

  final Input$RefOrder _instance;

  final TRes Function(Input$RefOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$RefOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$RefOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$RefOrder<TRes>
    implements CopyWith$Input$RefOrder<TRes> {
  _CopyWithStubImpl$Input$RefOrder(this._res);

  TRes _res;

  call({
    Enum$RefOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput {
  factory Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput({
    required String enterpriseId,
    String? clientMutationId,
  }) =>
      Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._({
        r'enterpriseId': enterpriseId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._(this._$data);

  factory Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
          Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput>
      get copyWith =>
          CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
    TRes> {
  factory CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
    Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput instance,
    TRes Function(Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput)
        then,
  ) = _CopyWithImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput;

  factory CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput;

  TRes call({
    String? enterpriseId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
        TRes>
    implements
        CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
            TRes> {
  _CopyWithImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
    this._instance,
    this._then,
  );

  final Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput _instance;

  final TRes Function(
      Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
        TRes>
    implements
        CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
            TRes> {
  _CopyWithStubImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RegenerateVerifiableDomainTokenInput {
  factory Input$RegenerateVerifiableDomainTokenInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$RegenerateVerifiableDomainTokenInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RegenerateVerifiableDomainTokenInput._(this._$data);

  factory Input$RegenerateVerifiableDomainTokenInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RegenerateVerifiableDomainTokenInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RegenerateVerifiableDomainTokenInput<
          Input$RegenerateVerifiableDomainTokenInput>
      get copyWith => CopyWith$Input$RegenerateVerifiableDomainTokenInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RegenerateVerifiableDomainTokenInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RegenerateVerifiableDomainTokenInput<TRes> {
  factory CopyWith$Input$RegenerateVerifiableDomainTokenInput(
    Input$RegenerateVerifiableDomainTokenInput instance,
    TRes Function(Input$RegenerateVerifiableDomainTokenInput) then,
  ) = _CopyWithImpl$Input$RegenerateVerifiableDomainTokenInput;

  factory CopyWith$Input$RegenerateVerifiableDomainTokenInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RegenerateVerifiableDomainTokenInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RegenerateVerifiableDomainTokenInput<TRes>
    implements CopyWith$Input$RegenerateVerifiableDomainTokenInput<TRes> {
  _CopyWithImpl$Input$RegenerateVerifiableDomainTokenInput(
    this._instance,
    this._then,
  );

  final Input$RegenerateVerifiableDomainTokenInput _instance;

  final TRes Function(Input$RegenerateVerifiableDomainTokenInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RegenerateVerifiableDomainTokenInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RegenerateVerifiableDomainTokenInput<TRes>
    implements CopyWith$Input$RegenerateVerifiableDomainTokenInput<TRes> {
  _CopyWithStubImpl$Input$RegenerateVerifiableDomainTokenInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RejectDeploymentsInput {
  factory Input$RejectDeploymentsInput({
    required String workflowRunId,
    required List<String> environmentIds,
    String? comment,
    String? clientMutationId,
  }) =>
      Input$RejectDeploymentsInput._({
        r'workflowRunId': workflowRunId,
        r'environmentIds': environmentIds,
        if (comment != null) r'comment': comment,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RejectDeploymentsInput._(this._$data);

  factory Input$RejectDeploymentsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$workflowRunId = data['workflowRunId'];
    result$data['workflowRunId'] = (l$workflowRunId as String);
    final l$environmentIds = data['environmentIds'];
    result$data['environmentIds'] =
        (l$environmentIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RejectDeploymentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get workflowRunId => (_$data['workflowRunId'] as String);
  List<String> get environmentIds => (_$data['environmentIds'] as List<String>);
  String? get comment => (_$data['comment'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$workflowRunId = workflowRunId;
    result$data['workflowRunId'] = l$workflowRunId;
    final l$environmentIds = environmentIds;
    result$data['environmentIds'] = l$environmentIds.map((e) => e).toList();
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RejectDeploymentsInput<Input$RejectDeploymentsInput>
      get copyWith => CopyWith$Input$RejectDeploymentsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RejectDeploymentsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$workflowRunId = workflowRunId;
    final lOther$workflowRunId = other.workflowRunId;
    if (l$workflowRunId != lOther$workflowRunId) {
      return false;
    }
    final l$environmentIds = environmentIds;
    final lOther$environmentIds = other.environmentIds;
    if (l$environmentIds.length != lOther$environmentIds.length) {
      return false;
    }
    for (int i = 0; i < l$environmentIds.length; i++) {
      final l$environmentIds$entry = l$environmentIds[i];
      final lOther$environmentIds$entry = lOther$environmentIds[i];
      if (l$environmentIds$entry != lOther$environmentIds$entry) {
        return false;
      }
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$workflowRunId = workflowRunId;
    final l$environmentIds = environmentIds;
    final l$comment = comment;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$workflowRunId,
      Object.hashAll(l$environmentIds.map((v) => v)),
      _$data.containsKey('comment') ? l$comment : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RejectDeploymentsInput<TRes> {
  factory CopyWith$Input$RejectDeploymentsInput(
    Input$RejectDeploymentsInput instance,
    TRes Function(Input$RejectDeploymentsInput) then,
  ) = _CopyWithImpl$Input$RejectDeploymentsInput;

  factory CopyWith$Input$RejectDeploymentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RejectDeploymentsInput;

  TRes call({
    String? workflowRunId,
    List<String>? environmentIds,
    String? comment,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RejectDeploymentsInput<TRes>
    implements CopyWith$Input$RejectDeploymentsInput<TRes> {
  _CopyWithImpl$Input$RejectDeploymentsInput(
    this._instance,
    this._then,
  );

  final Input$RejectDeploymentsInput _instance;

  final TRes Function(Input$RejectDeploymentsInput) _then;

  static const _undefined = {};

  TRes call({
    Object? workflowRunId = _undefined,
    Object? environmentIds = _undefined,
    Object? comment = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RejectDeploymentsInput._({
        ..._instance._$data,
        if (workflowRunId != _undefined && workflowRunId != null)
          'workflowRunId': (workflowRunId as String),
        if (environmentIds != _undefined && environmentIds != null)
          'environmentIds': (environmentIds as List<String>),
        if (comment != _undefined) 'comment': (comment as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RejectDeploymentsInput<TRes>
    implements CopyWith$Input$RejectDeploymentsInput<TRes> {
  _CopyWithStubImpl$Input$RejectDeploymentsInput(this._res);

  TRes _res;

  call({
    String? workflowRunId,
    List<String>? environmentIds,
    String? comment,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ReleaseOrder {
  factory Input$ReleaseOrder({
    required Enum$ReleaseOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ReleaseOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ReleaseOrder._(this._$data);

  factory Input$ReleaseOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$ReleaseOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ReleaseOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ReleaseOrderField get field =>
      (_$data['field'] as Enum$ReleaseOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ReleaseOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ReleaseOrder<Input$ReleaseOrder> get copyWith =>
      CopyWith$Input$ReleaseOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReleaseOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ReleaseOrder<TRes> {
  factory CopyWith$Input$ReleaseOrder(
    Input$ReleaseOrder instance,
    TRes Function(Input$ReleaseOrder) then,
  ) = _CopyWithImpl$Input$ReleaseOrder;

  factory CopyWith$Input$ReleaseOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseOrder;

  TRes call({
    Enum$ReleaseOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ReleaseOrder<TRes>
    implements CopyWith$Input$ReleaseOrder<TRes> {
  _CopyWithImpl$Input$ReleaseOrder(
    this._instance,
    this._then,
  );

  final Input$ReleaseOrder _instance;

  final TRes Function(Input$ReleaseOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ReleaseOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ReleaseOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ReleaseOrder<TRes>
    implements CopyWith$Input$ReleaseOrder<TRes> {
  _CopyWithStubImpl$Input$ReleaseOrder(this._res);

  TRes _res;

  call({
    Enum$ReleaseOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$RemoveAssigneesFromAssignableInput {
  factory Input$RemoveAssigneesFromAssignableInput({
    required String assignableId,
    required List<String> assigneeIds,
    String? clientMutationId,
  }) =>
      Input$RemoveAssigneesFromAssignableInput._({
        r'assignableId': assignableId,
        r'assigneeIds': assigneeIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RemoveAssigneesFromAssignableInput._(this._$data);

  factory Input$RemoveAssigneesFromAssignableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$assignableId = data['assignableId'];
    result$data['assignableId'] = (l$assignableId as String);
    final l$assigneeIds = data['assigneeIds'];
    result$data['assigneeIds'] =
        (l$assigneeIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RemoveAssigneesFromAssignableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get assignableId => (_$data['assignableId'] as String);
  List<String> get assigneeIds => (_$data['assigneeIds'] as List<String>);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$assignableId = assignableId;
    result$data['assignableId'] = l$assignableId;
    final l$assigneeIds = assigneeIds;
    result$data['assigneeIds'] = l$assigneeIds.map((e) => e).toList();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveAssigneesFromAssignableInput<
          Input$RemoveAssigneesFromAssignableInput>
      get copyWith => CopyWith$Input$RemoveAssigneesFromAssignableInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveAssigneesFromAssignableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$assignableId = assignableId;
    final lOther$assignableId = other.assignableId;
    if (l$assignableId != lOther$assignableId) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (l$assigneeIds.length != lOther$assigneeIds.length) {
      return false;
    }
    for (int i = 0; i < l$assigneeIds.length; i++) {
      final l$assigneeIds$entry = l$assigneeIds[i];
      final lOther$assigneeIds$entry = lOther$assigneeIds[i];
      if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
        return false;
      }
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assignableId = assignableId;
    final l$assigneeIds = assigneeIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$assignableId,
      Object.hashAll(l$assigneeIds.map((v) => v)),
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveAssigneesFromAssignableInput<TRes> {
  factory CopyWith$Input$RemoveAssigneesFromAssignableInput(
    Input$RemoveAssigneesFromAssignableInput instance,
    TRes Function(Input$RemoveAssigneesFromAssignableInput) then,
  ) = _CopyWithImpl$Input$RemoveAssigneesFromAssignableInput;

  factory CopyWith$Input$RemoveAssigneesFromAssignableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveAssigneesFromAssignableInput;

  TRes call({
    String? assignableId,
    List<String>? assigneeIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RemoveAssigneesFromAssignableInput<TRes>
    implements CopyWith$Input$RemoveAssigneesFromAssignableInput<TRes> {
  _CopyWithImpl$Input$RemoveAssigneesFromAssignableInput(
    this._instance,
    this._then,
  );

  final Input$RemoveAssigneesFromAssignableInput _instance;

  final TRes Function(Input$RemoveAssigneesFromAssignableInput) _then;

  static const _undefined = {};

  TRes call({
    Object? assignableId = _undefined,
    Object? assigneeIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RemoveAssigneesFromAssignableInput._({
        ..._instance._$data,
        if (assignableId != _undefined && assignableId != null)
          'assignableId': (assignableId as String),
        if (assigneeIds != _undefined && assigneeIds != null)
          'assigneeIds': (assigneeIds as List<String>),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RemoveAssigneesFromAssignableInput<TRes>
    implements CopyWith$Input$RemoveAssigneesFromAssignableInput<TRes> {
  _CopyWithStubImpl$Input$RemoveAssigneesFromAssignableInput(this._res);

  TRes _res;

  call({
    String? assignableId,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseAdminInput {
  factory Input$RemoveEnterpriseAdminInput({
    required String enterpriseId,
    required String login,
    String? clientMutationId,
  }) =>
      Input$RemoveEnterpriseAdminInput._({
        r'enterpriseId': enterpriseId,
        r'login': login,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RemoveEnterpriseAdminInput._(this._$data);

  factory Input$RemoveEnterpriseAdminInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RemoveEnterpriseAdminInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseAdminInput<Input$RemoveEnterpriseAdminInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseAdminInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveEnterpriseAdminInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$login,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseAdminInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseAdminInput(
    Input$RemoveEnterpriseAdminInput instance,
    TRes Function(Input$RemoveEnterpriseAdminInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseAdminInput;

  factory CopyWith$Input$RemoveEnterpriseAdminInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseAdminInput;

  TRes call({
    String? enterpriseId,
    String? login,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseAdminInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseAdminInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseAdminInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseAdminInput _instance;

  final TRes Function(Input$RemoveEnterpriseAdminInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseAdminInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseAdminInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseAdminInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseAdminInput(this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? login,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseIdentityProviderInput {
  factory Input$RemoveEnterpriseIdentityProviderInput({
    required String enterpriseId,
    String? clientMutationId,
  }) =>
      Input$RemoveEnterpriseIdentityProviderInput._({
        r'enterpriseId': enterpriseId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RemoveEnterpriseIdentityProviderInput._(this._$data);

  factory Input$RemoveEnterpriseIdentityProviderInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RemoveEnterpriseIdentityProviderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseIdentityProviderInput<
          Input$RemoveEnterpriseIdentityProviderInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseIdentityProviderInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveEnterpriseIdentityProviderInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseIdentityProviderInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseIdentityProviderInput(
    Input$RemoveEnterpriseIdentityProviderInput instance,
    TRes Function(Input$RemoveEnterpriseIdentityProviderInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseIdentityProviderInput;

  factory CopyWith$Input$RemoveEnterpriseIdentityProviderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseIdentityProviderInput;

  TRes call({
    String? enterpriseId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseIdentityProviderInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseIdentityProviderInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseIdentityProviderInput _instance;

  final TRes Function(Input$RemoveEnterpriseIdentityProviderInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseIdentityProviderInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseIdentityProviderInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseIdentityProviderInput(this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseOrganizationInput {
  factory Input$RemoveEnterpriseOrganizationInput({
    required String enterpriseId,
    required String organizationId,
    String? clientMutationId,
  }) =>
      Input$RemoveEnterpriseOrganizationInput._({
        r'enterpriseId': enterpriseId,
        r'organizationId': organizationId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RemoveEnterpriseOrganizationInput._(this._$data);

  factory Input$RemoveEnterpriseOrganizationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RemoveEnterpriseOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get organizationId => (_$data['organizationId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseOrganizationInput<
          Input$RemoveEnterpriseOrganizationInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseOrganizationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveEnterpriseOrganizationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$organizationId = organizationId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$organizationId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseOrganizationInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseOrganizationInput(
    Input$RemoveEnterpriseOrganizationInput instance,
    TRes Function(Input$RemoveEnterpriseOrganizationInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseOrganizationInput;

  factory CopyWith$Input$RemoveEnterpriseOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseOrganizationInput;

  TRes call({
    String? enterpriseId,
    String? organizationId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseOrganizationInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseOrganizationInput _instance;

  final TRes Function(Input$RemoveEnterpriseOrganizationInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? organizationId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseOrganizationInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseOrganizationInput(this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? organizationId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseSupportEntitlementInput {
  factory Input$RemoveEnterpriseSupportEntitlementInput({
    required String enterpriseId,
    required String login,
    String? clientMutationId,
  }) =>
      Input$RemoveEnterpriseSupportEntitlementInput._({
        r'enterpriseId': enterpriseId,
        r'login': login,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RemoveEnterpriseSupportEntitlementInput._(this._$data);

  factory Input$RemoveEnterpriseSupportEntitlementInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RemoveEnterpriseSupportEntitlementInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<
          Input$RemoveEnterpriseSupportEntitlementInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseSupportEntitlementInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveEnterpriseSupportEntitlementInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$login,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseSupportEntitlementInput(
    Input$RemoveEnterpriseSupportEntitlementInput instance,
    TRes Function(Input$RemoveEnterpriseSupportEntitlementInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseSupportEntitlementInput;

  factory CopyWith$Input$RemoveEnterpriseSupportEntitlementInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseSupportEntitlementInput;

  TRes call({
    String? enterpriseId,
    String? login,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseSupportEntitlementInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseSupportEntitlementInput _instance;

  final TRes Function(Input$RemoveEnterpriseSupportEntitlementInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseSupportEntitlementInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseSupportEntitlementInput(this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? login,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RemoveLabelsFromLabelableInput {
  factory Input$RemoveLabelsFromLabelableInput({
    required String labelableId,
    required List<String> labelIds,
    String? clientMutationId,
  }) =>
      Input$RemoveLabelsFromLabelableInput._({
        r'labelableId': labelableId,
        r'labelIds': labelIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RemoveLabelsFromLabelableInput._(this._$data);

  factory Input$RemoveLabelsFromLabelableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$labelableId = data['labelableId'];
    result$data['labelableId'] = (l$labelableId as String);
    final l$labelIds = data['labelIds'];
    result$data['labelIds'] =
        (l$labelIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RemoveLabelsFromLabelableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get labelableId => (_$data['labelableId'] as String);
  List<String> get labelIds => (_$data['labelIds'] as List<String>);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$labelableId = labelableId;
    result$data['labelableId'] = l$labelableId;
    final l$labelIds = labelIds;
    result$data['labelIds'] = l$labelIds.map((e) => e).toList();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveLabelsFromLabelableInput<
          Input$RemoveLabelsFromLabelableInput>
      get copyWith => CopyWith$Input$RemoveLabelsFromLabelableInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveLabelsFromLabelableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$labelableId = labelableId;
    final lOther$labelableId = other.labelableId;
    if (l$labelableId != lOther$labelableId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (l$labelIds.length != lOther$labelIds.length) {
      return false;
    }
    for (int i = 0; i < l$labelIds.length; i++) {
      final l$labelIds$entry = l$labelIds[i];
      final lOther$labelIds$entry = lOther$labelIds[i];
      if (l$labelIds$entry != lOther$labelIds$entry) {
        return false;
      }
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$labelableId = labelableId;
    final l$labelIds = labelIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$labelableId,
      Object.hashAll(l$labelIds.map((v) => v)),
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveLabelsFromLabelableInput<TRes> {
  factory CopyWith$Input$RemoveLabelsFromLabelableInput(
    Input$RemoveLabelsFromLabelableInput instance,
    TRes Function(Input$RemoveLabelsFromLabelableInput) then,
  ) = _CopyWithImpl$Input$RemoveLabelsFromLabelableInput;

  factory CopyWith$Input$RemoveLabelsFromLabelableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveLabelsFromLabelableInput;

  TRes call({
    String? labelableId,
    List<String>? labelIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RemoveLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$RemoveLabelsFromLabelableInput<TRes> {
  _CopyWithImpl$Input$RemoveLabelsFromLabelableInput(
    this._instance,
    this._then,
  );

  final Input$RemoveLabelsFromLabelableInput _instance;

  final TRes Function(Input$RemoveLabelsFromLabelableInput) _then;

  static const _undefined = {};

  TRes call({
    Object? labelableId = _undefined,
    Object? labelIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RemoveLabelsFromLabelableInput._({
        ..._instance._$data,
        if (labelableId != _undefined && labelableId != null)
          'labelableId': (labelableId as String),
        if (labelIds != _undefined && labelIds != null)
          'labelIds': (labelIds as List<String>),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RemoveLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$RemoveLabelsFromLabelableInput<TRes> {
  _CopyWithStubImpl$Input$RemoveLabelsFromLabelableInput(this._res);

  TRes _res;

  call({
    String? labelableId,
    List<String>? labelIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RemoveOutsideCollaboratorInput {
  factory Input$RemoveOutsideCollaboratorInput({
    required String userId,
    required String organizationId,
    String? clientMutationId,
  }) =>
      Input$RemoveOutsideCollaboratorInput._({
        r'userId': userId,
        r'organizationId': organizationId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RemoveOutsideCollaboratorInput._(this._$data);

  factory Input$RemoveOutsideCollaboratorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RemoveOutsideCollaboratorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get userId => (_$data['userId'] as String);
  String get organizationId => (_$data['organizationId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$userId = userId;
    result$data['userId'] = l$userId;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveOutsideCollaboratorInput<
          Input$RemoveOutsideCollaboratorInput>
      get copyWith => CopyWith$Input$RemoveOutsideCollaboratorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveOutsideCollaboratorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$organizationId = organizationId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$userId,
      l$organizationId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveOutsideCollaboratorInput<TRes> {
  factory CopyWith$Input$RemoveOutsideCollaboratorInput(
    Input$RemoveOutsideCollaboratorInput instance,
    TRes Function(Input$RemoveOutsideCollaboratorInput) then,
  ) = _CopyWithImpl$Input$RemoveOutsideCollaboratorInput;

  factory CopyWith$Input$RemoveOutsideCollaboratorInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveOutsideCollaboratorInput;

  TRes call({
    String? userId,
    String? organizationId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RemoveOutsideCollaboratorInput<TRes>
    implements CopyWith$Input$RemoveOutsideCollaboratorInput<TRes> {
  _CopyWithImpl$Input$RemoveOutsideCollaboratorInput(
    this._instance,
    this._then,
  );

  final Input$RemoveOutsideCollaboratorInput _instance;

  final TRes Function(Input$RemoveOutsideCollaboratorInput) _then;

  static const _undefined = {};

  TRes call({
    Object? userId = _undefined,
    Object? organizationId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RemoveOutsideCollaboratorInput._({
        ..._instance._$data,
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RemoveOutsideCollaboratorInput<TRes>
    implements CopyWith$Input$RemoveOutsideCollaboratorInput<TRes> {
  _CopyWithStubImpl$Input$RemoveOutsideCollaboratorInput(this._res);

  TRes _res;

  call({
    String? userId,
    String? organizationId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RemoveReactionInput {
  factory Input$RemoveReactionInput({
    required String subjectId,
    required Enum$ReactionContent content,
    String? clientMutationId,
  }) =>
      Input$RemoveReactionInput._({
        r'subjectId': subjectId,
        r'content': content,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RemoveReactionInput._(this._$data);

  factory Input$RemoveReactionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    final l$content = data['content'];
    result$data['content'] =
        fromJson$Enum$ReactionContent((l$content as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RemoveReactionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get subjectId => (_$data['subjectId'] as String);
  Enum$ReactionContent get content =>
      (_$data['content'] as Enum$ReactionContent);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    final l$content = content;
    result$data['content'] = toJson$Enum$ReactionContent(l$content);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveReactionInput<Input$RemoveReactionInput> get copyWith =>
      CopyWith$Input$RemoveReactionInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveReactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subjectId = subjectId;
    final l$content = content;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$subjectId,
      l$content,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveReactionInput<TRes> {
  factory CopyWith$Input$RemoveReactionInput(
    Input$RemoveReactionInput instance,
    TRes Function(Input$RemoveReactionInput) then,
  ) = _CopyWithImpl$Input$RemoveReactionInput;

  factory CopyWith$Input$RemoveReactionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveReactionInput;

  TRes call({
    String? subjectId,
    Enum$ReactionContent? content,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RemoveReactionInput<TRes>
    implements CopyWith$Input$RemoveReactionInput<TRes> {
  _CopyWithImpl$Input$RemoveReactionInput(
    this._instance,
    this._then,
  );

  final Input$RemoveReactionInput _instance;

  final TRes Function(Input$RemoveReactionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? subjectId = _undefined,
    Object? content = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RemoveReactionInput._({
        ..._instance._$data,
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
        if (content != _undefined && content != null)
          'content': (content as Enum$ReactionContent),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RemoveReactionInput<TRes>
    implements CopyWith$Input$RemoveReactionInput<TRes> {
  _CopyWithStubImpl$Input$RemoveReactionInput(this._res);

  TRes _res;

  call({
    String? subjectId,
    Enum$ReactionContent? content,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RemoveStarInput {
  factory Input$RemoveStarInput({
    required String starrableId,
    String? clientMutationId,
  }) =>
      Input$RemoveStarInput._({
        r'starrableId': starrableId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RemoveStarInput._(this._$data);

  factory Input$RemoveStarInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$starrableId = data['starrableId'];
    result$data['starrableId'] = (l$starrableId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RemoveStarInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get starrableId => (_$data['starrableId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$starrableId = starrableId;
    result$data['starrableId'] = l$starrableId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveStarInput<Input$RemoveStarInput> get copyWith =>
      CopyWith$Input$RemoveStarInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveStarInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$starrableId = starrableId;
    final lOther$starrableId = other.starrableId;
    if (l$starrableId != lOther$starrableId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$starrableId = starrableId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$starrableId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveStarInput<TRes> {
  factory CopyWith$Input$RemoveStarInput(
    Input$RemoveStarInput instance,
    TRes Function(Input$RemoveStarInput) then,
  ) = _CopyWithImpl$Input$RemoveStarInput;

  factory CopyWith$Input$RemoveStarInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveStarInput;

  TRes call({
    String? starrableId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RemoveStarInput<TRes>
    implements CopyWith$Input$RemoveStarInput<TRes> {
  _CopyWithImpl$Input$RemoveStarInput(
    this._instance,
    this._then,
  );

  final Input$RemoveStarInput _instance;

  final TRes Function(Input$RemoveStarInput) _then;

  static const _undefined = {};

  TRes call({
    Object? starrableId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RemoveStarInput._({
        ..._instance._$data,
        if (starrableId != _undefined && starrableId != null)
          'starrableId': (starrableId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RemoveStarInput<TRes>
    implements CopyWith$Input$RemoveStarInput<TRes> {
  _CopyWithStubImpl$Input$RemoveStarInput(this._res);

  TRes _res;

  call({
    String? starrableId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RemoveUpvoteInput {
  factory Input$RemoveUpvoteInput({
    required String subjectId,
    String? clientMutationId,
  }) =>
      Input$RemoveUpvoteInput._({
        r'subjectId': subjectId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RemoveUpvoteInput._(this._$data);

  factory Input$RemoveUpvoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RemoveUpvoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get subjectId => (_$data['subjectId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveUpvoteInput<Input$RemoveUpvoteInput> get copyWith =>
      CopyWith$Input$RemoveUpvoteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveUpvoteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subjectId = subjectId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$subjectId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveUpvoteInput<TRes> {
  factory CopyWith$Input$RemoveUpvoteInput(
    Input$RemoveUpvoteInput instance,
    TRes Function(Input$RemoveUpvoteInput) then,
  ) = _CopyWithImpl$Input$RemoveUpvoteInput;

  factory CopyWith$Input$RemoveUpvoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveUpvoteInput;

  TRes call({
    String? subjectId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RemoveUpvoteInput<TRes>
    implements CopyWith$Input$RemoveUpvoteInput<TRes> {
  _CopyWithImpl$Input$RemoveUpvoteInput(
    this._instance,
    this._then,
  );

  final Input$RemoveUpvoteInput _instance;

  final TRes Function(Input$RemoveUpvoteInput) _then;

  static const _undefined = {};

  TRes call({
    Object? subjectId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RemoveUpvoteInput._({
        ..._instance._$data,
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RemoveUpvoteInput<TRes>
    implements CopyWith$Input$RemoveUpvoteInput<TRes> {
  _CopyWithStubImpl$Input$RemoveUpvoteInput(this._res);

  TRes _res;

  call({
    String? subjectId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ReopenIssueInput {
  factory Input$ReopenIssueInput({
    required String issueId,
    String? clientMutationId,
  }) =>
      Input$ReopenIssueInput._({
        r'issueId': issueId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ReopenIssueInput._(this._$data);

  factory Input$ReopenIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ReopenIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get issueId => (_$data['issueId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ReopenIssueInput<Input$ReopenIssueInput> get copyWith =>
      CopyWith$Input$ReopenIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReopenIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$issueId = issueId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$issueId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReopenIssueInput<TRes> {
  factory CopyWith$Input$ReopenIssueInput(
    Input$ReopenIssueInput instance,
    TRes Function(Input$ReopenIssueInput) then,
  ) = _CopyWithImpl$Input$ReopenIssueInput;

  factory CopyWith$Input$ReopenIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReopenIssueInput;

  TRes call({
    String? issueId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ReopenIssueInput<TRes>
    implements CopyWith$Input$ReopenIssueInput<TRes> {
  _CopyWithImpl$Input$ReopenIssueInput(
    this._instance,
    this._then,
  );

  final Input$ReopenIssueInput _instance;

  final TRes Function(Input$ReopenIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? issueId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ReopenIssueInput._({
        ..._instance._$data,
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ReopenIssueInput<TRes>
    implements CopyWith$Input$ReopenIssueInput<TRes> {
  _CopyWithStubImpl$Input$ReopenIssueInput(this._res);

  TRes _res;

  call({
    String? issueId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ReopenPullRequestInput {
  factory Input$ReopenPullRequestInput({
    required String pullRequestId,
    String? clientMutationId,
  }) =>
      Input$ReopenPullRequestInput._({
        r'pullRequestId': pullRequestId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ReopenPullRequestInput._(this._$data);

  factory Input$ReopenPullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ReopenPullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ReopenPullRequestInput<Input$ReopenPullRequestInput>
      get copyWith => CopyWith$Input$ReopenPullRequestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReopenPullRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReopenPullRequestInput<TRes> {
  factory CopyWith$Input$ReopenPullRequestInput(
    Input$ReopenPullRequestInput instance,
    TRes Function(Input$ReopenPullRequestInput) then,
  ) = _CopyWithImpl$Input$ReopenPullRequestInput;

  factory CopyWith$Input$ReopenPullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReopenPullRequestInput;

  TRes call({
    String? pullRequestId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ReopenPullRequestInput<TRes>
    implements CopyWith$Input$ReopenPullRequestInput<TRes> {
  _CopyWithImpl$Input$ReopenPullRequestInput(
    this._instance,
    this._then,
  );

  final Input$ReopenPullRequestInput _instance;

  final TRes Function(Input$ReopenPullRequestInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ReopenPullRequestInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ReopenPullRequestInput<TRes>
    implements CopyWith$Input$ReopenPullRequestInput<TRes> {
  _CopyWithStubImpl$Input$ReopenPullRequestInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RepositoryInvitationOrder {
  factory Input$RepositoryInvitationOrder({
    required Enum$RepositoryInvitationOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$RepositoryInvitationOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$RepositoryInvitationOrder._(this._$data);

  factory Input$RepositoryInvitationOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$RepositoryInvitationOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$RepositoryInvitationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RepositoryInvitationOrderField get field =>
      (_$data['field'] as Enum$RepositoryInvitationOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$RepositoryInvitationOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$RepositoryInvitationOrder<Input$RepositoryInvitationOrder>
      get copyWith => CopyWith$Input$RepositoryInvitationOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RepositoryInvitationOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$RepositoryInvitationOrder<TRes> {
  factory CopyWith$Input$RepositoryInvitationOrder(
    Input$RepositoryInvitationOrder instance,
    TRes Function(Input$RepositoryInvitationOrder) then,
  ) = _CopyWithImpl$Input$RepositoryInvitationOrder;

  factory CopyWith$Input$RepositoryInvitationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryInvitationOrder;

  TRes call({
    Enum$RepositoryInvitationOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$RepositoryInvitationOrder<TRes>
    implements CopyWith$Input$RepositoryInvitationOrder<TRes> {
  _CopyWithImpl$Input$RepositoryInvitationOrder(
    this._instance,
    this._then,
  );

  final Input$RepositoryInvitationOrder _instance;

  final TRes Function(Input$RepositoryInvitationOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$RepositoryInvitationOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$RepositoryInvitationOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$RepositoryInvitationOrder<TRes>
    implements CopyWith$Input$RepositoryInvitationOrder<TRes> {
  _CopyWithStubImpl$Input$RepositoryInvitationOrder(this._res);

  TRes _res;

  call({
    Enum$RepositoryInvitationOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$RepositoryMigrationOrder {
  factory Input$RepositoryMigrationOrder({
    required Enum$RepositoryMigrationOrderField field,
    required Enum$RepositoryMigrationOrderDirection direction,
  }) =>
      Input$RepositoryMigrationOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$RepositoryMigrationOrder._(this._$data);

  factory Input$RepositoryMigrationOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$RepositoryMigrationOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] = fromJson$Enum$RepositoryMigrationOrderDirection(
        (l$direction as String));
    return Input$RepositoryMigrationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RepositoryMigrationOrderField get field =>
      (_$data['field'] as Enum$RepositoryMigrationOrderField);
  Enum$RepositoryMigrationOrderDirection get direction =>
      (_$data['direction'] as Enum$RepositoryMigrationOrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$RepositoryMigrationOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] =
        toJson$Enum$RepositoryMigrationOrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$RepositoryMigrationOrder<Input$RepositoryMigrationOrder>
      get copyWith => CopyWith$Input$RepositoryMigrationOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RepositoryMigrationOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$RepositoryMigrationOrder<TRes> {
  factory CopyWith$Input$RepositoryMigrationOrder(
    Input$RepositoryMigrationOrder instance,
    TRes Function(Input$RepositoryMigrationOrder) then,
  ) = _CopyWithImpl$Input$RepositoryMigrationOrder;

  factory CopyWith$Input$RepositoryMigrationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryMigrationOrder;

  TRes call({
    Enum$RepositoryMigrationOrderField? field,
    Enum$RepositoryMigrationOrderDirection? direction,
  });
}

class _CopyWithImpl$Input$RepositoryMigrationOrder<TRes>
    implements CopyWith$Input$RepositoryMigrationOrder<TRes> {
  _CopyWithImpl$Input$RepositoryMigrationOrder(
    this._instance,
    this._then,
  );

  final Input$RepositoryMigrationOrder _instance;

  final TRes Function(Input$RepositoryMigrationOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$RepositoryMigrationOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$RepositoryMigrationOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$RepositoryMigrationOrderDirection),
      }));
}

class _CopyWithStubImpl$Input$RepositoryMigrationOrder<TRes>
    implements CopyWith$Input$RepositoryMigrationOrder<TRes> {
  _CopyWithStubImpl$Input$RepositoryMigrationOrder(this._res);

  TRes _res;

  call({
    Enum$RepositoryMigrationOrderField? field,
    Enum$RepositoryMigrationOrderDirection? direction,
  }) =>
      _res;
}

class Input$RepositoryOrder {
  factory Input$RepositoryOrder({
    required Enum$RepositoryOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$RepositoryOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$RepositoryOrder._(this._$data);

  factory Input$RepositoryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$RepositoryOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$RepositoryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RepositoryOrderField get field =>
      (_$data['field'] as Enum$RepositoryOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$RepositoryOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$RepositoryOrder<Input$RepositoryOrder> get copyWith =>
      CopyWith$Input$RepositoryOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RepositoryOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$RepositoryOrder<TRes> {
  factory CopyWith$Input$RepositoryOrder(
    Input$RepositoryOrder instance,
    TRes Function(Input$RepositoryOrder) then,
  ) = _CopyWithImpl$Input$RepositoryOrder;

  factory CopyWith$Input$RepositoryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryOrder;

  TRes call({
    Enum$RepositoryOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$RepositoryOrder<TRes>
    implements CopyWith$Input$RepositoryOrder<TRes> {
  _CopyWithImpl$Input$RepositoryOrder(
    this._instance,
    this._then,
  );

  final Input$RepositoryOrder _instance;

  final TRes Function(Input$RepositoryOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$RepositoryOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$RepositoryOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$RepositoryOrder<TRes>
    implements CopyWith$Input$RepositoryOrder<TRes> {
  _CopyWithStubImpl$Input$RepositoryOrder(this._res);

  TRes _res;

  call({
    Enum$RepositoryOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$RequestReviewsInput {
  factory Input$RequestReviewsInput({
    required String pullRequestId,
    List<String>? userIds,
    List<String>? teamIds,
    bool? union,
    String? clientMutationId,
  }) =>
      Input$RequestReviewsInput._({
        r'pullRequestId': pullRequestId,
        if (userIds != null) r'userIds': userIds,
        if (teamIds != null) r'teamIds': teamIds,
        if (union != null) r'union': union,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RequestReviewsInput._(this._$data);

  factory Input$RequestReviewsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('userIds')) {
      final l$userIds = data['userIds'];
      result$data['userIds'] =
          (l$userIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('teamIds')) {
      final l$teamIds = data['teamIds'];
      result$data['teamIds'] =
          (l$teamIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('union')) {
      final l$union = data['union'];
      result$data['union'] = (l$union as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RequestReviewsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  List<String>? get userIds => (_$data['userIds'] as List<String>?);
  List<String>? get teamIds => (_$data['teamIds'] as List<String>?);
  bool? get union => (_$data['union'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('userIds')) {
      final l$userIds = userIds;
      result$data['userIds'] = l$userIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('teamIds')) {
      final l$teamIds = teamIds;
      result$data['teamIds'] = l$teamIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('union')) {
      final l$union = union;
      result$data['union'] = l$union;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RequestReviewsInput<Input$RequestReviewsInput> get copyWith =>
      CopyWith$Input$RequestReviewsInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RequestReviewsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$userIds = userIds;
    final lOther$userIds = other.userIds;
    if (_$data.containsKey('userIds') != other._$data.containsKey('userIds')) {
      return false;
    }
    if (l$userIds != null && lOther$userIds != null) {
      if (l$userIds.length != lOther$userIds.length) {
        return false;
      }
      for (int i = 0; i < l$userIds.length; i++) {
        final l$userIds$entry = l$userIds[i];
        final lOther$userIds$entry = lOther$userIds[i];
        if (l$userIds$entry != lOther$userIds$entry) {
          return false;
        }
      }
    } else if (l$userIds != lOther$userIds) {
      return false;
    }
    final l$teamIds = teamIds;
    final lOther$teamIds = other.teamIds;
    if (_$data.containsKey('teamIds') != other._$data.containsKey('teamIds')) {
      return false;
    }
    if (l$teamIds != null && lOther$teamIds != null) {
      if (l$teamIds.length != lOther$teamIds.length) {
        return false;
      }
      for (int i = 0; i < l$teamIds.length; i++) {
        final l$teamIds$entry = l$teamIds[i];
        final lOther$teamIds$entry = lOther$teamIds[i];
        if (l$teamIds$entry != lOther$teamIds$entry) {
          return false;
        }
      }
    } else if (l$teamIds != lOther$teamIds) {
      return false;
    }
    final l$union = union;
    final lOther$union = other.union;
    if (_$data.containsKey('union') != other._$data.containsKey('union')) {
      return false;
    }
    if (l$union != lOther$union) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$userIds = userIds;
    final l$teamIds = teamIds;
    final l$union = union;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      _$data.containsKey('userIds')
          ? l$userIds == null
              ? null
              : Object.hashAll(l$userIds.map((v) => v))
          : const {},
      _$data.containsKey('teamIds')
          ? l$teamIds == null
              ? null
              : Object.hashAll(l$teamIds.map((v) => v))
          : const {},
      _$data.containsKey('union') ? l$union : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequestReviewsInput<TRes> {
  factory CopyWith$Input$RequestReviewsInput(
    Input$RequestReviewsInput instance,
    TRes Function(Input$RequestReviewsInput) then,
  ) = _CopyWithImpl$Input$RequestReviewsInput;

  factory CopyWith$Input$RequestReviewsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestReviewsInput;

  TRes call({
    String? pullRequestId,
    List<String>? userIds,
    List<String>? teamIds,
    bool? union,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RequestReviewsInput<TRes>
    implements CopyWith$Input$RequestReviewsInput<TRes> {
  _CopyWithImpl$Input$RequestReviewsInput(
    this._instance,
    this._then,
  );

  final Input$RequestReviewsInput _instance;

  final TRes Function(Input$RequestReviewsInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? userIds = _undefined,
    Object? teamIds = _undefined,
    Object? union = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RequestReviewsInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (userIds != _undefined) 'userIds': (userIds as List<String>?),
        if (teamIds != _undefined) 'teamIds': (teamIds as List<String>?),
        if (union != _undefined) 'union': (union as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RequestReviewsInput<TRes>
    implements CopyWith$Input$RequestReviewsInput<TRes> {
  _CopyWithStubImpl$Input$RequestReviewsInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    List<String>? userIds,
    List<String>? teamIds,
    bool? union,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RequiredStatusCheckInput {
  factory Input$RequiredStatusCheckInput({
    required String context,
    String? appId,
  }) =>
      Input$RequiredStatusCheckInput._({
        r'context': context,
        if (appId != null) r'appId': appId,
      });

  Input$RequiredStatusCheckInput._(this._$data);

  factory Input$RequiredStatusCheckInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$context = data['context'];
    result$data['context'] = (l$context as String);
    if (data.containsKey('appId')) {
      final l$appId = data['appId'];
      result$data['appId'] = (l$appId as String?);
    }
    return Input$RequiredStatusCheckInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get context => (_$data['context'] as String);
  String? get appId => (_$data['appId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$context = context;
    result$data['context'] = l$context;
    if (_$data.containsKey('appId')) {
      final l$appId = appId;
      result$data['appId'] = l$appId;
    }
    return result$data;
  }

  CopyWith$Input$RequiredStatusCheckInput<Input$RequiredStatusCheckInput>
      get copyWith => CopyWith$Input$RequiredStatusCheckInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RequiredStatusCheckInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (_$data.containsKey('appId') != other._$data.containsKey('appId')) {
      return false;
    }
    if (l$appId != lOther$appId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$context = context;
    final l$appId = appId;
    return Object.hashAll([
      l$context,
      _$data.containsKey('appId') ? l$appId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequiredStatusCheckInput<TRes> {
  factory CopyWith$Input$RequiredStatusCheckInput(
    Input$RequiredStatusCheckInput instance,
    TRes Function(Input$RequiredStatusCheckInput) then,
  ) = _CopyWithImpl$Input$RequiredStatusCheckInput;

  factory CopyWith$Input$RequiredStatusCheckInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequiredStatusCheckInput;

  TRes call({
    String? context,
    String? appId,
  });
}

class _CopyWithImpl$Input$RequiredStatusCheckInput<TRes>
    implements CopyWith$Input$RequiredStatusCheckInput<TRes> {
  _CopyWithImpl$Input$RequiredStatusCheckInput(
    this._instance,
    this._then,
  );

  final Input$RequiredStatusCheckInput _instance;

  final TRes Function(Input$RequiredStatusCheckInput) _then;

  static const _undefined = {};

  TRes call({
    Object? context = _undefined,
    Object? appId = _undefined,
  }) =>
      _then(Input$RequiredStatusCheckInput._({
        ..._instance._$data,
        if (context != _undefined && context != null)
          'context': (context as String),
        if (appId != _undefined) 'appId': (appId as String?),
      }));
}

class _CopyWithStubImpl$Input$RequiredStatusCheckInput<TRes>
    implements CopyWith$Input$RequiredStatusCheckInput<TRes> {
  _CopyWithStubImpl$Input$RequiredStatusCheckInput(this._res);

  TRes _res;

  call({
    String? context,
    String? appId,
  }) =>
      _res;
}

class Input$RerequestCheckSuiteInput {
  factory Input$RerequestCheckSuiteInput({
    required String repositoryId,
    required String checkSuiteId,
    String? clientMutationId,
  }) =>
      Input$RerequestCheckSuiteInput._({
        r'repositoryId': repositoryId,
        r'checkSuiteId': checkSuiteId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RerequestCheckSuiteInput._(this._$data);

  factory Input$RerequestCheckSuiteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$checkSuiteId = data['checkSuiteId'];
    result$data['checkSuiteId'] = (l$checkSuiteId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RerequestCheckSuiteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get checkSuiteId => (_$data['checkSuiteId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$checkSuiteId = checkSuiteId;
    result$data['checkSuiteId'] = l$checkSuiteId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RerequestCheckSuiteInput<Input$RerequestCheckSuiteInput>
      get copyWith => CopyWith$Input$RerequestCheckSuiteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RerequestCheckSuiteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$checkSuiteId = checkSuiteId;
    final lOther$checkSuiteId = other.checkSuiteId;
    if (l$checkSuiteId != lOther$checkSuiteId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$checkSuiteId = checkSuiteId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$checkSuiteId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RerequestCheckSuiteInput<TRes> {
  factory CopyWith$Input$RerequestCheckSuiteInput(
    Input$RerequestCheckSuiteInput instance,
    TRes Function(Input$RerequestCheckSuiteInput) then,
  ) = _CopyWithImpl$Input$RerequestCheckSuiteInput;

  factory CopyWith$Input$RerequestCheckSuiteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RerequestCheckSuiteInput;

  TRes call({
    String? repositoryId,
    String? checkSuiteId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RerequestCheckSuiteInput<TRes>
    implements CopyWith$Input$RerequestCheckSuiteInput<TRes> {
  _CopyWithImpl$Input$RerequestCheckSuiteInput(
    this._instance,
    this._then,
  );

  final Input$RerequestCheckSuiteInput _instance;

  final TRes Function(Input$RerequestCheckSuiteInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? checkSuiteId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RerequestCheckSuiteInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (checkSuiteId != _undefined && checkSuiteId != null)
          'checkSuiteId': (checkSuiteId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RerequestCheckSuiteInput<TRes>
    implements CopyWith$Input$RerequestCheckSuiteInput<TRes> {
  _CopyWithStubImpl$Input$RerequestCheckSuiteInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? checkSuiteId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$ResolveReviewThreadInput {
  factory Input$ResolveReviewThreadInput({
    required String threadId,
    String? clientMutationId,
  }) =>
      Input$ResolveReviewThreadInput._({
        r'threadId': threadId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$ResolveReviewThreadInput._(this._$data);

  factory Input$ResolveReviewThreadInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$threadId = data['threadId'];
    result$data['threadId'] = (l$threadId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$ResolveReviewThreadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get threadId => (_$data['threadId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$threadId = threadId;
    result$data['threadId'] = l$threadId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$ResolveReviewThreadInput<Input$ResolveReviewThreadInput>
      get copyWith => CopyWith$Input$ResolveReviewThreadInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ResolveReviewThreadInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$threadId = threadId;
    final lOther$threadId = other.threadId;
    if (l$threadId != lOther$threadId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$threadId = threadId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$threadId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ResolveReviewThreadInput<TRes> {
  factory CopyWith$Input$ResolveReviewThreadInput(
    Input$ResolveReviewThreadInput instance,
    TRes Function(Input$ResolveReviewThreadInput) then,
  ) = _CopyWithImpl$Input$ResolveReviewThreadInput;

  factory CopyWith$Input$ResolveReviewThreadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ResolveReviewThreadInput;

  TRes call({
    String? threadId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$ResolveReviewThreadInput<TRes>
    implements CopyWith$Input$ResolveReviewThreadInput<TRes> {
  _CopyWithImpl$Input$ResolveReviewThreadInput(
    this._instance,
    this._then,
  );

  final Input$ResolveReviewThreadInput _instance;

  final TRes Function(Input$ResolveReviewThreadInput) _then;

  static const _undefined = {};

  TRes call({
    Object? threadId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$ResolveReviewThreadInput._({
        ..._instance._$data,
        if (threadId != _undefined && threadId != null)
          'threadId': (threadId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ResolveReviewThreadInput<TRes>
    implements CopyWith$Input$ResolveReviewThreadInput<TRes> {
  _CopyWithStubImpl$Input$ResolveReviewThreadInput(this._res);

  TRes _res;

  call({
    String? threadId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RevokeEnterpriseOrganizationsMigratorRoleInput {
  factory Input$RevokeEnterpriseOrganizationsMigratorRoleInput({
    required String enterpriseId,
    required String login,
    String? clientMutationId,
  }) =>
      Input$RevokeEnterpriseOrganizationsMigratorRoleInput._({
        r'enterpriseId': enterpriseId,
        r'login': login,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RevokeEnterpriseOrganizationsMigratorRoleInput._(this._$data);

  factory Input$RevokeEnterpriseOrganizationsMigratorRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RevokeEnterpriseOrganizationsMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<
          Input$RevokeEnterpriseOrganizationsMigratorRoleInput>
      get copyWith =>
          CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RevokeEnterpriseOrganizationsMigratorRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$login,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<
    TRes> {
  factory CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
    Input$RevokeEnterpriseOrganizationsMigratorRoleInput instance,
    TRes Function(Input$RevokeEnterpriseOrganizationsMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput;

  factory CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput;

  TRes call({
    String? enterpriseId,
    String? login,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<TRes>
    implements
        CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$RevokeEnterpriseOrganizationsMigratorRoleInput _instance;

  final TRes Function(Input$RevokeEnterpriseOrganizationsMigratorRoleInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RevokeEnterpriseOrganizationsMigratorRoleInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<
        TRes>
    implements
        CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? login,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RevokeMigratorRoleInput {
  factory Input$RevokeMigratorRoleInput({
    required String organizationId,
    required String actor,
    required Enum$ActorType actorType,
    String? clientMutationId,
  }) =>
      Input$RevokeMigratorRoleInput._({
        r'organizationId': organizationId,
        r'actor': actor,
        r'actorType': actorType,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RevokeMigratorRoleInput._(this._$data);

  factory Input$RevokeMigratorRoleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$actor = data['actor'];
    result$data['actor'] = (l$actor as String);
    final l$actorType = data['actorType'];
    result$data['actorType'] = fromJson$Enum$ActorType((l$actorType as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RevokeMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get organizationId => (_$data['organizationId'] as String);
  String get actor => (_$data['actor'] as String);
  Enum$ActorType get actorType => (_$data['actorType'] as Enum$ActorType);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$actor = actor;
    result$data['actor'] = l$actor;
    final l$actorType = actorType;
    result$data['actorType'] = toJson$Enum$ActorType(l$actorType);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RevokeMigratorRoleInput<Input$RevokeMigratorRoleInput>
      get copyWith => CopyWith$Input$RevokeMigratorRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RevokeMigratorRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$actor = actor;
    final lOther$actor = other.actor;
    if (l$actor != lOther$actor) {
      return false;
    }
    final l$actorType = actorType;
    final lOther$actorType = other.actorType;
    if (l$actorType != lOther$actorType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$organizationId = organizationId;
    final l$actor = actor;
    final l$actorType = actorType;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$organizationId,
      l$actor,
      l$actorType,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RevokeMigratorRoleInput<TRes> {
  factory CopyWith$Input$RevokeMigratorRoleInput(
    Input$RevokeMigratorRoleInput instance,
    TRes Function(Input$RevokeMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$RevokeMigratorRoleInput;

  factory CopyWith$Input$RevokeMigratorRoleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RevokeMigratorRoleInput;

  TRes call({
    String? organizationId,
    String? actor,
    Enum$ActorType? actorType,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RevokeMigratorRoleInput<TRes>
    implements CopyWith$Input$RevokeMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$RevokeMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$RevokeMigratorRoleInput _instance;

  final TRes Function(Input$RevokeMigratorRoleInput) _then;

  static const _undefined = {};

  TRes call({
    Object? organizationId = _undefined,
    Object? actor = _undefined,
    Object? actorType = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RevokeMigratorRoleInput._({
        ..._instance._$data,
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (actor != _undefined && actor != null) 'actor': (actor as String),
        if (actorType != _undefined && actorType != null)
          'actorType': (actorType as Enum$ActorType),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RevokeMigratorRoleInput<TRes>
    implements CopyWith$Input$RevokeMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$RevokeMigratorRoleInput(this._res);

  TRes _res;

  call({
    String? organizationId,
    String? actor,
    Enum$ActorType? actorType,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$SavedReplyOrder {
  factory Input$SavedReplyOrder({
    required Enum$SavedReplyOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SavedReplyOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SavedReplyOrder._(this._$data);

  factory Input$SavedReplyOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SavedReplyOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SavedReplyOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SavedReplyOrderField get field =>
      (_$data['field'] as Enum$SavedReplyOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SavedReplyOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SavedReplyOrder<Input$SavedReplyOrder> get copyWith =>
      CopyWith$Input$SavedReplyOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SavedReplyOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SavedReplyOrder<TRes> {
  factory CopyWith$Input$SavedReplyOrder(
    Input$SavedReplyOrder instance,
    TRes Function(Input$SavedReplyOrder) then,
  ) = _CopyWithImpl$Input$SavedReplyOrder;

  factory CopyWith$Input$SavedReplyOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SavedReplyOrder;

  TRes call({
    Enum$SavedReplyOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SavedReplyOrder<TRes>
    implements CopyWith$Input$SavedReplyOrder<TRes> {
  _CopyWithImpl$Input$SavedReplyOrder(
    this._instance,
    this._then,
  );

  final Input$SavedReplyOrder _instance;

  final TRes Function(Input$SavedReplyOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SavedReplyOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SavedReplyOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SavedReplyOrder<TRes>
    implements CopyWith$Input$SavedReplyOrder<TRes> {
  _CopyWithStubImpl$Input$SavedReplyOrder(this._res);

  TRes _res;

  call({
    Enum$SavedReplyOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SecurityAdvisoryIdentifierFilter {
  factory Input$SecurityAdvisoryIdentifierFilter({
    required Enum$SecurityAdvisoryIdentifierType type,
    required String value,
  }) =>
      Input$SecurityAdvisoryIdentifierFilter._({
        r'type': type,
        r'value': value,
      });

  Input$SecurityAdvisoryIdentifierFilter._(this._$data);

  factory Input$SecurityAdvisoryIdentifierFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$type = data['type'];
    result$data['type'] =
        fromJson$Enum$SecurityAdvisoryIdentifierType((l$type as String));
    final l$value = data['value'];
    result$data['value'] = (l$value as String);
    return Input$SecurityAdvisoryIdentifierFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SecurityAdvisoryIdentifierType get type =>
      (_$data['type'] as Enum$SecurityAdvisoryIdentifierType);
  String get value => (_$data['value'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$type = type;
    result$data['type'] = toJson$Enum$SecurityAdvisoryIdentifierType(l$type);
    final l$value = value;
    result$data['value'] = l$value;
    return result$data;
  }

  CopyWith$Input$SecurityAdvisoryIdentifierFilter<
          Input$SecurityAdvisoryIdentifierFilter>
      get copyWith => CopyWith$Input$SecurityAdvisoryIdentifierFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SecurityAdvisoryIdentifierFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type = type;
    final l$value = value;
    return Object.hashAll([
      l$type,
      l$value,
    ]);
  }
}

abstract class CopyWith$Input$SecurityAdvisoryIdentifierFilter<TRes> {
  factory CopyWith$Input$SecurityAdvisoryIdentifierFilter(
    Input$SecurityAdvisoryIdentifierFilter instance,
    TRes Function(Input$SecurityAdvisoryIdentifierFilter) then,
  ) = _CopyWithImpl$Input$SecurityAdvisoryIdentifierFilter;

  factory CopyWith$Input$SecurityAdvisoryIdentifierFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityAdvisoryIdentifierFilter;

  TRes call({
    Enum$SecurityAdvisoryIdentifierType? type,
    String? value,
  });
}

class _CopyWithImpl$Input$SecurityAdvisoryIdentifierFilter<TRes>
    implements CopyWith$Input$SecurityAdvisoryIdentifierFilter<TRes> {
  _CopyWithImpl$Input$SecurityAdvisoryIdentifierFilter(
    this._instance,
    this._then,
  );

  final Input$SecurityAdvisoryIdentifierFilter _instance;

  final TRes Function(Input$SecurityAdvisoryIdentifierFilter) _then;

  static const _undefined = {};

  TRes call({
    Object? type = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$SecurityAdvisoryIdentifierFilter._({
        ..._instance._$data,
        if (type != _undefined && type != null)
          'type': (type as Enum$SecurityAdvisoryIdentifierType),
        if (value != _undefined && value != null) 'value': (value as String),
      }));
}

class _CopyWithStubImpl$Input$SecurityAdvisoryIdentifierFilter<TRes>
    implements CopyWith$Input$SecurityAdvisoryIdentifierFilter<TRes> {
  _CopyWithStubImpl$Input$SecurityAdvisoryIdentifierFilter(this._res);

  TRes _res;

  call({
    Enum$SecurityAdvisoryIdentifierType? type,
    String? value,
  }) =>
      _res;
}

class Input$SecurityAdvisoryOrder {
  factory Input$SecurityAdvisoryOrder({
    required Enum$SecurityAdvisoryOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SecurityAdvisoryOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SecurityAdvisoryOrder._(this._$data);

  factory Input$SecurityAdvisoryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SecurityAdvisoryOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SecurityAdvisoryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SecurityAdvisoryOrderField get field =>
      (_$data['field'] as Enum$SecurityAdvisoryOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SecurityAdvisoryOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SecurityAdvisoryOrder<Input$SecurityAdvisoryOrder>
      get copyWith => CopyWith$Input$SecurityAdvisoryOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SecurityAdvisoryOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SecurityAdvisoryOrder<TRes> {
  factory CopyWith$Input$SecurityAdvisoryOrder(
    Input$SecurityAdvisoryOrder instance,
    TRes Function(Input$SecurityAdvisoryOrder) then,
  ) = _CopyWithImpl$Input$SecurityAdvisoryOrder;

  factory CopyWith$Input$SecurityAdvisoryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityAdvisoryOrder;

  TRes call({
    Enum$SecurityAdvisoryOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SecurityAdvisoryOrder<TRes>
    implements CopyWith$Input$SecurityAdvisoryOrder<TRes> {
  _CopyWithImpl$Input$SecurityAdvisoryOrder(
    this._instance,
    this._then,
  );

  final Input$SecurityAdvisoryOrder _instance;

  final TRes Function(Input$SecurityAdvisoryOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SecurityAdvisoryOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SecurityAdvisoryOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SecurityAdvisoryOrder<TRes>
    implements CopyWith$Input$SecurityAdvisoryOrder<TRes> {
  _CopyWithStubImpl$Input$SecurityAdvisoryOrder(this._res);

  TRes _res;

  call({
    Enum$SecurityAdvisoryOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SecurityVulnerabilityOrder {
  factory Input$SecurityVulnerabilityOrder({
    required Enum$SecurityVulnerabilityOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SecurityVulnerabilityOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SecurityVulnerabilityOrder._(this._$data);

  factory Input$SecurityVulnerabilityOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SecurityVulnerabilityOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SecurityVulnerabilityOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SecurityVulnerabilityOrderField get field =>
      (_$data['field'] as Enum$SecurityVulnerabilityOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SecurityVulnerabilityOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SecurityVulnerabilityOrder<Input$SecurityVulnerabilityOrder>
      get copyWith => CopyWith$Input$SecurityVulnerabilityOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SecurityVulnerabilityOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SecurityVulnerabilityOrder<TRes> {
  factory CopyWith$Input$SecurityVulnerabilityOrder(
    Input$SecurityVulnerabilityOrder instance,
    TRes Function(Input$SecurityVulnerabilityOrder) then,
  ) = _CopyWithImpl$Input$SecurityVulnerabilityOrder;

  factory CopyWith$Input$SecurityVulnerabilityOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityVulnerabilityOrder;

  TRes call({
    Enum$SecurityVulnerabilityOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SecurityVulnerabilityOrder<TRes>
    implements CopyWith$Input$SecurityVulnerabilityOrder<TRes> {
  _CopyWithImpl$Input$SecurityVulnerabilityOrder(
    this._instance,
    this._then,
  );

  final Input$SecurityVulnerabilityOrder _instance;

  final TRes Function(Input$SecurityVulnerabilityOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SecurityVulnerabilityOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SecurityVulnerabilityOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SecurityVulnerabilityOrder<TRes>
    implements CopyWith$Input$SecurityVulnerabilityOrder<TRes> {
  _CopyWithStubImpl$Input$SecurityVulnerabilityOrder(this._res);

  TRes _res;

  call({
    Enum$SecurityVulnerabilityOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SetEnterpriseIdentityProviderInput {
  factory Input$SetEnterpriseIdentityProviderInput({
    required String enterpriseId,
    required String ssoUrl,
    String? issuer,
    required String idpCertificate,
    required Enum$SamlSignatureAlgorithm signatureMethod,
    required Enum$SamlDigestAlgorithm digestMethod,
    String? clientMutationId,
  }) =>
      Input$SetEnterpriseIdentityProviderInput._({
        r'enterpriseId': enterpriseId,
        r'ssoUrl': ssoUrl,
        if (issuer != null) r'issuer': issuer,
        r'idpCertificate': idpCertificate,
        r'signatureMethod': signatureMethod,
        r'digestMethod': digestMethod,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$SetEnterpriseIdentityProviderInput._(this._$data);

  factory Input$SetEnterpriseIdentityProviderInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$ssoUrl = data['ssoUrl'];
    result$data['ssoUrl'] = (l$ssoUrl as String);
    if (data.containsKey('issuer')) {
      final l$issuer = data['issuer'];
      result$data['issuer'] = (l$issuer as String?);
    }
    final l$idpCertificate = data['idpCertificate'];
    result$data['idpCertificate'] = (l$idpCertificate as String);
    final l$signatureMethod = data['signatureMethod'];
    result$data['signatureMethod'] =
        fromJson$Enum$SamlSignatureAlgorithm((l$signatureMethod as String));
    final l$digestMethod = data['digestMethod'];
    result$data['digestMethod'] =
        fromJson$Enum$SamlDigestAlgorithm((l$digestMethod as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$SetEnterpriseIdentityProviderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get ssoUrl => (_$data['ssoUrl'] as String);
  String? get issuer => (_$data['issuer'] as String?);
  String get idpCertificate => (_$data['idpCertificate'] as String);
  Enum$SamlSignatureAlgorithm get signatureMethod =>
      (_$data['signatureMethod'] as Enum$SamlSignatureAlgorithm);
  Enum$SamlDigestAlgorithm get digestMethod =>
      (_$data['digestMethod'] as Enum$SamlDigestAlgorithm);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$ssoUrl = ssoUrl;
    result$data['ssoUrl'] = l$ssoUrl;
    if (_$data.containsKey('issuer')) {
      final l$issuer = issuer;
      result$data['issuer'] = l$issuer;
    }
    final l$idpCertificate = idpCertificate;
    result$data['idpCertificate'] = l$idpCertificate;
    final l$signatureMethod = signatureMethod;
    result$data['signatureMethod'] =
        toJson$Enum$SamlSignatureAlgorithm(l$signatureMethod);
    final l$digestMethod = digestMethod;
    result$data['digestMethod'] =
        toJson$Enum$SamlDigestAlgorithm(l$digestMethod);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$SetEnterpriseIdentityProviderInput<
          Input$SetEnterpriseIdentityProviderInput>
      get copyWith => CopyWith$Input$SetEnterpriseIdentityProviderInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SetEnterpriseIdentityProviderInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$ssoUrl = ssoUrl;
    final lOther$ssoUrl = other.ssoUrl;
    if (l$ssoUrl != lOther$ssoUrl) {
      return false;
    }
    final l$issuer = issuer;
    final lOther$issuer = other.issuer;
    if (_$data.containsKey('issuer') != other._$data.containsKey('issuer')) {
      return false;
    }
    if (l$issuer != lOther$issuer) {
      return false;
    }
    final l$idpCertificate = idpCertificate;
    final lOther$idpCertificate = other.idpCertificate;
    if (l$idpCertificate != lOther$idpCertificate) {
      return false;
    }
    final l$signatureMethod = signatureMethod;
    final lOther$signatureMethod = other.signatureMethod;
    if (l$signatureMethod != lOther$signatureMethod) {
      return false;
    }
    final l$digestMethod = digestMethod;
    final lOther$digestMethod = other.digestMethod;
    if (l$digestMethod != lOther$digestMethod) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$ssoUrl = ssoUrl;
    final l$issuer = issuer;
    final l$idpCertificate = idpCertificate;
    final l$signatureMethod = signatureMethod;
    final l$digestMethod = digestMethod;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$ssoUrl,
      _$data.containsKey('issuer') ? l$issuer : const {},
      l$idpCertificate,
      l$signatureMethod,
      l$digestMethod,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$SetEnterpriseIdentityProviderInput<TRes> {
  factory CopyWith$Input$SetEnterpriseIdentityProviderInput(
    Input$SetEnterpriseIdentityProviderInput instance,
    TRes Function(Input$SetEnterpriseIdentityProviderInput) then,
  ) = _CopyWithImpl$Input$SetEnterpriseIdentityProviderInput;

  factory CopyWith$Input$SetEnterpriseIdentityProviderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetEnterpriseIdentityProviderInput;

  TRes call({
    String? enterpriseId,
    String? ssoUrl,
    String? issuer,
    String? idpCertificate,
    Enum$SamlSignatureAlgorithm? signatureMethod,
    Enum$SamlDigestAlgorithm? digestMethod,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$SetEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$SetEnterpriseIdentityProviderInput<TRes> {
  _CopyWithImpl$Input$SetEnterpriseIdentityProviderInput(
    this._instance,
    this._then,
  );

  final Input$SetEnterpriseIdentityProviderInput _instance;

  final TRes Function(Input$SetEnterpriseIdentityProviderInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? ssoUrl = _undefined,
    Object? issuer = _undefined,
    Object? idpCertificate = _undefined,
    Object? signatureMethod = _undefined,
    Object? digestMethod = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$SetEnterpriseIdentityProviderInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (ssoUrl != _undefined && ssoUrl != null)
          'ssoUrl': (ssoUrl as String),
        if (issuer != _undefined) 'issuer': (issuer as String?),
        if (idpCertificate != _undefined && idpCertificate != null)
          'idpCertificate': (idpCertificate as String),
        if (signatureMethod != _undefined && signatureMethod != null)
          'signatureMethod': (signatureMethod as Enum$SamlSignatureAlgorithm),
        if (digestMethod != _undefined && digestMethod != null)
          'digestMethod': (digestMethod as Enum$SamlDigestAlgorithm),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$SetEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$SetEnterpriseIdentityProviderInput<TRes> {
  _CopyWithStubImpl$Input$SetEnterpriseIdentityProviderInput(this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? ssoUrl,
    String? issuer,
    String? idpCertificate,
    Enum$SamlSignatureAlgorithm? signatureMethod,
    Enum$SamlDigestAlgorithm? digestMethod,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$SetOrganizationInteractionLimitInput {
  factory Input$SetOrganizationInteractionLimitInput({
    required String organizationId,
    required Enum$RepositoryInteractionLimit limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    String? clientMutationId,
  }) =>
      Input$SetOrganizationInteractionLimitInput._({
        r'organizationId': organizationId,
        r'limit': limit,
        if (expiry != null) r'expiry': expiry,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$SetOrganizationInteractionLimitInput._(this._$data);

  factory Input$SetOrganizationInteractionLimitInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$limit = data['limit'];
    result$data['limit'] =
        fromJson$Enum$RepositoryInteractionLimit((l$limit as String));
    if (data.containsKey('expiry')) {
      final l$expiry = data['expiry'];
      result$data['expiry'] = l$expiry == null
          ? null
          : fromJson$Enum$RepositoryInteractionLimitExpiry(
              (l$expiry as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$SetOrganizationInteractionLimitInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get organizationId => (_$data['organizationId'] as String);
  Enum$RepositoryInteractionLimit get limit =>
      (_$data['limit'] as Enum$RepositoryInteractionLimit);
  Enum$RepositoryInteractionLimitExpiry? get expiry =>
      (_$data['expiry'] as Enum$RepositoryInteractionLimitExpiry?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$limit = limit;
    result$data['limit'] = toJson$Enum$RepositoryInteractionLimit(l$limit);
    if (_$data.containsKey('expiry')) {
      final l$expiry = expiry;
      result$data['expiry'] = l$expiry == null
          ? null
          : toJson$Enum$RepositoryInteractionLimitExpiry(l$expiry);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$SetOrganizationInteractionLimitInput<
          Input$SetOrganizationInteractionLimitInput>
      get copyWith => CopyWith$Input$SetOrganizationInteractionLimitInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SetOrganizationInteractionLimitInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$expiry = expiry;
    final lOther$expiry = other.expiry;
    if (_$data.containsKey('expiry') != other._$data.containsKey('expiry')) {
      return false;
    }
    if (l$expiry != lOther$expiry) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$organizationId = organizationId;
    final l$limit = limit;
    final l$expiry = expiry;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$organizationId,
      l$limit,
      _$data.containsKey('expiry') ? l$expiry : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$SetOrganizationInteractionLimitInput<TRes> {
  factory CopyWith$Input$SetOrganizationInteractionLimitInput(
    Input$SetOrganizationInteractionLimitInput instance,
    TRes Function(Input$SetOrganizationInteractionLimitInput) then,
  ) = _CopyWithImpl$Input$SetOrganizationInteractionLimitInput;

  factory CopyWith$Input$SetOrganizationInteractionLimitInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetOrganizationInteractionLimitInput;

  TRes call({
    String? organizationId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$SetOrganizationInteractionLimitInput<TRes>
    implements CopyWith$Input$SetOrganizationInteractionLimitInput<TRes> {
  _CopyWithImpl$Input$SetOrganizationInteractionLimitInput(
    this._instance,
    this._then,
  );

  final Input$SetOrganizationInteractionLimitInput _instance;

  final TRes Function(Input$SetOrganizationInteractionLimitInput) _then;

  static const _undefined = {};

  TRes call({
    Object? organizationId = _undefined,
    Object? limit = _undefined,
    Object? expiry = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$SetOrganizationInteractionLimitInput._({
        ..._instance._$data,
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (limit != _undefined && limit != null)
          'limit': (limit as Enum$RepositoryInteractionLimit),
        if (expiry != _undefined)
          'expiry': (expiry as Enum$RepositoryInteractionLimitExpiry?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$SetOrganizationInteractionLimitInput<TRes>
    implements CopyWith$Input$SetOrganizationInteractionLimitInput<TRes> {
  _CopyWithStubImpl$Input$SetOrganizationInteractionLimitInput(this._res);

  TRes _res;

  call({
    String? organizationId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$SetRepositoryInteractionLimitInput {
  factory Input$SetRepositoryInteractionLimitInput({
    required String repositoryId,
    required Enum$RepositoryInteractionLimit limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    String? clientMutationId,
  }) =>
      Input$SetRepositoryInteractionLimitInput._({
        r'repositoryId': repositoryId,
        r'limit': limit,
        if (expiry != null) r'expiry': expiry,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$SetRepositoryInteractionLimitInput._(this._$data);

  factory Input$SetRepositoryInteractionLimitInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$limit = data['limit'];
    result$data['limit'] =
        fromJson$Enum$RepositoryInteractionLimit((l$limit as String));
    if (data.containsKey('expiry')) {
      final l$expiry = data['expiry'];
      result$data['expiry'] = l$expiry == null
          ? null
          : fromJson$Enum$RepositoryInteractionLimitExpiry(
              (l$expiry as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$SetRepositoryInteractionLimitInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  Enum$RepositoryInteractionLimit get limit =>
      (_$data['limit'] as Enum$RepositoryInteractionLimit);
  Enum$RepositoryInteractionLimitExpiry? get expiry =>
      (_$data['expiry'] as Enum$RepositoryInteractionLimitExpiry?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$limit = limit;
    result$data['limit'] = toJson$Enum$RepositoryInteractionLimit(l$limit);
    if (_$data.containsKey('expiry')) {
      final l$expiry = expiry;
      result$data['expiry'] = l$expiry == null
          ? null
          : toJson$Enum$RepositoryInteractionLimitExpiry(l$expiry);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$SetRepositoryInteractionLimitInput<
          Input$SetRepositoryInteractionLimitInput>
      get copyWith => CopyWith$Input$SetRepositoryInteractionLimitInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SetRepositoryInteractionLimitInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$expiry = expiry;
    final lOther$expiry = other.expiry;
    if (_$data.containsKey('expiry') != other._$data.containsKey('expiry')) {
      return false;
    }
    if (l$expiry != lOther$expiry) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$limit = limit;
    final l$expiry = expiry;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$limit,
      _$data.containsKey('expiry') ? l$expiry : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$SetRepositoryInteractionLimitInput<TRes> {
  factory CopyWith$Input$SetRepositoryInteractionLimitInput(
    Input$SetRepositoryInteractionLimitInput instance,
    TRes Function(Input$SetRepositoryInteractionLimitInput) then,
  ) = _CopyWithImpl$Input$SetRepositoryInteractionLimitInput;

  factory CopyWith$Input$SetRepositoryInteractionLimitInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetRepositoryInteractionLimitInput;

  TRes call({
    String? repositoryId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$SetRepositoryInteractionLimitInput<TRes>
    implements CopyWith$Input$SetRepositoryInteractionLimitInput<TRes> {
  _CopyWithImpl$Input$SetRepositoryInteractionLimitInput(
    this._instance,
    this._then,
  );

  final Input$SetRepositoryInteractionLimitInput _instance;

  final TRes Function(Input$SetRepositoryInteractionLimitInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? limit = _undefined,
    Object? expiry = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$SetRepositoryInteractionLimitInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (limit != _undefined && limit != null)
          'limit': (limit as Enum$RepositoryInteractionLimit),
        if (expiry != _undefined)
          'expiry': (expiry as Enum$RepositoryInteractionLimitExpiry?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$SetRepositoryInteractionLimitInput<TRes>
    implements CopyWith$Input$SetRepositoryInteractionLimitInput<TRes> {
  _CopyWithStubImpl$Input$SetRepositoryInteractionLimitInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$SetUserInteractionLimitInput {
  factory Input$SetUserInteractionLimitInput({
    required String userId,
    required Enum$RepositoryInteractionLimit limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    String? clientMutationId,
  }) =>
      Input$SetUserInteractionLimitInput._({
        r'userId': userId,
        r'limit': limit,
        if (expiry != null) r'expiry': expiry,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$SetUserInteractionLimitInput._(this._$data);

  factory Input$SetUserInteractionLimitInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    final l$limit = data['limit'];
    result$data['limit'] =
        fromJson$Enum$RepositoryInteractionLimit((l$limit as String));
    if (data.containsKey('expiry')) {
      final l$expiry = data['expiry'];
      result$data['expiry'] = l$expiry == null
          ? null
          : fromJson$Enum$RepositoryInteractionLimitExpiry(
              (l$expiry as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$SetUserInteractionLimitInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get userId => (_$data['userId'] as String);
  Enum$RepositoryInteractionLimit get limit =>
      (_$data['limit'] as Enum$RepositoryInteractionLimit);
  Enum$RepositoryInteractionLimitExpiry? get expiry =>
      (_$data['expiry'] as Enum$RepositoryInteractionLimitExpiry?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$userId = userId;
    result$data['userId'] = l$userId;
    final l$limit = limit;
    result$data['limit'] = toJson$Enum$RepositoryInteractionLimit(l$limit);
    if (_$data.containsKey('expiry')) {
      final l$expiry = expiry;
      result$data['expiry'] = l$expiry == null
          ? null
          : toJson$Enum$RepositoryInteractionLimitExpiry(l$expiry);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$SetUserInteractionLimitInput<
          Input$SetUserInteractionLimitInput>
      get copyWith => CopyWith$Input$SetUserInteractionLimitInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SetUserInteractionLimitInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$expiry = expiry;
    final lOther$expiry = other.expiry;
    if (_$data.containsKey('expiry') != other._$data.containsKey('expiry')) {
      return false;
    }
    if (l$expiry != lOther$expiry) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$limit = limit;
    final l$expiry = expiry;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$userId,
      l$limit,
      _$data.containsKey('expiry') ? l$expiry : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$SetUserInteractionLimitInput<TRes> {
  factory CopyWith$Input$SetUserInteractionLimitInput(
    Input$SetUserInteractionLimitInput instance,
    TRes Function(Input$SetUserInteractionLimitInput) then,
  ) = _CopyWithImpl$Input$SetUserInteractionLimitInput;

  factory CopyWith$Input$SetUserInteractionLimitInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetUserInteractionLimitInput;

  TRes call({
    String? userId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$SetUserInteractionLimitInput<TRes>
    implements CopyWith$Input$SetUserInteractionLimitInput<TRes> {
  _CopyWithImpl$Input$SetUserInteractionLimitInput(
    this._instance,
    this._then,
  );

  final Input$SetUserInteractionLimitInput _instance;

  final TRes Function(Input$SetUserInteractionLimitInput) _then;

  static const _undefined = {};

  TRes call({
    Object? userId = _undefined,
    Object? limit = _undefined,
    Object? expiry = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$SetUserInteractionLimitInput._({
        ..._instance._$data,
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
        if (limit != _undefined && limit != null)
          'limit': (limit as Enum$RepositoryInteractionLimit),
        if (expiry != _undefined)
          'expiry': (expiry as Enum$RepositoryInteractionLimitExpiry?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$SetUserInteractionLimitInput<TRes>
    implements CopyWith$Input$SetUserInteractionLimitInput<TRes> {
  _CopyWithStubImpl$Input$SetUserInteractionLimitInput(this._res);

  TRes _res;

  call({
    String? userId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$SponsorableOrder {
  factory Input$SponsorableOrder({
    required Enum$SponsorableOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorableOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorableOrder._(this._$data);

  factory Input$SponsorableOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorableOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorableOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorableOrderField get field =>
      (_$data['field'] as Enum$SponsorableOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorableOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorableOrder<Input$SponsorableOrder> get copyWith =>
      CopyWith$Input$SponsorableOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorableOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorableOrder<TRes> {
  factory CopyWith$Input$SponsorableOrder(
    Input$SponsorableOrder instance,
    TRes Function(Input$SponsorableOrder) then,
  ) = _CopyWithImpl$Input$SponsorableOrder;

  factory CopyWith$Input$SponsorableOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorableOrder;

  TRes call({
    Enum$SponsorableOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorableOrder<TRes>
    implements CopyWith$Input$SponsorableOrder<TRes> {
  _CopyWithImpl$Input$SponsorableOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorableOrder _instance;

  final TRes Function(Input$SponsorableOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorableOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorableOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorableOrder<TRes>
    implements CopyWith$Input$SponsorableOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorableOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorableOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SponsorOrder {
  factory Input$SponsorOrder({
    required Enum$SponsorOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorOrder._(this._$data);

  factory Input$SponsorOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$SponsorOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorOrderField get field =>
      (_$data['field'] as Enum$SponsorOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorOrder<Input$SponsorOrder> get copyWith =>
      CopyWith$Input$SponsorOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorOrder<TRes> {
  factory CopyWith$Input$SponsorOrder(
    Input$SponsorOrder instance,
    TRes Function(Input$SponsorOrder) then,
  ) = _CopyWithImpl$Input$SponsorOrder;

  factory CopyWith$Input$SponsorOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorOrder;

  TRes call({
    Enum$SponsorOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorOrder<TRes>
    implements CopyWith$Input$SponsorOrder<TRes> {
  _CopyWithImpl$Input$SponsorOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorOrder _instance;

  final TRes Function(Input$SponsorOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorOrder<TRes>
    implements CopyWith$Input$SponsorOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SponsorsActivityOrder {
  factory Input$SponsorsActivityOrder({
    required Enum$SponsorsActivityOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorsActivityOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorsActivityOrder._(this._$data);

  factory Input$SponsorsActivityOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorsActivityOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorsActivityOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorsActivityOrderField get field =>
      (_$data['field'] as Enum$SponsorsActivityOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorsActivityOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorsActivityOrder<Input$SponsorsActivityOrder>
      get copyWith => CopyWith$Input$SponsorsActivityOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorsActivityOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorsActivityOrder<TRes> {
  factory CopyWith$Input$SponsorsActivityOrder(
    Input$SponsorsActivityOrder instance,
    TRes Function(Input$SponsorsActivityOrder) then,
  ) = _CopyWithImpl$Input$SponsorsActivityOrder;

  factory CopyWith$Input$SponsorsActivityOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorsActivityOrder;

  TRes call({
    Enum$SponsorsActivityOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorsActivityOrder<TRes>
    implements CopyWith$Input$SponsorsActivityOrder<TRes> {
  _CopyWithImpl$Input$SponsorsActivityOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorsActivityOrder _instance;

  final TRes Function(Input$SponsorsActivityOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorsActivityOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorsActivityOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorsActivityOrder<TRes>
    implements CopyWith$Input$SponsorsActivityOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorsActivityOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorsActivityOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SponsorshipNewsletterOrder {
  factory Input$SponsorshipNewsletterOrder({
    required Enum$SponsorshipNewsletterOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorshipNewsletterOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorshipNewsletterOrder._(this._$data);

  factory Input$SponsorshipNewsletterOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorshipNewsletterOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorshipNewsletterOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorshipNewsletterOrderField get field =>
      (_$data['field'] as Enum$SponsorshipNewsletterOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorshipNewsletterOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorshipNewsletterOrder<Input$SponsorshipNewsletterOrder>
      get copyWith => CopyWith$Input$SponsorshipNewsletterOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorshipNewsletterOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorshipNewsletterOrder<TRes> {
  factory CopyWith$Input$SponsorshipNewsletterOrder(
    Input$SponsorshipNewsletterOrder instance,
    TRes Function(Input$SponsorshipNewsletterOrder) then,
  ) = _CopyWithImpl$Input$SponsorshipNewsletterOrder;

  factory CopyWith$Input$SponsorshipNewsletterOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorshipNewsletterOrder;

  TRes call({
    Enum$SponsorshipNewsletterOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorshipNewsletterOrder<TRes>
    implements CopyWith$Input$SponsorshipNewsletterOrder<TRes> {
  _CopyWithImpl$Input$SponsorshipNewsletterOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorshipNewsletterOrder _instance;

  final TRes Function(Input$SponsorshipNewsletterOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorshipNewsletterOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorshipNewsletterOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorshipNewsletterOrder<TRes>
    implements CopyWith$Input$SponsorshipNewsletterOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorshipNewsletterOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorshipNewsletterOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SponsorshipOrder {
  factory Input$SponsorshipOrder({
    required Enum$SponsorshipOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorshipOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorshipOrder._(this._$data);

  factory Input$SponsorshipOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorshipOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorshipOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorshipOrderField get field =>
      (_$data['field'] as Enum$SponsorshipOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorshipOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorshipOrder<Input$SponsorshipOrder> get copyWith =>
      CopyWith$Input$SponsorshipOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorshipOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorshipOrder<TRes> {
  factory CopyWith$Input$SponsorshipOrder(
    Input$SponsorshipOrder instance,
    TRes Function(Input$SponsorshipOrder) then,
  ) = _CopyWithImpl$Input$SponsorshipOrder;

  factory CopyWith$Input$SponsorshipOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorshipOrder;

  TRes call({
    Enum$SponsorshipOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorshipOrder<TRes>
    implements CopyWith$Input$SponsorshipOrder<TRes> {
  _CopyWithImpl$Input$SponsorshipOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorshipOrder _instance;

  final TRes Function(Input$SponsorshipOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorshipOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorshipOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorshipOrder<TRes>
    implements CopyWith$Input$SponsorshipOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorshipOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorshipOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SponsorsTierOrder {
  factory Input$SponsorsTierOrder({
    required Enum$SponsorsTierOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorsTierOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorsTierOrder._(this._$data);

  factory Input$SponsorsTierOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorsTierOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorsTierOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorsTierOrderField get field =>
      (_$data['field'] as Enum$SponsorsTierOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorsTierOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorsTierOrder<Input$SponsorsTierOrder> get copyWith =>
      CopyWith$Input$SponsorsTierOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorsTierOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorsTierOrder<TRes> {
  factory CopyWith$Input$SponsorsTierOrder(
    Input$SponsorsTierOrder instance,
    TRes Function(Input$SponsorsTierOrder) then,
  ) = _CopyWithImpl$Input$SponsorsTierOrder;

  factory CopyWith$Input$SponsorsTierOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorsTierOrder;

  TRes call({
    Enum$SponsorsTierOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorsTierOrder<TRes>
    implements CopyWith$Input$SponsorsTierOrder<TRes> {
  _CopyWithImpl$Input$SponsorsTierOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorsTierOrder _instance;

  final TRes Function(Input$SponsorsTierOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorsTierOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorsTierOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorsTierOrder<TRes>
    implements CopyWith$Input$SponsorsTierOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorsTierOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorsTierOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$StarOrder {
  factory Input$StarOrder({
    required Enum$StarOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$StarOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$StarOrder._(this._$data);

  factory Input$StarOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$StarOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$StarOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$StarOrderField get field => (_$data['field'] as Enum$StarOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$StarOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$StarOrder<Input$StarOrder> get copyWith =>
      CopyWith$Input$StarOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StarOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$StarOrder<TRes> {
  factory CopyWith$Input$StarOrder(
    Input$StarOrder instance,
    TRes Function(Input$StarOrder) then,
  ) = _CopyWithImpl$Input$StarOrder;

  factory CopyWith$Input$StarOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$StarOrder;

  TRes call({
    Enum$StarOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$StarOrder<TRes>
    implements CopyWith$Input$StarOrder<TRes> {
  _CopyWithImpl$Input$StarOrder(
    this._instance,
    this._then,
  );

  final Input$StarOrder _instance;

  final TRes Function(Input$StarOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$StarOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$StarOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$StarOrder<TRes>
    implements CopyWith$Input$StarOrder<TRes> {
  _CopyWithStubImpl$Input$StarOrder(this._res);

  TRes _res;

  call({
    Enum$StarOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$StartRepositoryMigrationInput {
  factory Input$StartRepositoryMigrationInput({
    required String sourceId,
    required String ownerId,
    required String sourceRepositoryUrl,
    required String repositoryName,
    bool? continueOnError,
    String? gitArchiveUrl,
    String? metadataArchiveUrl,
    required String accessToken,
    String? githubPat,
    bool? skipReleases,
    String? targetRepoVisibility,
    bool? lockSource,
    String? clientMutationId,
  }) =>
      Input$StartRepositoryMigrationInput._({
        r'sourceId': sourceId,
        r'ownerId': ownerId,
        r'sourceRepositoryUrl': sourceRepositoryUrl,
        r'repositoryName': repositoryName,
        if (continueOnError != null) r'continueOnError': continueOnError,
        if (gitArchiveUrl != null) r'gitArchiveUrl': gitArchiveUrl,
        if (metadataArchiveUrl != null)
          r'metadataArchiveUrl': metadataArchiveUrl,
        r'accessToken': accessToken,
        if (githubPat != null) r'githubPat': githubPat,
        if (skipReleases != null) r'skipReleases': skipReleases,
        if (targetRepoVisibility != null)
          r'targetRepoVisibility': targetRepoVisibility,
        if (lockSource != null) r'lockSource': lockSource,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$StartRepositoryMigrationInput._(this._$data);

  factory Input$StartRepositoryMigrationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$sourceId = data['sourceId'];
    result$data['sourceId'] = (l$sourceId as String);
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$sourceRepositoryUrl = data['sourceRepositoryUrl'];
    result$data['sourceRepositoryUrl'] = (l$sourceRepositoryUrl as String);
    final l$repositoryName = data['repositoryName'];
    result$data['repositoryName'] = (l$repositoryName as String);
    if (data.containsKey('continueOnError')) {
      final l$continueOnError = data['continueOnError'];
      result$data['continueOnError'] = (l$continueOnError as bool?);
    }
    if (data.containsKey('gitArchiveUrl')) {
      final l$gitArchiveUrl = data['gitArchiveUrl'];
      result$data['gitArchiveUrl'] = (l$gitArchiveUrl as String?);
    }
    if (data.containsKey('metadataArchiveUrl')) {
      final l$metadataArchiveUrl = data['metadataArchiveUrl'];
      result$data['metadataArchiveUrl'] = (l$metadataArchiveUrl as String?);
    }
    final l$accessToken = data['accessToken'];
    result$data['accessToken'] = (l$accessToken as String);
    if (data.containsKey('githubPat')) {
      final l$githubPat = data['githubPat'];
      result$data['githubPat'] = (l$githubPat as String?);
    }
    if (data.containsKey('skipReleases')) {
      final l$skipReleases = data['skipReleases'];
      result$data['skipReleases'] = (l$skipReleases as bool?);
    }
    if (data.containsKey('targetRepoVisibility')) {
      final l$targetRepoVisibility = data['targetRepoVisibility'];
      result$data['targetRepoVisibility'] = (l$targetRepoVisibility as String?);
    }
    if (data.containsKey('lockSource')) {
      final l$lockSource = data['lockSource'];
      result$data['lockSource'] = (l$lockSource as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$StartRepositoryMigrationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get sourceId => (_$data['sourceId'] as String);
  String get ownerId => (_$data['ownerId'] as String);
  String get sourceRepositoryUrl => (_$data['sourceRepositoryUrl'] as String);
  String get repositoryName => (_$data['repositoryName'] as String);
  bool? get continueOnError => (_$data['continueOnError'] as bool?);
  String? get gitArchiveUrl => (_$data['gitArchiveUrl'] as String?);
  String? get metadataArchiveUrl => (_$data['metadataArchiveUrl'] as String?);
  String get accessToken => (_$data['accessToken'] as String);
  String? get githubPat => (_$data['githubPat'] as String?);
  bool? get skipReleases => (_$data['skipReleases'] as bool?);
  String? get targetRepoVisibility =>
      (_$data['targetRepoVisibility'] as String?);
  bool? get lockSource => (_$data['lockSource'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$sourceId = sourceId;
    result$data['sourceId'] = l$sourceId;
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$sourceRepositoryUrl = sourceRepositoryUrl;
    result$data['sourceRepositoryUrl'] = l$sourceRepositoryUrl;
    final l$repositoryName = repositoryName;
    result$data['repositoryName'] = l$repositoryName;
    if (_$data.containsKey('continueOnError')) {
      final l$continueOnError = continueOnError;
      result$data['continueOnError'] = l$continueOnError;
    }
    if (_$data.containsKey('gitArchiveUrl')) {
      final l$gitArchiveUrl = gitArchiveUrl;
      result$data['gitArchiveUrl'] = l$gitArchiveUrl;
    }
    if (_$data.containsKey('metadataArchiveUrl')) {
      final l$metadataArchiveUrl = metadataArchiveUrl;
      result$data['metadataArchiveUrl'] = l$metadataArchiveUrl;
    }
    final l$accessToken = accessToken;
    result$data['accessToken'] = l$accessToken;
    if (_$data.containsKey('githubPat')) {
      final l$githubPat = githubPat;
      result$data['githubPat'] = l$githubPat;
    }
    if (_$data.containsKey('skipReleases')) {
      final l$skipReleases = skipReleases;
      result$data['skipReleases'] = l$skipReleases;
    }
    if (_$data.containsKey('targetRepoVisibility')) {
      final l$targetRepoVisibility = targetRepoVisibility;
      result$data['targetRepoVisibility'] = l$targetRepoVisibility;
    }
    if (_$data.containsKey('lockSource')) {
      final l$lockSource = lockSource;
      result$data['lockSource'] = l$lockSource;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$StartRepositoryMigrationInput<
          Input$StartRepositoryMigrationInput>
      get copyWith => CopyWith$Input$StartRepositoryMigrationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StartRepositoryMigrationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$sourceId = sourceId;
    final lOther$sourceId = other.sourceId;
    if (l$sourceId != lOther$sourceId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$sourceRepositoryUrl = sourceRepositoryUrl;
    final lOther$sourceRepositoryUrl = other.sourceRepositoryUrl;
    if (l$sourceRepositoryUrl != lOther$sourceRepositoryUrl) {
      return false;
    }
    final l$repositoryName = repositoryName;
    final lOther$repositoryName = other.repositoryName;
    if (l$repositoryName != lOther$repositoryName) {
      return false;
    }
    final l$continueOnError = continueOnError;
    final lOther$continueOnError = other.continueOnError;
    if (_$data.containsKey('continueOnError') !=
        other._$data.containsKey('continueOnError')) {
      return false;
    }
    if (l$continueOnError != lOther$continueOnError) {
      return false;
    }
    final l$gitArchiveUrl = gitArchiveUrl;
    final lOther$gitArchiveUrl = other.gitArchiveUrl;
    if (_$data.containsKey('gitArchiveUrl') !=
        other._$data.containsKey('gitArchiveUrl')) {
      return false;
    }
    if (l$gitArchiveUrl != lOther$gitArchiveUrl) {
      return false;
    }
    final l$metadataArchiveUrl = metadataArchiveUrl;
    final lOther$metadataArchiveUrl = other.metadataArchiveUrl;
    if (_$data.containsKey('metadataArchiveUrl') !=
        other._$data.containsKey('metadataArchiveUrl')) {
      return false;
    }
    if (l$metadataArchiveUrl != lOther$metadataArchiveUrl) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$githubPat = githubPat;
    final lOther$githubPat = other.githubPat;
    if (_$data.containsKey('githubPat') !=
        other._$data.containsKey('githubPat')) {
      return false;
    }
    if (l$githubPat != lOther$githubPat) {
      return false;
    }
    final l$skipReleases = skipReleases;
    final lOther$skipReleases = other.skipReleases;
    if (_$data.containsKey('skipReleases') !=
        other._$data.containsKey('skipReleases')) {
      return false;
    }
    if (l$skipReleases != lOther$skipReleases) {
      return false;
    }
    final l$targetRepoVisibility = targetRepoVisibility;
    final lOther$targetRepoVisibility = other.targetRepoVisibility;
    if (_$data.containsKey('targetRepoVisibility') !=
        other._$data.containsKey('targetRepoVisibility')) {
      return false;
    }
    if (l$targetRepoVisibility != lOther$targetRepoVisibility) {
      return false;
    }
    final l$lockSource = lockSource;
    final lOther$lockSource = other.lockSource;
    if (_$data.containsKey('lockSource') !=
        other._$data.containsKey('lockSource')) {
      return false;
    }
    if (l$lockSource != lOther$lockSource) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sourceId = sourceId;
    final l$ownerId = ownerId;
    final l$sourceRepositoryUrl = sourceRepositoryUrl;
    final l$repositoryName = repositoryName;
    final l$continueOnError = continueOnError;
    final l$gitArchiveUrl = gitArchiveUrl;
    final l$metadataArchiveUrl = metadataArchiveUrl;
    final l$accessToken = accessToken;
    final l$githubPat = githubPat;
    final l$skipReleases = skipReleases;
    final l$targetRepoVisibility = targetRepoVisibility;
    final l$lockSource = lockSource;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$sourceId,
      l$ownerId,
      l$sourceRepositoryUrl,
      l$repositoryName,
      _$data.containsKey('continueOnError') ? l$continueOnError : const {},
      _$data.containsKey('gitArchiveUrl') ? l$gitArchiveUrl : const {},
      _$data.containsKey('metadataArchiveUrl')
          ? l$metadataArchiveUrl
          : const {},
      l$accessToken,
      _$data.containsKey('githubPat') ? l$githubPat : const {},
      _$data.containsKey('skipReleases') ? l$skipReleases : const {},
      _$data.containsKey('targetRepoVisibility')
          ? l$targetRepoVisibility
          : const {},
      _$data.containsKey('lockSource') ? l$lockSource : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$StartRepositoryMigrationInput<TRes> {
  factory CopyWith$Input$StartRepositoryMigrationInput(
    Input$StartRepositoryMigrationInput instance,
    TRes Function(Input$StartRepositoryMigrationInput) then,
  ) = _CopyWithImpl$Input$StartRepositoryMigrationInput;

  factory CopyWith$Input$StartRepositoryMigrationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StartRepositoryMigrationInput;

  TRes call({
    String? sourceId,
    String? ownerId,
    String? sourceRepositoryUrl,
    String? repositoryName,
    bool? continueOnError,
    String? gitArchiveUrl,
    String? metadataArchiveUrl,
    String? accessToken,
    String? githubPat,
    bool? skipReleases,
    String? targetRepoVisibility,
    bool? lockSource,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$StartRepositoryMigrationInput<TRes>
    implements CopyWith$Input$StartRepositoryMigrationInput<TRes> {
  _CopyWithImpl$Input$StartRepositoryMigrationInput(
    this._instance,
    this._then,
  );

  final Input$StartRepositoryMigrationInput _instance;

  final TRes Function(Input$StartRepositoryMigrationInput) _then;

  static const _undefined = {};

  TRes call({
    Object? sourceId = _undefined,
    Object? ownerId = _undefined,
    Object? sourceRepositoryUrl = _undefined,
    Object? repositoryName = _undefined,
    Object? continueOnError = _undefined,
    Object? gitArchiveUrl = _undefined,
    Object? metadataArchiveUrl = _undefined,
    Object? accessToken = _undefined,
    Object? githubPat = _undefined,
    Object? skipReleases = _undefined,
    Object? targetRepoVisibility = _undefined,
    Object? lockSource = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$StartRepositoryMigrationInput._({
        ..._instance._$data,
        if (sourceId != _undefined && sourceId != null)
          'sourceId': (sourceId as String),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (sourceRepositoryUrl != _undefined && sourceRepositoryUrl != null)
          'sourceRepositoryUrl': (sourceRepositoryUrl as String),
        if (repositoryName != _undefined && repositoryName != null)
          'repositoryName': (repositoryName as String),
        if (continueOnError != _undefined)
          'continueOnError': (continueOnError as bool?),
        if (gitArchiveUrl != _undefined)
          'gitArchiveUrl': (gitArchiveUrl as String?),
        if (metadataArchiveUrl != _undefined)
          'metadataArchiveUrl': (metadataArchiveUrl as String?),
        if (accessToken != _undefined && accessToken != null)
          'accessToken': (accessToken as String),
        if (githubPat != _undefined) 'githubPat': (githubPat as String?),
        if (skipReleases != _undefined) 'skipReleases': (skipReleases as bool?),
        if (targetRepoVisibility != _undefined)
          'targetRepoVisibility': (targetRepoVisibility as String?),
        if (lockSource != _undefined) 'lockSource': (lockSource as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$StartRepositoryMigrationInput<TRes>
    implements CopyWith$Input$StartRepositoryMigrationInput<TRes> {
  _CopyWithStubImpl$Input$StartRepositoryMigrationInput(this._res);

  TRes _res;

  call({
    String? sourceId,
    String? ownerId,
    String? sourceRepositoryUrl,
    String? repositoryName,
    bool? continueOnError,
    String? gitArchiveUrl,
    String? metadataArchiveUrl,
    String? accessToken,
    String? githubPat,
    bool? skipReleases,
    String? targetRepoVisibility,
    bool? lockSource,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$SubmitPullRequestReviewInput {
  factory Input$SubmitPullRequestReviewInput({
    String? pullRequestId,
    String? pullRequestReviewId,
    required Enum$PullRequestReviewEvent event,
    String? body,
    String? clientMutationId,
  }) =>
      Input$SubmitPullRequestReviewInput._({
        if (pullRequestId != null) r'pullRequestId': pullRequestId,
        if (pullRequestReviewId != null)
          r'pullRequestReviewId': pullRequestReviewId,
        r'event': event,
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$SubmitPullRequestReviewInput._(this._$data);

  factory Input$SubmitPullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('pullRequestId')) {
      final l$pullRequestId = data['pullRequestId'];
      result$data['pullRequestId'] = (l$pullRequestId as String?);
    }
    if (data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = data['pullRequestReviewId'];
      result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String?);
    }
    final l$event = data['event'];
    result$data['event'] =
        fromJson$Enum$PullRequestReviewEvent((l$event as String));
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$SubmitPullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get pullRequestId => (_$data['pullRequestId'] as String?);
  String? get pullRequestReviewId => (_$data['pullRequestReviewId'] as String?);
  Enum$PullRequestReviewEvent get event =>
      (_$data['event'] as Enum$PullRequestReviewEvent);
  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('pullRequestId')) {
      final l$pullRequestId = pullRequestId;
      result$data['pullRequestId'] = l$pullRequestId;
    }
    if (_$data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = pullRequestReviewId;
      result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    }
    final l$event = event;
    result$data['event'] = toJson$Enum$PullRequestReviewEvent(l$event);
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$SubmitPullRequestReviewInput<
          Input$SubmitPullRequestReviewInput>
      get copyWith => CopyWith$Input$SubmitPullRequestReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SubmitPullRequestReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (_$data.containsKey('pullRequestId') !=
        other._$data.containsKey('pullRequestId')) {
      return false;
    }
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (_$data.containsKey('pullRequestReviewId') !=
        other._$data.containsKey('pullRequestReviewId')) {
      return false;
    }
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (l$event != lOther$event) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$event = event;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('pullRequestId') ? l$pullRequestId : const {},
      _$data.containsKey('pullRequestReviewId')
          ? l$pullRequestReviewId
          : const {},
      l$event,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubmitPullRequestReviewInput<TRes> {
  factory CopyWith$Input$SubmitPullRequestReviewInput(
    Input$SubmitPullRequestReviewInput instance,
    TRes Function(Input$SubmitPullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$SubmitPullRequestReviewInput;

  factory CopyWith$Input$SubmitPullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubmitPullRequestReviewInput;

  TRes call({
    String? pullRequestId,
    String? pullRequestReviewId,
    Enum$PullRequestReviewEvent? event,
    String? body,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$SubmitPullRequestReviewInput<TRes>
    implements CopyWith$Input$SubmitPullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$SubmitPullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$SubmitPullRequestReviewInput _instance;

  final TRes Function(Input$SubmitPullRequestReviewInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? pullRequestReviewId = _undefined,
    Object? event = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$SubmitPullRequestReviewInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined)
          'pullRequestId': (pullRequestId as String?),
        if (pullRequestReviewId != _undefined)
          'pullRequestReviewId': (pullRequestReviewId as String?),
        if (event != _undefined && event != null)
          'event': (event as Enum$PullRequestReviewEvent),
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$SubmitPullRequestReviewInput<TRes>
    implements CopyWith$Input$SubmitPullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$SubmitPullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? pullRequestReviewId,
    Enum$PullRequestReviewEvent? event,
    String? body,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$TeamDiscussionCommentOrder {
  factory Input$TeamDiscussionCommentOrder({
    required Enum$TeamDiscussionCommentOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$TeamDiscussionCommentOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$TeamDiscussionCommentOrder._(this._$data);

  factory Input$TeamDiscussionCommentOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamDiscussionCommentOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$TeamDiscussionCommentOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TeamDiscussionCommentOrderField get field =>
      (_$data['field'] as Enum$TeamDiscussionCommentOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamDiscussionCommentOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$TeamDiscussionCommentOrder<Input$TeamDiscussionCommentOrder>
      get copyWith => CopyWith$Input$TeamDiscussionCommentOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TeamDiscussionCommentOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$TeamDiscussionCommentOrder<TRes> {
  factory CopyWith$Input$TeamDiscussionCommentOrder(
    Input$TeamDiscussionCommentOrder instance,
    TRes Function(Input$TeamDiscussionCommentOrder) then,
  ) = _CopyWithImpl$Input$TeamDiscussionCommentOrder;

  factory CopyWith$Input$TeamDiscussionCommentOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamDiscussionCommentOrder;

  TRes call({
    Enum$TeamDiscussionCommentOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$TeamDiscussionCommentOrder<TRes>
    implements CopyWith$Input$TeamDiscussionCommentOrder<TRes> {
  _CopyWithImpl$Input$TeamDiscussionCommentOrder(
    this._instance,
    this._then,
  );

  final Input$TeamDiscussionCommentOrder _instance;

  final TRes Function(Input$TeamDiscussionCommentOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$TeamDiscussionCommentOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamDiscussionCommentOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$TeamDiscussionCommentOrder<TRes>
    implements CopyWith$Input$TeamDiscussionCommentOrder<TRes> {
  _CopyWithStubImpl$Input$TeamDiscussionCommentOrder(this._res);

  TRes _res;

  call({
    Enum$TeamDiscussionCommentOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$TeamDiscussionOrder {
  factory Input$TeamDiscussionOrder({
    required Enum$TeamDiscussionOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$TeamDiscussionOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$TeamDiscussionOrder._(this._$data);

  factory Input$TeamDiscussionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamDiscussionOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$TeamDiscussionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TeamDiscussionOrderField get field =>
      (_$data['field'] as Enum$TeamDiscussionOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamDiscussionOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$TeamDiscussionOrder<Input$TeamDiscussionOrder> get copyWith =>
      CopyWith$Input$TeamDiscussionOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TeamDiscussionOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$TeamDiscussionOrder<TRes> {
  factory CopyWith$Input$TeamDiscussionOrder(
    Input$TeamDiscussionOrder instance,
    TRes Function(Input$TeamDiscussionOrder) then,
  ) = _CopyWithImpl$Input$TeamDiscussionOrder;

  factory CopyWith$Input$TeamDiscussionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamDiscussionOrder;

  TRes call({
    Enum$TeamDiscussionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$TeamDiscussionOrder<TRes>
    implements CopyWith$Input$TeamDiscussionOrder<TRes> {
  _CopyWithImpl$Input$TeamDiscussionOrder(
    this._instance,
    this._then,
  );

  final Input$TeamDiscussionOrder _instance;

  final TRes Function(Input$TeamDiscussionOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$TeamDiscussionOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamDiscussionOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$TeamDiscussionOrder<TRes>
    implements CopyWith$Input$TeamDiscussionOrder<TRes> {
  _CopyWithStubImpl$Input$TeamDiscussionOrder(this._res);

  TRes _res;

  call({
    Enum$TeamDiscussionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$TeamMemberOrder {
  factory Input$TeamMemberOrder({
    required Enum$TeamMemberOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$TeamMemberOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$TeamMemberOrder._(this._$data);

  factory Input$TeamMemberOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamMemberOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$TeamMemberOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TeamMemberOrderField get field =>
      (_$data['field'] as Enum$TeamMemberOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamMemberOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$TeamMemberOrder<Input$TeamMemberOrder> get copyWith =>
      CopyWith$Input$TeamMemberOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TeamMemberOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$TeamMemberOrder<TRes> {
  factory CopyWith$Input$TeamMemberOrder(
    Input$TeamMemberOrder instance,
    TRes Function(Input$TeamMemberOrder) then,
  ) = _CopyWithImpl$Input$TeamMemberOrder;

  factory CopyWith$Input$TeamMemberOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamMemberOrder;

  TRes call({
    Enum$TeamMemberOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$TeamMemberOrder<TRes>
    implements CopyWith$Input$TeamMemberOrder<TRes> {
  _CopyWithImpl$Input$TeamMemberOrder(
    this._instance,
    this._then,
  );

  final Input$TeamMemberOrder _instance;

  final TRes Function(Input$TeamMemberOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$TeamMemberOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamMemberOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$TeamMemberOrder<TRes>
    implements CopyWith$Input$TeamMemberOrder<TRes> {
  _CopyWithStubImpl$Input$TeamMemberOrder(this._res);

  TRes _res;

  call({
    Enum$TeamMemberOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$TeamOrder {
  factory Input$TeamOrder({
    required Enum$TeamOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$TeamOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$TeamOrder._(this._$data);

  factory Input$TeamOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$TeamOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$TeamOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TeamOrderField get field => (_$data['field'] as Enum$TeamOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$TeamOrder<Input$TeamOrder> get copyWith =>
      CopyWith$Input$TeamOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TeamOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$TeamOrder<TRes> {
  factory CopyWith$Input$TeamOrder(
    Input$TeamOrder instance,
    TRes Function(Input$TeamOrder) then,
  ) = _CopyWithImpl$Input$TeamOrder;

  factory CopyWith$Input$TeamOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamOrder;

  TRes call({
    Enum$TeamOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$TeamOrder<TRes>
    implements CopyWith$Input$TeamOrder<TRes> {
  _CopyWithImpl$Input$TeamOrder(
    this._instance,
    this._then,
  );

  final Input$TeamOrder _instance;

  final TRes Function(Input$TeamOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$TeamOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$TeamOrder<TRes>
    implements CopyWith$Input$TeamOrder<TRes> {
  _CopyWithStubImpl$Input$TeamOrder(this._res);

  TRes _res;

  call({
    Enum$TeamOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$TeamRepositoryOrder {
  factory Input$TeamRepositoryOrder({
    required Enum$TeamRepositoryOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$TeamRepositoryOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$TeamRepositoryOrder._(this._$data);

  factory Input$TeamRepositoryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamRepositoryOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$TeamRepositoryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TeamRepositoryOrderField get field =>
      (_$data['field'] as Enum$TeamRepositoryOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamRepositoryOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$TeamRepositoryOrder<Input$TeamRepositoryOrder> get copyWith =>
      CopyWith$Input$TeamRepositoryOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TeamRepositoryOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$TeamRepositoryOrder<TRes> {
  factory CopyWith$Input$TeamRepositoryOrder(
    Input$TeamRepositoryOrder instance,
    TRes Function(Input$TeamRepositoryOrder) then,
  ) = _CopyWithImpl$Input$TeamRepositoryOrder;

  factory CopyWith$Input$TeamRepositoryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamRepositoryOrder;

  TRes call({
    Enum$TeamRepositoryOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$TeamRepositoryOrder<TRes>
    implements CopyWith$Input$TeamRepositoryOrder<TRes> {
  _CopyWithImpl$Input$TeamRepositoryOrder(
    this._instance,
    this._then,
  );

  final Input$TeamRepositoryOrder _instance;

  final TRes Function(Input$TeamRepositoryOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$TeamRepositoryOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamRepositoryOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$TeamRepositoryOrder<TRes>
    implements CopyWith$Input$TeamRepositoryOrder<TRes> {
  _CopyWithStubImpl$Input$TeamRepositoryOrder(this._res);

  TRes _res;

  call({
    Enum$TeamRepositoryOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$TransferEnterpriseOrganizationInput {
  factory Input$TransferEnterpriseOrganizationInput({
    required String organizationId,
    required String destinationEnterpriseId,
    String? clientMutationId,
  }) =>
      Input$TransferEnterpriseOrganizationInput._({
        r'organizationId': organizationId,
        r'destinationEnterpriseId': destinationEnterpriseId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$TransferEnterpriseOrganizationInput._(this._$data);

  factory Input$TransferEnterpriseOrganizationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$destinationEnterpriseId = data['destinationEnterpriseId'];
    result$data['destinationEnterpriseId'] =
        (l$destinationEnterpriseId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$TransferEnterpriseOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get organizationId => (_$data['organizationId'] as String);
  String get destinationEnterpriseId =>
      (_$data['destinationEnterpriseId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$destinationEnterpriseId = destinationEnterpriseId;
    result$data['destinationEnterpriseId'] = l$destinationEnterpriseId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$TransferEnterpriseOrganizationInput<
          Input$TransferEnterpriseOrganizationInput>
      get copyWith => CopyWith$Input$TransferEnterpriseOrganizationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferEnterpriseOrganizationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$destinationEnterpriseId = destinationEnterpriseId;
    final lOther$destinationEnterpriseId = other.destinationEnterpriseId;
    if (l$destinationEnterpriseId != lOther$destinationEnterpriseId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$organizationId = organizationId;
    final l$destinationEnterpriseId = destinationEnterpriseId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$organizationId,
      l$destinationEnterpriseId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferEnterpriseOrganizationInput<TRes> {
  factory CopyWith$Input$TransferEnterpriseOrganizationInput(
    Input$TransferEnterpriseOrganizationInput instance,
    TRes Function(Input$TransferEnterpriseOrganizationInput) then,
  ) = _CopyWithImpl$Input$TransferEnterpriseOrganizationInput;

  factory CopyWith$Input$TransferEnterpriseOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferEnterpriseOrganizationInput;

  TRes call({
    String? organizationId,
    String? destinationEnterpriseId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$TransferEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$TransferEnterpriseOrganizationInput<TRes> {
  _CopyWithImpl$Input$TransferEnterpriseOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$TransferEnterpriseOrganizationInput _instance;

  final TRes Function(Input$TransferEnterpriseOrganizationInput) _then;

  static const _undefined = {};

  TRes call({
    Object? organizationId = _undefined,
    Object? destinationEnterpriseId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$TransferEnterpriseOrganizationInput._({
        ..._instance._$data,
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (destinationEnterpriseId != _undefined &&
            destinationEnterpriseId != null)
          'destinationEnterpriseId': (destinationEnterpriseId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$TransferEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$TransferEnterpriseOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$TransferEnterpriseOrganizationInput(this._res);

  TRes _res;

  call({
    String? organizationId,
    String? destinationEnterpriseId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$TransferIssueInput {
  factory Input$TransferIssueInput({
    required String issueId,
    required String repositoryId,
    bool? createLabelsIfMissing,
    String? clientMutationId,
  }) =>
      Input$TransferIssueInput._({
        r'issueId': issueId,
        r'repositoryId': repositoryId,
        if (createLabelsIfMissing != null)
          r'createLabelsIfMissing': createLabelsIfMissing,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$TransferIssueInput._(this._$data);

  factory Input$TransferIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('createLabelsIfMissing')) {
      final l$createLabelsIfMissing = data['createLabelsIfMissing'];
      result$data['createLabelsIfMissing'] = (l$createLabelsIfMissing as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$TransferIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get issueId => (_$data['issueId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  bool? get createLabelsIfMissing => (_$data['createLabelsIfMissing'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('createLabelsIfMissing')) {
      final l$createLabelsIfMissing = createLabelsIfMissing;
      result$data['createLabelsIfMissing'] = l$createLabelsIfMissing;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$TransferIssueInput<Input$TransferIssueInput> get copyWith =>
      CopyWith$Input$TransferIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$createLabelsIfMissing = createLabelsIfMissing;
    final lOther$createLabelsIfMissing = other.createLabelsIfMissing;
    if (_$data.containsKey('createLabelsIfMissing') !=
        other._$data.containsKey('createLabelsIfMissing')) {
      return false;
    }
    if (l$createLabelsIfMissing != lOther$createLabelsIfMissing) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$issueId = issueId;
    final l$repositoryId = repositoryId;
    final l$createLabelsIfMissing = createLabelsIfMissing;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$issueId,
      l$repositoryId,
      _$data.containsKey('createLabelsIfMissing')
          ? l$createLabelsIfMissing
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferIssueInput<TRes> {
  factory CopyWith$Input$TransferIssueInput(
    Input$TransferIssueInput instance,
    TRes Function(Input$TransferIssueInput) then,
  ) = _CopyWithImpl$Input$TransferIssueInput;

  factory CopyWith$Input$TransferIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferIssueInput;

  TRes call({
    String? issueId,
    String? repositoryId,
    bool? createLabelsIfMissing,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$TransferIssueInput<TRes>
    implements CopyWith$Input$TransferIssueInput<TRes> {
  _CopyWithImpl$Input$TransferIssueInput(
    this._instance,
    this._then,
  );

  final Input$TransferIssueInput _instance;

  final TRes Function(Input$TransferIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? issueId = _undefined,
    Object? repositoryId = _undefined,
    Object? createLabelsIfMissing = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$TransferIssueInput._({
        ..._instance._$data,
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (createLabelsIfMissing != _undefined)
          'createLabelsIfMissing': (createLabelsIfMissing as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$TransferIssueInput<TRes>
    implements CopyWith$Input$TransferIssueInput<TRes> {
  _CopyWithStubImpl$Input$TransferIssueInput(this._res);

  TRes _res;

  call({
    String? issueId,
    String? repositoryId,
    bool? createLabelsIfMissing,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnarchiveProjectV2ItemInput {
  factory Input$UnarchiveProjectV2ItemInput({
    required String projectId,
    required String itemId,
    String? clientMutationId,
  }) =>
      Input$UnarchiveProjectV2ItemInput._({
        r'projectId': projectId,
        r'itemId': itemId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnarchiveProjectV2ItemInput._(this._$data);

  factory Input$UnarchiveProjectV2ItemInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnarchiveProjectV2ItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get itemId => (_$data['itemId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnarchiveProjectV2ItemInput<Input$UnarchiveProjectV2ItemInput>
      get copyWith => CopyWith$Input$UnarchiveProjectV2ItemInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnarchiveProjectV2ItemInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$itemId = itemId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$itemId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnarchiveProjectV2ItemInput<TRes> {
  factory CopyWith$Input$UnarchiveProjectV2ItemInput(
    Input$UnarchiveProjectV2ItemInput instance,
    TRes Function(Input$UnarchiveProjectV2ItemInput) then,
  ) = _CopyWithImpl$Input$UnarchiveProjectV2ItemInput;

  factory CopyWith$Input$UnarchiveProjectV2ItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnarchiveProjectV2ItemInput;

  TRes call({
    String? projectId,
    String? itemId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnarchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$UnarchiveProjectV2ItemInput<TRes> {
  _CopyWithImpl$Input$UnarchiveProjectV2ItemInput(
    this._instance,
    this._then,
  );

  final Input$UnarchiveProjectV2ItemInput _instance;

  final TRes Function(Input$UnarchiveProjectV2ItemInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? itemId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnarchiveProjectV2ItemInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnarchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$UnarchiveProjectV2ItemInput<TRes> {
  _CopyWithStubImpl$Input$UnarchiveProjectV2ItemInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? itemId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnarchiveRepositoryInput {
  factory Input$UnarchiveRepositoryInput({
    required String repositoryId,
    String? clientMutationId,
  }) =>
      Input$UnarchiveRepositoryInput._({
        r'repositoryId': repositoryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnarchiveRepositoryInput._(this._$data);

  factory Input$UnarchiveRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnarchiveRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnarchiveRepositoryInput<Input$UnarchiveRepositoryInput>
      get copyWith => CopyWith$Input$UnarchiveRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnarchiveRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnarchiveRepositoryInput<TRes> {
  factory CopyWith$Input$UnarchiveRepositoryInput(
    Input$UnarchiveRepositoryInput instance,
    TRes Function(Input$UnarchiveRepositoryInput) then,
  ) = _CopyWithImpl$Input$UnarchiveRepositoryInput;

  factory CopyWith$Input$UnarchiveRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnarchiveRepositoryInput;

  TRes call({
    String? repositoryId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnarchiveRepositoryInput<TRes>
    implements CopyWith$Input$UnarchiveRepositoryInput<TRes> {
  _CopyWithImpl$Input$UnarchiveRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UnarchiveRepositoryInput _instance;

  final TRes Function(Input$UnarchiveRepositoryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnarchiveRepositoryInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnarchiveRepositoryInput<TRes>
    implements CopyWith$Input$UnarchiveRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UnarchiveRepositoryInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnfollowOrganizationInput {
  factory Input$UnfollowOrganizationInput({
    required String organizationId,
    String? clientMutationId,
  }) =>
      Input$UnfollowOrganizationInput._({
        r'organizationId': organizationId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnfollowOrganizationInput._(this._$data);

  factory Input$UnfollowOrganizationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnfollowOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get organizationId => (_$data['organizationId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnfollowOrganizationInput<Input$UnfollowOrganizationInput>
      get copyWith => CopyWith$Input$UnfollowOrganizationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnfollowOrganizationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$organizationId = organizationId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$organizationId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnfollowOrganizationInput<TRes> {
  factory CopyWith$Input$UnfollowOrganizationInput(
    Input$UnfollowOrganizationInput instance,
    TRes Function(Input$UnfollowOrganizationInput) then,
  ) = _CopyWithImpl$Input$UnfollowOrganizationInput;

  factory CopyWith$Input$UnfollowOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnfollowOrganizationInput;

  TRes call({
    String? organizationId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnfollowOrganizationInput<TRes>
    implements CopyWith$Input$UnfollowOrganizationInput<TRes> {
  _CopyWithImpl$Input$UnfollowOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$UnfollowOrganizationInput _instance;

  final TRes Function(Input$UnfollowOrganizationInput) _then;

  static const _undefined = {};

  TRes call({
    Object? organizationId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnfollowOrganizationInput._({
        ..._instance._$data,
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnfollowOrganizationInput<TRes>
    implements CopyWith$Input$UnfollowOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$UnfollowOrganizationInput(this._res);

  TRes _res;

  call({
    String? organizationId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnfollowUserInput {
  factory Input$UnfollowUserInput({
    required String userId,
    String? clientMutationId,
  }) =>
      Input$UnfollowUserInput._({
        r'userId': userId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnfollowUserInput._(this._$data);

  factory Input$UnfollowUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnfollowUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get userId => (_$data['userId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$userId = userId;
    result$data['userId'] = l$userId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnfollowUserInput<Input$UnfollowUserInput> get copyWith =>
      CopyWith$Input$UnfollowUserInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnfollowUserInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$userId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnfollowUserInput<TRes> {
  factory CopyWith$Input$UnfollowUserInput(
    Input$UnfollowUserInput instance,
    TRes Function(Input$UnfollowUserInput) then,
  ) = _CopyWithImpl$Input$UnfollowUserInput;

  factory CopyWith$Input$UnfollowUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnfollowUserInput;

  TRes call({
    String? userId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnfollowUserInput<TRes>
    implements CopyWith$Input$UnfollowUserInput<TRes> {
  _CopyWithImpl$Input$UnfollowUserInput(
    this._instance,
    this._then,
  );

  final Input$UnfollowUserInput _instance;

  final TRes Function(Input$UnfollowUserInput) _then;

  static const _undefined = {};

  TRes call({
    Object? userId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnfollowUserInput._({
        ..._instance._$data,
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnfollowUserInput<TRes>
    implements CopyWith$Input$UnfollowUserInput<TRes> {
  _CopyWithStubImpl$Input$UnfollowUserInput(this._res);

  TRes _res;

  call({
    String? userId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnlinkProjectV2FromRepositoryInput {
  factory Input$UnlinkProjectV2FromRepositoryInput({
    required String projectId,
    required String repositoryId,
    String? clientMutationId,
  }) =>
      Input$UnlinkProjectV2FromRepositoryInput._({
        r'projectId': projectId,
        r'repositoryId': repositoryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnlinkProjectV2FromRepositoryInput._(this._$data);

  factory Input$UnlinkProjectV2FromRepositoryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnlinkProjectV2FromRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnlinkProjectV2FromRepositoryInput<
          Input$UnlinkProjectV2FromRepositoryInput>
      get copyWith => CopyWith$Input$UnlinkProjectV2FromRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnlinkProjectV2FromRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$repositoryId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnlinkProjectV2FromRepositoryInput<TRes> {
  factory CopyWith$Input$UnlinkProjectV2FromRepositoryInput(
    Input$UnlinkProjectV2FromRepositoryInput instance,
    TRes Function(Input$UnlinkProjectV2FromRepositoryInput) then,
  ) = _CopyWithImpl$Input$UnlinkProjectV2FromRepositoryInput;

  factory CopyWith$Input$UnlinkProjectV2FromRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlinkProjectV2FromRepositoryInput;

  TRes call({
    String? projectId,
    String? repositoryId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnlinkProjectV2FromRepositoryInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromRepositoryInput<TRes> {
  _CopyWithImpl$Input$UnlinkProjectV2FromRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UnlinkProjectV2FromRepositoryInput _instance;

  final TRes Function(Input$UnlinkProjectV2FromRepositoryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnlinkProjectV2FromRepositoryInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnlinkProjectV2FromRepositoryInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UnlinkProjectV2FromRepositoryInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? repositoryId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnlinkProjectV2FromTeamInput {
  factory Input$UnlinkProjectV2FromTeamInput({
    required String projectId,
    required String teamId,
    String? clientMutationId,
  }) =>
      Input$UnlinkProjectV2FromTeamInput._({
        r'projectId': projectId,
        r'teamId': teamId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnlinkProjectV2FromTeamInput._(this._$data);

  factory Input$UnlinkProjectV2FromTeamInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$teamId = data['teamId'];
    result$data['teamId'] = (l$teamId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnlinkProjectV2FromTeamInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get teamId => (_$data['teamId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$teamId = teamId;
    result$data['teamId'] = l$teamId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnlinkProjectV2FromTeamInput<
          Input$UnlinkProjectV2FromTeamInput>
      get copyWith => CopyWith$Input$UnlinkProjectV2FromTeamInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnlinkProjectV2FromTeamInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (l$teamId != lOther$teamId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$teamId = teamId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$teamId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnlinkProjectV2FromTeamInput<TRes> {
  factory CopyWith$Input$UnlinkProjectV2FromTeamInput(
    Input$UnlinkProjectV2FromTeamInput instance,
    TRes Function(Input$UnlinkProjectV2FromTeamInput) then,
  ) = _CopyWithImpl$Input$UnlinkProjectV2FromTeamInput;

  factory CopyWith$Input$UnlinkProjectV2FromTeamInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlinkProjectV2FromTeamInput;

  TRes call({
    String? projectId,
    String? teamId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnlinkProjectV2FromTeamInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromTeamInput<TRes> {
  _CopyWithImpl$Input$UnlinkProjectV2FromTeamInput(
    this._instance,
    this._then,
  );

  final Input$UnlinkProjectV2FromTeamInput _instance;

  final TRes Function(Input$UnlinkProjectV2FromTeamInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? teamId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnlinkProjectV2FromTeamInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (teamId != _undefined && teamId != null)
          'teamId': (teamId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnlinkProjectV2FromTeamInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromTeamInput<TRes> {
  _CopyWithStubImpl$Input$UnlinkProjectV2FromTeamInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? teamId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnlinkRepositoryFromProjectInput {
  factory Input$UnlinkRepositoryFromProjectInput({
    required String projectId,
    required String repositoryId,
    String? clientMutationId,
  }) =>
      Input$UnlinkRepositoryFromProjectInput._({
        r'projectId': projectId,
        r'repositoryId': repositoryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnlinkRepositoryFromProjectInput._(this._$data);

  factory Input$UnlinkRepositoryFromProjectInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnlinkRepositoryFromProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnlinkRepositoryFromProjectInput<
          Input$UnlinkRepositoryFromProjectInput>
      get copyWith => CopyWith$Input$UnlinkRepositoryFromProjectInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnlinkRepositoryFromProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$repositoryId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnlinkRepositoryFromProjectInput<TRes> {
  factory CopyWith$Input$UnlinkRepositoryFromProjectInput(
    Input$UnlinkRepositoryFromProjectInput instance,
    TRes Function(Input$UnlinkRepositoryFromProjectInput) then,
  ) = _CopyWithImpl$Input$UnlinkRepositoryFromProjectInput;

  factory CopyWith$Input$UnlinkRepositoryFromProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlinkRepositoryFromProjectInput;

  TRes call({
    String? projectId,
    String? repositoryId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnlinkRepositoryFromProjectInput<TRes>
    implements CopyWith$Input$UnlinkRepositoryFromProjectInput<TRes> {
  _CopyWithImpl$Input$UnlinkRepositoryFromProjectInput(
    this._instance,
    this._then,
  );

  final Input$UnlinkRepositoryFromProjectInput _instance;

  final TRes Function(Input$UnlinkRepositoryFromProjectInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnlinkRepositoryFromProjectInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnlinkRepositoryFromProjectInput<TRes>
    implements CopyWith$Input$UnlinkRepositoryFromProjectInput<TRes> {
  _CopyWithStubImpl$Input$UnlinkRepositoryFromProjectInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? repositoryId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnlockLockableInput {
  factory Input$UnlockLockableInput({
    required String lockableId,
    String? clientMutationId,
  }) =>
      Input$UnlockLockableInput._({
        r'lockableId': lockableId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnlockLockableInput._(this._$data);

  factory Input$UnlockLockableInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$lockableId = data['lockableId'];
    result$data['lockableId'] = (l$lockableId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnlockLockableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get lockableId => (_$data['lockableId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$lockableId = lockableId;
    result$data['lockableId'] = l$lockableId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnlockLockableInput<Input$UnlockLockableInput> get copyWith =>
      CopyWith$Input$UnlockLockableInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnlockLockableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$lockableId = lockableId;
    final lOther$lockableId = other.lockableId;
    if (l$lockableId != lOther$lockableId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$lockableId = lockableId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$lockableId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnlockLockableInput<TRes> {
  factory CopyWith$Input$UnlockLockableInput(
    Input$UnlockLockableInput instance,
    TRes Function(Input$UnlockLockableInput) then,
  ) = _CopyWithImpl$Input$UnlockLockableInput;

  factory CopyWith$Input$UnlockLockableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlockLockableInput;

  TRes call({
    String? lockableId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnlockLockableInput<TRes>
    implements CopyWith$Input$UnlockLockableInput<TRes> {
  _CopyWithImpl$Input$UnlockLockableInput(
    this._instance,
    this._then,
  );

  final Input$UnlockLockableInput _instance;

  final TRes Function(Input$UnlockLockableInput) _then;

  static const _undefined = {};

  TRes call({
    Object? lockableId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnlockLockableInput._({
        ..._instance._$data,
        if (lockableId != _undefined && lockableId != null)
          'lockableId': (lockableId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnlockLockableInput<TRes>
    implements CopyWith$Input$UnlockLockableInput<TRes> {
  _CopyWithStubImpl$Input$UnlockLockableInput(this._res);

  TRes _res;

  call({
    String? lockableId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnmarkDiscussionCommentAsAnswerInput {
  factory Input$UnmarkDiscussionCommentAsAnswerInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$UnmarkDiscussionCommentAsAnswerInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnmarkDiscussionCommentAsAnswerInput._(this._$data);

  factory Input$UnmarkDiscussionCommentAsAnswerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnmarkDiscussionCommentAsAnswerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<
          Input$UnmarkDiscussionCommentAsAnswerInput>
      get copyWith => CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnmarkDiscussionCommentAsAnswerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<TRes> {
  factory CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput(
    Input$UnmarkDiscussionCommentAsAnswerInput instance,
    TRes Function(Input$UnmarkDiscussionCommentAsAnswerInput) then,
  ) = _CopyWithImpl$Input$UnmarkDiscussionCommentAsAnswerInput;

  factory CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnmarkDiscussionCommentAsAnswerInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnmarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithImpl$Input$UnmarkDiscussionCommentAsAnswerInput(
    this._instance,
    this._then,
  );

  final Input$UnmarkDiscussionCommentAsAnswerInput _instance;

  final TRes Function(Input$UnmarkDiscussionCommentAsAnswerInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnmarkDiscussionCommentAsAnswerInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnmarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithStubImpl$Input$UnmarkDiscussionCommentAsAnswerInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnmarkFileAsViewedInput {
  factory Input$UnmarkFileAsViewedInput({
    required String pullRequestId,
    required String path,
    String? clientMutationId,
  }) =>
      Input$UnmarkFileAsViewedInput._({
        r'pullRequestId': pullRequestId,
        r'path': path,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnmarkFileAsViewedInput._(this._$data);

  factory Input$UnmarkFileAsViewedInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnmarkFileAsViewedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String get path => (_$data['path'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnmarkFileAsViewedInput<Input$UnmarkFileAsViewedInput>
      get copyWith => CopyWith$Input$UnmarkFileAsViewedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnmarkFileAsViewedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$path = path;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      l$path,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnmarkFileAsViewedInput<TRes> {
  factory CopyWith$Input$UnmarkFileAsViewedInput(
    Input$UnmarkFileAsViewedInput instance,
    TRes Function(Input$UnmarkFileAsViewedInput) then,
  ) = _CopyWithImpl$Input$UnmarkFileAsViewedInput;

  factory CopyWith$Input$UnmarkFileAsViewedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnmarkFileAsViewedInput;

  TRes call({
    String? pullRequestId,
    String? path,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnmarkFileAsViewedInput<TRes>
    implements CopyWith$Input$UnmarkFileAsViewedInput<TRes> {
  _CopyWithImpl$Input$UnmarkFileAsViewedInput(
    this._instance,
    this._then,
  );

  final Input$UnmarkFileAsViewedInput _instance;

  final TRes Function(Input$UnmarkFileAsViewedInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? path = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnmarkFileAsViewedInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (path != _undefined && path != null) 'path': (path as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnmarkFileAsViewedInput<TRes>
    implements CopyWith$Input$UnmarkFileAsViewedInput<TRes> {
  _CopyWithStubImpl$Input$UnmarkFileAsViewedInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? path,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnmarkIssueAsDuplicateInput {
  factory Input$UnmarkIssueAsDuplicateInput({
    required String duplicateId,
    required String canonicalId,
    String? clientMutationId,
  }) =>
      Input$UnmarkIssueAsDuplicateInput._({
        r'duplicateId': duplicateId,
        r'canonicalId': canonicalId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnmarkIssueAsDuplicateInput._(this._$data);

  factory Input$UnmarkIssueAsDuplicateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$duplicateId = data['duplicateId'];
    result$data['duplicateId'] = (l$duplicateId as String);
    final l$canonicalId = data['canonicalId'];
    result$data['canonicalId'] = (l$canonicalId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnmarkIssueAsDuplicateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get duplicateId => (_$data['duplicateId'] as String);
  String get canonicalId => (_$data['canonicalId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$duplicateId = duplicateId;
    result$data['duplicateId'] = l$duplicateId;
    final l$canonicalId = canonicalId;
    result$data['canonicalId'] = l$canonicalId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnmarkIssueAsDuplicateInput<Input$UnmarkIssueAsDuplicateInput>
      get copyWith => CopyWith$Input$UnmarkIssueAsDuplicateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnmarkIssueAsDuplicateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$duplicateId = duplicateId;
    final lOther$duplicateId = other.duplicateId;
    if (l$duplicateId != lOther$duplicateId) {
      return false;
    }
    final l$canonicalId = canonicalId;
    final lOther$canonicalId = other.canonicalId;
    if (l$canonicalId != lOther$canonicalId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$duplicateId = duplicateId;
    final l$canonicalId = canonicalId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$duplicateId,
      l$canonicalId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnmarkIssueAsDuplicateInput<TRes> {
  factory CopyWith$Input$UnmarkIssueAsDuplicateInput(
    Input$UnmarkIssueAsDuplicateInput instance,
    TRes Function(Input$UnmarkIssueAsDuplicateInput) then,
  ) = _CopyWithImpl$Input$UnmarkIssueAsDuplicateInput;

  factory CopyWith$Input$UnmarkIssueAsDuplicateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnmarkIssueAsDuplicateInput;

  TRes call({
    String? duplicateId,
    String? canonicalId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnmarkIssueAsDuplicateInput<TRes>
    implements CopyWith$Input$UnmarkIssueAsDuplicateInput<TRes> {
  _CopyWithImpl$Input$UnmarkIssueAsDuplicateInput(
    this._instance,
    this._then,
  );

  final Input$UnmarkIssueAsDuplicateInput _instance;

  final TRes Function(Input$UnmarkIssueAsDuplicateInput) _then;

  static const _undefined = {};

  TRes call({
    Object? duplicateId = _undefined,
    Object? canonicalId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnmarkIssueAsDuplicateInput._({
        ..._instance._$data,
        if (duplicateId != _undefined && duplicateId != null)
          'duplicateId': (duplicateId as String),
        if (canonicalId != _undefined && canonicalId != null)
          'canonicalId': (canonicalId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnmarkIssueAsDuplicateInput<TRes>
    implements CopyWith$Input$UnmarkIssueAsDuplicateInput<TRes> {
  _CopyWithStubImpl$Input$UnmarkIssueAsDuplicateInput(this._res);

  TRes _res;

  call({
    String? duplicateId,
    String? canonicalId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnminimizeCommentInput {
  factory Input$UnminimizeCommentInput({
    required String subjectId,
    String? clientMutationId,
  }) =>
      Input$UnminimizeCommentInput._({
        r'subjectId': subjectId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnminimizeCommentInput._(this._$data);

  factory Input$UnminimizeCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnminimizeCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get subjectId => (_$data['subjectId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnminimizeCommentInput<Input$UnminimizeCommentInput>
      get copyWith => CopyWith$Input$UnminimizeCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnminimizeCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subjectId = subjectId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$subjectId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnminimizeCommentInput<TRes> {
  factory CopyWith$Input$UnminimizeCommentInput(
    Input$UnminimizeCommentInput instance,
    TRes Function(Input$UnminimizeCommentInput) then,
  ) = _CopyWithImpl$Input$UnminimizeCommentInput;

  factory CopyWith$Input$UnminimizeCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnminimizeCommentInput;

  TRes call({
    String? subjectId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnminimizeCommentInput<TRes>
    implements CopyWith$Input$UnminimizeCommentInput<TRes> {
  _CopyWithImpl$Input$UnminimizeCommentInput(
    this._instance,
    this._then,
  );

  final Input$UnminimizeCommentInput _instance;

  final TRes Function(Input$UnminimizeCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? subjectId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnminimizeCommentInput._({
        ..._instance._$data,
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnminimizeCommentInput<TRes>
    implements CopyWith$Input$UnminimizeCommentInput<TRes> {
  _CopyWithStubImpl$Input$UnminimizeCommentInput(this._res);

  TRes _res;

  call({
    String? subjectId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnpinIssueInput {
  factory Input$UnpinIssueInput({
    required String issueId,
    String? clientMutationId,
  }) =>
      Input$UnpinIssueInput._({
        r'issueId': issueId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnpinIssueInput._(this._$data);

  factory Input$UnpinIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnpinIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get issueId => (_$data['issueId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnpinIssueInput<Input$UnpinIssueInput> get copyWith =>
      CopyWith$Input$UnpinIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnpinIssueInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$issueId = issueId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$issueId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnpinIssueInput<TRes> {
  factory CopyWith$Input$UnpinIssueInput(
    Input$UnpinIssueInput instance,
    TRes Function(Input$UnpinIssueInput) then,
  ) = _CopyWithImpl$Input$UnpinIssueInput;

  factory CopyWith$Input$UnpinIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnpinIssueInput;

  TRes call({
    String? issueId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnpinIssueInput<TRes>
    implements CopyWith$Input$UnpinIssueInput<TRes> {
  _CopyWithImpl$Input$UnpinIssueInput(
    this._instance,
    this._then,
  );

  final Input$UnpinIssueInput _instance;

  final TRes Function(Input$UnpinIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? issueId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnpinIssueInput._({
        ..._instance._$data,
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnpinIssueInput<TRes>
    implements CopyWith$Input$UnpinIssueInput<TRes> {
  _CopyWithStubImpl$Input$UnpinIssueInput(this._res);

  TRes _res;

  call({
    String? issueId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UnresolveReviewThreadInput {
  factory Input$UnresolveReviewThreadInput({
    required String threadId,
    String? clientMutationId,
  }) =>
      Input$UnresolveReviewThreadInput._({
        r'threadId': threadId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UnresolveReviewThreadInput._(this._$data);

  factory Input$UnresolveReviewThreadInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$threadId = data['threadId'];
    result$data['threadId'] = (l$threadId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UnresolveReviewThreadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get threadId => (_$data['threadId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$threadId = threadId;
    result$data['threadId'] = l$threadId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UnresolveReviewThreadInput<Input$UnresolveReviewThreadInput>
      get copyWith => CopyWith$Input$UnresolveReviewThreadInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnresolveReviewThreadInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$threadId = threadId;
    final lOther$threadId = other.threadId;
    if (l$threadId != lOther$threadId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$threadId = threadId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$threadId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UnresolveReviewThreadInput<TRes> {
  factory CopyWith$Input$UnresolveReviewThreadInput(
    Input$UnresolveReviewThreadInput instance,
    TRes Function(Input$UnresolveReviewThreadInput) then,
  ) = _CopyWithImpl$Input$UnresolveReviewThreadInput;

  factory CopyWith$Input$UnresolveReviewThreadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnresolveReviewThreadInput;

  TRes call({
    String? threadId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UnresolveReviewThreadInput<TRes>
    implements CopyWith$Input$UnresolveReviewThreadInput<TRes> {
  _CopyWithImpl$Input$UnresolveReviewThreadInput(
    this._instance,
    this._then,
  );

  final Input$UnresolveReviewThreadInput _instance;

  final TRes Function(Input$UnresolveReviewThreadInput) _then;

  static const _undefined = {};

  TRes call({
    Object? threadId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UnresolveReviewThreadInput._({
        ..._instance._$data,
        if (threadId != _undefined && threadId != null)
          'threadId': (threadId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UnresolveReviewThreadInput<TRes>
    implements CopyWith$Input$UnresolveReviewThreadInput<TRes> {
  _CopyWithStubImpl$Input$UnresolveReviewThreadInput(this._res);

  TRes _res;

  call({
    String? threadId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateBranchProtectionRuleInput {
  factory Input$UpdateBranchProtectionRuleInput({
    required String branchProtectionRuleId,
    String? pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
    String? clientMutationId,
  }) =>
      Input$UpdateBranchProtectionRuleInput._({
        r'branchProtectionRuleId': branchProtectionRuleId,
        if (pattern != null) r'pattern': pattern,
        if (requiresApprovingReviews != null)
          r'requiresApprovingReviews': requiresApprovingReviews,
        if (requiredApprovingReviewCount != null)
          r'requiredApprovingReviewCount': requiredApprovingReviewCount,
        if (requiresCommitSignatures != null)
          r'requiresCommitSignatures': requiresCommitSignatures,
        if (requiresLinearHistory != null)
          r'requiresLinearHistory': requiresLinearHistory,
        if (blocksCreations != null) r'blocksCreations': blocksCreations,
        if (allowsForcePushes != null) r'allowsForcePushes': allowsForcePushes,
        if (allowsDeletions != null) r'allowsDeletions': allowsDeletions,
        if (isAdminEnforced != null) r'isAdminEnforced': isAdminEnforced,
        if (requiresStatusChecks != null)
          r'requiresStatusChecks': requiresStatusChecks,
        if (requiresStrictStatusChecks != null)
          r'requiresStrictStatusChecks': requiresStrictStatusChecks,
        if (requiresCodeOwnerReviews != null)
          r'requiresCodeOwnerReviews': requiresCodeOwnerReviews,
        if (dismissesStaleReviews != null)
          r'dismissesStaleReviews': dismissesStaleReviews,
        if (restrictsReviewDismissals != null)
          r'restrictsReviewDismissals': restrictsReviewDismissals,
        if (reviewDismissalActorIds != null)
          r'reviewDismissalActorIds': reviewDismissalActorIds,
        if (bypassPullRequestActorIds != null)
          r'bypassPullRequestActorIds': bypassPullRequestActorIds,
        if (bypassForcePushActorIds != null)
          r'bypassForcePushActorIds': bypassForcePushActorIds,
        if (restrictsPushes != null) r'restrictsPushes': restrictsPushes,
        if (pushActorIds != null) r'pushActorIds': pushActorIds,
        if (requiredStatusCheckContexts != null)
          r'requiredStatusCheckContexts': requiredStatusCheckContexts,
        if (requiredStatusChecks != null)
          r'requiredStatusChecks': requiredStatusChecks,
        if (requiresConversationResolution != null)
          r'requiresConversationResolution': requiresConversationResolution,
        if (requireLastPushApproval != null)
          r'requireLastPushApproval': requireLastPushApproval,
        if (lockBranch != null) r'lockBranch': lockBranch,
        if (lockAllowsFetchAndMerge != null)
          r'lockAllowsFetchAndMerge': lockAllowsFetchAndMerge,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateBranchProtectionRuleInput._(this._$data);

  factory Input$UpdateBranchProtectionRuleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$branchProtectionRuleId = data['branchProtectionRuleId'];
    result$data['branchProtectionRuleId'] =
        (l$branchProtectionRuleId as String);
    if (data.containsKey('pattern')) {
      final l$pattern = data['pattern'];
      result$data['pattern'] = (l$pattern as String?);
    }
    if (data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = data['requiresApprovingReviews'];
      result$data['requiresApprovingReviews'] =
          (l$requiresApprovingReviews as bool?);
    }
    if (data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount =
          data['requiredApprovingReviewCount'];
      result$data['requiredApprovingReviewCount'] =
          (l$requiredApprovingReviewCount as int?);
    }
    if (data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = data['requiresCommitSignatures'];
      result$data['requiresCommitSignatures'] =
          (l$requiresCommitSignatures as bool?);
    }
    if (data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = data['requiresLinearHistory'];
      result$data['requiresLinearHistory'] = (l$requiresLinearHistory as bool?);
    }
    if (data.containsKey('blocksCreations')) {
      final l$blocksCreations = data['blocksCreations'];
      result$data['blocksCreations'] = (l$blocksCreations as bool?);
    }
    if (data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = data['allowsForcePushes'];
      result$data['allowsForcePushes'] = (l$allowsForcePushes as bool?);
    }
    if (data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = data['allowsDeletions'];
      result$data['allowsDeletions'] = (l$allowsDeletions as bool?);
    }
    if (data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = data['isAdminEnforced'];
      result$data['isAdminEnforced'] = (l$isAdminEnforced as bool?);
    }
    if (data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = data['requiresStatusChecks'];
      result$data['requiresStatusChecks'] = (l$requiresStatusChecks as bool?);
    }
    if (data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = data['requiresStrictStatusChecks'];
      result$data['requiresStrictStatusChecks'] =
          (l$requiresStrictStatusChecks as bool?);
    }
    if (data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = data['requiresCodeOwnerReviews'];
      result$data['requiresCodeOwnerReviews'] =
          (l$requiresCodeOwnerReviews as bool?);
    }
    if (data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = data['dismissesStaleReviews'];
      result$data['dismissesStaleReviews'] = (l$dismissesStaleReviews as bool?);
    }
    if (data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = data['restrictsReviewDismissals'];
      result$data['restrictsReviewDismissals'] =
          (l$restrictsReviewDismissals as bool?);
    }
    if (data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = data['reviewDismissalActorIds'];
      result$data['reviewDismissalActorIds'] =
          (l$reviewDismissalActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = data['bypassPullRequestActorIds'];
      result$data['bypassPullRequestActorIds'] =
          (l$bypassPullRequestActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = data['bypassForcePushActorIds'];
      result$data['bypassForcePushActorIds'] =
          (l$bypassForcePushActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = data['restrictsPushes'];
      result$data['restrictsPushes'] = (l$restrictsPushes as bool?);
    }
    if (data.containsKey('pushActorIds')) {
      final l$pushActorIds = data['pushActorIds'];
      result$data['pushActorIds'] = (l$pushActorIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = data['requiredStatusCheckContexts'];
      result$data['requiredStatusCheckContexts'] =
          (l$requiredStatusCheckContexts as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = data['requiredStatusChecks'];
      result$data['requiredStatusChecks'] =
          (l$requiredStatusChecks as List<dynamic>?)
              ?.map((e) => Input$RequiredStatusCheckInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    if (data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution =
          data['requiresConversationResolution'];
      result$data['requiresConversationResolution'] =
          (l$requiresConversationResolution as bool?);
    }
    if (data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = data['requireLastPushApproval'];
      result$data['requireLastPushApproval'] =
          (l$requireLastPushApproval as bool?);
    }
    if (data.containsKey('lockBranch')) {
      final l$lockBranch = data['lockBranch'];
      result$data['lockBranch'] = (l$lockBranch as bool?);
    }
    if (data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = data['lockAllowsFetchAndMerge'];
      result$data['lockAllowsFetchAndMerge'] =
          (l$lockAllowsFetchAndMerge as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateBranchProtectionRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get branchProtectionRuleId =>
      (_$data['branchProtectionRuleId'] as String);
  String? get pattern => (_$data['pattern'] as String?);
  bool? get requiresApprovingReviews =>
      (_$data['requiresApprovingReviews'] as bool?);
  int? get requiredApprovingReviewCount =>
      (_$data['requiredApprovingReviewCount'] as int?);
  bool? get requiresCommitSignatures =>
      (_$data['requiresCommitSignatures'] as bool?);
  bool? get requiresLinearHistory => (_$data['requiresLinearHistory'] as bool?);
  bool? get blocksCreations => (_$data['blocksCreations'] as bool?);
  bool? get allowsForcePushes => (_$data['allowsForcePushes'] as bool?);
  bool? get allowsDeletions => (_$data['allowsDeletions'] as bool?);
  bool? get isAdminEnforced => (_$data['isAdminEnforced'] as bool?);
  bool? get requiresStatusChecks => (_$data['requiresStatusChecks'] as bool?);
  bool? get requiresStrictStatusChecks =>
      (_$data['requiresStrictStatusChecks'] as bool?);
  bool? get requiresCodeOwnerReviews =>
      (_$data['requiresCodeOwnerReviews'] as bool?);
  bool? get dismissesStaleReviews => (_$data['dismissesStaleReviews'] as bool?);
  bool? get restrictsReviewDismissals =>
      (_$data['restrictsReviewDismissals'] as bool?);
  List<String>? get reviewDismissalActorIds =>
      (_$data['reviewDismissalActorIds'] as List<String>?);
  List<String>? get bypassPullRequestActorIds =>
      (_$data['bypassPullRequestActorIds'] as List<String>?);
  List<String>? get bypassForcePushActorIds =>
      (_$data['bypassForcePushActorIds'] as List<String>?);
  bool? get restrictsPushes => (_$data['restrictsPushes'] as bool?);
  List<String>? get pushActorIds => (_$data['pushActorIds'] as List<String>?);
  List<String>? get requiredStatusCheckContexts =>
      (_$data['requiredStatusCheckContexts'] as List<String>?);
  List<Input$RequiredStatusCheckInput>? get requiredStatusChecks =>
      (_$data['requiredStatusChecks'] as List<Input$RequiredStatusCheckInput>?);
  bool? get requiresConversationResolution =>
      (_$data['requiresConversationResolution'] as bool?);
  bool? get requireLastPushApproval =>
      (_$data['requireLastPushApproval'] as bool?);
  bool? get lockBranch => (_$data['lockBranch'] as bool?);
  bool? get lockAllowsFetchAndMerge =>
      (_$data['lockAllowsFetchAndMerge'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$branchProtectionRuleId = branchProtectionRuleId;
    result$data['branchProtectionRuleId'] = l$branchProtectionRuleId;
    if (_$data.containsKey('pattern')) {
      final l$pattern = pattern;
      result$data['pattern'] = l$pattern;
    }
    if (_$data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = requiresApprovingReviews;
      result$data['requiresApprovingReviews'] = l$requiresApprovingReviews;
    }
    if (_$data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
      result$data['requiredApprovingReviewCount'] =
          l$requiredApprovingReviewCount;
    }
    if (_$data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = requiresCommitSignatures;
      result$data['requiresCommitSignatures'] = l$requiresCommitSignatures;
    }
    if (_$data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = requiresLinearHistory;
      result$data['requiresLinearHistory'] = l$requiresLinearHistory;
    }
    if (_$data.containsKey('blocksCreations')) {
      final l$blocksCreations = blocksCreations;
      result$data['blocksCreations'] = l$blocksCreations;
    }
    if (_$data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = allowsForcePushes;
      result$data['allowsForcePushes'] = l$allowsForcePushes;
    }
    if (_$data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = allowsDeletions;
      result$data['allowsDeletions'] = l$allowsDeletions;
    }
    if (_$data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = isAdminEnforced;
      result$data['isAdminEnforced'] = l$isAdminEnforced;
    }
    if (_$data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = requiresStatusChecks;
      result$data['requiresStatusChecks'] = l$requiresStatusChecks;
    }
    if (_$data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
      result$data['requiresStrictStatusChecks'] = l$requiresStrictStatusChecks;
    }
    if (_$data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
      result$data['requiresCodeOwnerReviews'] = l$requiresCodeOwnerReviews;
    }
    if (_$data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = dismissesStaleReviews;
      result$data['dismissesStaleReviews'] = l$dismissesStaleReviews;
    }
    if (_$data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = restrictsReviewDismissals;
      result$data['restrictsReviewDismissals'] = l$restrictsReviewDismissals;
    }
    if (_$data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = reviewDismissalActorIds;
      result$data['reviewDismissalActorIds'] =
          l$reviewDismissalActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
      result$data['bypassPullRequestActorIds'] =
          l$bypassPullRequestActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = bypassForcePushActorIds;
      result$data['bypassForcePushActorIds'] =
          l$bypassForcePushActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = restrictsPushes;
      result$data['restrictsPushes'] = l$restrictsPushes;
    }
    if (_$data.containsKey('pushActorIds')) {
      final l$pushActorIds = pushActorIds;
      result$data['pushActorIds'] = l$pushActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
      result$data['requiredStatusCheckContexts'] =
          l$requiredStatusCheckContexts?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = requiredStatusChecks;
      result$data['requiredStatusChecks'] =
          l$requiredStatusChecks?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution = requiresConversationResolution;
      result$data['requiresConversationResolution'] =
          l$requiresConversationResolution;
    }
    if (_$data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = requireLastPushApproval;
      result$data['requireLastPushApproval'] = l$requireLastPushApproval;
    }
    if (_$data.containsKey('lockBranch')) {
      final l$lockBranch = lockBranch;
      result$data['lockBranch'] = l$lockBranch;
    }
    if (_$data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
      result$data['lockAllowsFetchAndMerge'] = l$lockAllowsFetchAndMerge;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateBranchProtectionRuleInput<
          Input$UpdateBranchProtectionRuleInput>
      get copyWith => CopyWith$Input$UpdateBranchProtectionRuleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateBranchProtectionRuleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$branchProtectionRuleId = branchProtectionRuleId;
    final lOther$branchProtectionRuleId = other.branchProtectionRuleId;
    if (l$branchProtectionRuleId != lOther$branchProtectionRuleId) {
      return false;
    }
    final l$pattern = pattern;
    final lOther$pattern = other.pattern;
    if (_$data.containsKey('pattern') != other._$data.containsKey('pattern')) {
      return false;
    }
    if (l$pattern != lOther$pattern) {
      return false;
    }
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final lOther$requiresApprovingReviews = other.requiresApprovingReviews;
    if (_$data.containsKey('requiresApprovingReviews') !=
        other._$data.containsKey('requiresApprovingReviews')) {
      return false;
    }
    if (l$requiresApprovingReviews != lOther$requiresApprovingReviews) {
      return false;
    }
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final lOther$requiredApprovingReviewCount =
        other.requiredApprovingReviewCount;
    if (_$data.containsKey('requiredApprovingReviewCount') !=
        other._$data.containsKey('requiredApprovingReviewCount')) {
      return false;
    }
    if (l$requiredApprovingReviewCount != lOther$requiredApprovingReviewCount) {
      return false;
    }
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final lOther$requiresCommitSignatures = other.requiresCommitSignatures;
    if (_$data.containsKey('requiresCommitSignatures') !=
        other._$data.containsKey('requiresCommitSignatures')) {
      return false;
    }
    if (l$requiresCommitSignatures != lOther$requiresCommitSignatures) {
      return false;
    }
    final l$requiresLinearHistory = requiresLinearHistory;
    final lOther$requiresLinearHistory = other.requiresLinearHistory;
    if (_$data.containsKey('requiresLinearHistory') !=
        other._$data.containsKey('requiresLinearHistory')) {
      return false;
    }
    if (l$requiresLinearHistory != lOther$requiresLinearHistory) {
      return false;
    }
    final l$blocksCreations = blocksCreations;
    final lOther$blocksCreations = other.blocksCreations;
    if (_$data.containsKey('blocksCreations') !=
        other._$data.containsKey('blocksCreations')) {
      return false;
    }
    if (l$blocksCreations != lOther$blocksCreations) {
      return false;
    }
    final l$allowsForcePushes = allowsForcePushes;
    final lOther$allowsForcePushes = other.allowsForcePushes;
    if (_$data.containsKey('allowsForcePushes') !=
        other._$data.containsKey('allowsForcePushes')) {
      return false;
    }
    if (l$allowsForcePushes != lOther$allowsForcePushes) {
      return false;
    }
    final l$allowsDeletions = allowsDeletions;
    final lOther$allowsDeletions = other.allowsDeletions;
    if (_$data.containsKey('allowsDeletions') !=
        other._$data.containsKey('allowsDeletions')) {
      return false;
    }
    if (l$allowsDeletions != lOther$allowsDeletions) {
      return false;
    }
    final l$isAdminEnforced = isAdminEnforced;
    final lOther$isAdminEnforced = other.isAdminEnforced;
    if (_$data.containsKey('isAdminEnforced') !=
        other._$data.containsKey('isAdminEnforced')) {
      return false;
    }
    if (l$isAdminEnforced != lOther$isAdminEnforced) {
      return false;
    }
    final l$requiresStatusChecks = requiresStatusChecks;
    final lOther$requiresStatusChecks = other.requiresStatusChecks;
    if (_$data.containsKey('requiresStatusChecks') !=
        other._$data.containsKey('requiresStatusChecks')) {
      return false;
    }
    if (l$requiresStatusChecks != lOther$requiresStatusChecks) {
      return false;
    }
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final lOther$requiresStrictStatusChecks = other.requiresStrictStatusChecks;
    if (_$data.containsKey('requiresStrictStatusChecks') !=
        other._$data.containsKey('requiresStrictStatusChecks')) {
      return false;
    }
    if (l$requiresStrictStatusChecks != lOther$requiresStrictStatusChecks) {
      return false;
    }
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final lOther$requiresCodeOwnerReviews = other.requiresCodeOwnerReviews;
    if (_$data.containsKey('requiresCodeOwnerReviews') !=
        other._$data.containsKey('requiresCodeOwnerReviews')) {
      return false;
    }
    if (l$requiresCodeOwnerReviews != lOther$requiresCodeOwnerReviews) {
      return false;
    }
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final lOther$dismissesStaleReviews = other.dismissesStaleReviews;
    if (_$data.containsKey('dismissesStaleReviews') !=
        other._$data.containsKey('dismissesStaleReviews')) {
      return false;
    }
    if (l$dismissesStaleReviews != lOther$dismissesStaleReviews) {
      return false;
    }
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final lOther$restrictsReviewDismissals = other.restrictsReviewDismissals;
    if (_$data.containsKey('restrictsReviewDismissals') !=
        other._$data.containsKey('restrictsReviewDismissals')) {
      return false;
    }
    if (l$restrictsReviewDismissals != lOther$restrictsReviewDismissals) {
      return false;
    }
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    final lOther$reviewDismissalActorIds = other.reviewDismissalActorIds;
    if (_$data.containsKey('reviewDismissalActorIds') !=
        other._$data.containsKey('reviewDismissalActorIds')) {
      return false;
    }
    if (l$reviewDismissalActorIds != null &&
        lOther$reviewDismissalActorIds != null) {
      if (l$reviewDismissalActorIds.length !=
          lOther$reviewDismissalActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$reviewDismissalActorIds.length; i++) {
        final l$reviewDismissalActorIds$entry = l$reviewDismissalActorIds[i];
        final lOther$reviewDismissalActorIds$entry =
            lOther$reviewDismissalActorIds[i];
        if (l$reviewDismissalActorIds$entry !=
            lOther$reviewDismissalActorIds$entry) {
          return false;
        }
      }
    } else if (l$reviewDismissalActorIds != lOther$reviewDismissalActorIds) {
      return false;
    }
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final lOther$bypassPullRequestActorIds = other.bypassPullRequestActorIds;
    if (_$data.containsKey('bypassPullRequestActorIds') !=
        other._$data.containsKey('bypassPullRequestActorIds')) {
      return false;
    }
    if (l$bypassPullRequestActorIds != null &&
        lOther$bypassPullRequestActorIds != null) {
      if (l$bypassPullRequestActorIds.length !=
          lOther$bypassPullRequestActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassPullRequestActorIds.length; i++) {
        final l$bypassPullRequestActorIds$entry =
            l$bypassPullRequestActorIds[i];
        final lOther$bypassPullRequestActorIds$entry =
            lOther$bypassPullRequestActorIds[i];
        if (l$bypassPullRequestActorIds$entry !=
            lOther$bypassPullRequestActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassPullRequestActorIds !=
        lOther$bypassPullRequestActorIds) {
      return false;
    }
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final lOther$bypassForcePushActorIds = other.bypassForcePushActorIds;
    if (_$data.containsKey('bypassForcePushActorIds') !=
        other._$data.containsKey('bypassForcePushActorIds')) {
      return false;
    }
    if (l$bypassForcePushActorIds != null &&
        lOther$bypassForcePushActorIds != null) {
      if (l$bypassForcePushActorIds.length !=
          lOther$bypassForcePushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassForcePushActorIds.length; i++) {
        final l$bypassForcePushActorIds$entry = l$bypassForcePushActorIds[i];
        final lOther$bypassForcePushActorIds$entry =
            lOther$bypassForcePushActorIds[i];
        if (l$bypassForcePushActorIds$entry !=
            lOther$bypassForcePushActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassForcePushActorIds != lOther$bypassForcePushActorIds) {
      return false;
    }
    final l$restrictsPushes = restrictsPushes;
    final lOther$restrictsPushes = other.restrictsPushes;
    if (_$data.containsKey('restrictsPushes') !=
        other._$data.containsKey('restrictsPushes')) {
      return false;
    }
    if (l$restrictsPushes != lOther$restrictsPushes) {
      return false;
    }
    final l$pushActorIds = pushActorIds;
    final lOther$pushActorIds = other.pushActorIds;
    if (_$data.containsKey('pushActorIds') !=
        other._$data.containsKey('pushActorIds')) {
      return false;
    }
    if (l$pushActorIds != null && lOther$pushActorIds != null) {
      if (l$pushActorIds.length != lOther$pushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$pushActorIds.length; i++) {
        final l$pushActorIds$entry = l$pushActorIds[i];
        final lOther$pushActorIds$entry = lOther$pushActorIds[i];
        if (l$pushActorIds$entry != lOther$pushActorIds$entry) {
          return false;
        }
      }
    } else if (l$pushActorIds != lOther$pushActorIds) {
      return false;
    }
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final lOther$requiredStatusCheckContexts =
        other.requiredStatusCheckContexts;
    if (_$data.containsKey('requiredStatusCheckContexts') !=
        other._$data.containsKey('requiredStatusCheckContexts')) {
      return false;
    }
    if (l$requiredStatusCheckContexts != null &&
        lOther$requiredStatusCheckContexts != null) {
      if (l$requiredStatusCheckContexts.length !=
          lOther$requiredStatusCheckContexts.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusCheckContexts.length; i++) {
        final l$requiredStatusCheckContexts$entry =
            l$requiredStatusCheckContexts[i];
        final lOther$requiredStatusCheckContexts$entry =
            lOther$requiredStatusCheckContexts[i];
        if (l$requiredStatusCheckContexts$entry !=
            lOther$requiredStatusCheckContexts$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusCheckContexts !=
        lOther$requiredStatusCheckContexts) {
      return false;
    }
    final l$requiredStatusChecks = requiredStatusChecks;
    final lOther$requiredStatusChecks = other.requiredStatusChecks;
    if (_$data.containsKey('requiredStatusChecks') !=
        other._$data.containsKey('requiredStatusChecks')) {
      return false;
    }
    if (l$requiredStatusChecks != null && lOther$requiredStatusChecks != null) {
      if (l$requiredStatusChecks.length != lOther$requiredStatusChecks.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusChecks.length; i++) {
        final l$requiredStatusChecks$entry = l$requiredStatusChecks[i];
        final lOther$requiredStatusChecks$entry =
            lOther$requiredStatusChecks[i];
        if (l$requiredStatusChecks$entry != lOther$requiredStatusChecks$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusChecks != lOther$requiredStatusChecks) {
      return false;
    }
    final l$requiresConversationResolution = requiresConversationResolution;
    final lOther$requiresConversationResolution =
        other.requiresConversationResolution;
    if (_$data.containsKey('requiresConversationResolution') !=
        other._$data.containsKey('requiresConversationResolution')) {
      return false;
    }
    if (l$requiresConversationResolution !=
        lOther$requiresConversationResolution) {
      return false;
    }
    final l$requireLastPushApproval = requireLastPushApproval;
    final lOther$requireLastPushApproval = other.requireLastPushApproval;
    if (_$data.containsKey('requireLastPushApproval') !=
        other._$data.containsKey('requireLastPushApproval')) {
      return false;
    }
    if (l$requireLastPushApproval != lOther$requireLastPushApproval) {
      return false;
    }
    final l$lockBranch = lockBranch;
    final lOther$lockBranch = other.lockBranch;
    if (_$data.containsKey('lockBranch') !=
        other._$data.containsKey('lockBranch')) {
      return false;
    }
    if (l$lockBranch != lOther$lockBranch) {
      return false;
    }
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    final lOther$lockAllowsFetchAndMerge = other.lockAllowsFetchAndMerge;
    if (_$data.containsKey('lockAllowsFetchAndMerge') !=
        other._$data.containsKey('lockAllowsFetchAndMerge')) {
      return false;
    }
    if (l$lockAllowsFetchAndMerge != lOther$lockAllowsFetchAndMerge) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$branchProtectionRuleId = branchProtectionRuleId;
    final l$pattern = pattern;
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final l$requiresLinearHistory = requiresLinearHistory;
    final l$blocksCreations = blocksCreations;
    final l$allowsForcePushes = allowsForcePushes;
    final l$allowsDeletions = allowsDeletions;
    final l$isAdminEnforced = isAdminEnforced;
    final l$requiresStatusChecks = requiresStatusChecks;
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final l$restrictsPushes = restrictsPushes;
    final l$pushActorIds = pushActorIds;
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final l$requiredStatusChecks = requiredStatusChecks;
    final l$requiresConversationResolution = requiresConversationResolution;
    final l$requireLastPushApproval = requireLastPushApproval;
    final l$lockBranch = lockBranch;
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$branchProtectionRuleId,
      _$data.containsKey('pattern') ? l$pattern : const {},
      _$data.containsKey('requiresApprovingReviews')
          ? l$requiresApprovingReviews
          : const {},
      _$data.containsKey('requiredApprovingReviewCount')
          ? l$requiredApprovingReviewCount
          : const {},
      _$data.containsKey('requiresCommitSignatures')
          ? l$requiresCommitSignatures
          : const {},
      _$data.containsKey('requiresLinearHistory')
          ? l$requiresLinearHistory
          : const {},
      _$data.containsKey('blocksCreations') ? l$blocksCreations : const {},
      _$data.containsKey('allowsForcePushes') ? l$allowsForcePushes : const {},
      _$data.containsKey('allowsDeletions') ? l$allowsDeletions : const {},
      _$data.containsKey('isAdminEnforced') ? l$isAdminEnforced : const {},
      _$data.containsKey('requiresStatusChecks')
          ? l$requiresStatusChecks
          : const {},
      _$data.containsKey('requiresStrictStatusChecks')
          ? l$requiresStrictStatusChecks
          : const {},
      _$data.containsKey('requiresCodeOwnerReviews')
          ? l$requiresCodeOwnerReviews
          : const {},
      _$data.containsKey('dismissesStaleReviews')
          ? l$dismissesStaleReviews
          : const {},
      _$data.containsKey('restrictsReviewDismissals')
          ? l$restrictsReviewDismissals
          : const {},
      _$data.containsKey('reviewDismissalActorIds')
          ? l$reviewDismissalActorIds == null
              ? null
              : Object.hashAll(l$reviewDismissalActorIds.map((v) => v))
          : const {},
      _$data.containsKey('bypassPullRequestActorIds')
          ? l$bypassPullRequestActorIds == null
              ? null
              : Object.hashAll(l$bypassPullRequestActorIds.map((v) => v))
          : const {},
      _$data.containsKey('bypassForcePushActorIds')
          ? l$bypassForcePushActorIds == null
              ? null
              : Object.hashAll(l$bypassForcePushActorIds.map((v) => v))
          : const {},
      _$data.containsKey('restrictsPushes') ? l$restrictsPushes : const {},
      _$data.containsKey('pushActorIds')
          ? l$pushActorIds == null
              ? null
              : Object.hashAll(l$pushActorIds.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusCheckContexts')
          ? l$requiredStatusCheckContexts == null
              ? null
              : Object.hashAll(l$requiredStatusCheckContexts.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusChecks')
          ? l$requiredStatusChecks == null
              ? null
              : Object.hashAll(l$requiredStatusChecks.map((v) => v))
          : const {},
      _$data.containsKey('requiresConversationResolution')
          ? l$requiresConversationResolution
          : const {},
      _$data.containsKey('requireLastPushApproval')
          ? l$requireLastPushApproval
          : const {},
      _$data.containsKey('lockBranch') ? l$lockBranch : const {},
      _$data.containsKey('lockAllowsFetchAndMerge')
          ? l$lockAllowsFetchAndMerge
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateBranchProtectionRuleInput<TRes> {
  factory CopyWith$Input$UpdateBranchProtectionRuleInput(
    Input$UpdateBranchProtectionRuleInput instance,
    TRes Function(Input$UpdateBranchProtectionRuleInput) then,
  ) = _CopyWithImpl$Input$UpdateBranchProtectionRuleInput;

  factory CopyWith$Input$UpdateBranchProtectionRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateBranchProtectionRuleInput;

  TRes call({
    String? branchProtectionRuleId,
    String? pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
    String? clientMutationId,
  });
  TRes requiredStatusChecks(
      Iterable<Input$RequiredStatusCheckInput>? Function(
              Iterable<
                  CopyWith$Input$RequiredStatusCheckInput<
                      Input$RequiredStatusCheckInput>>?)
          _fn);
}

class _CopyWithImpl$Input$UpdateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$UpdateBranchProtectionRuleInput<TRes> {
  _CopyWithImpl$Input$UpdateBranchProtectionRuleInput(
    this._instance,
    this._then,
  );

  final Input$UpdateBranchProtectionRuleInput _instance;

  final TRes Function(Input$UpdateBranchProtectionRuleInput) _then;

  static const _undefined = {};

  TRes call({
    Object? branchProtectionRuleId = _undefined,
    Object? pattern = _undefined,
    Object? requiresApprovingReviews = _undefined,
    Object? requiredApprovingReviewCount = _undefined,
    Object? requiresCommitSignatures = _undefined,
    Object? requiresLinearHistory = _undefined,
    Object? blocksCreations = _undefined,
    Object? allowsForcePushes = _undefined,
    Object? allowsDeletions = _undefined,
    Object? isAdminEnforced = _undefined,
    Object? requiresStatusChecks = _undefined,
    Object? requiresStrictStatusChecks = _undefined,
    Object? requiresCodeOwnerReviews = _undefined,
    Object? dismissesStaleReviews = _undefined,
    Object? restrictsReviewDismissals = _undefined,
    Object? reviewDismissalActorIds = _undefined,
    Object? bypassPullRequestActorIds = _undefined,
    Object? bypassForcePushActorIds = _undefined,
    Object? restrictsPushes = _undefined,
    Object? pushActorIds = _undefined,
    Object? requiredStatusCheckContexts = _undefined,
    Object? requiredStatusChecks = _undefined,
    Object? requiresConversationResolution = _undefined,
    Object? requireLastPushApproval = _undefined,
    Object? lockBranch = _undefined,
    Object? lockAllowsFetchAndMerge = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateBranchProtectionRuleInput._({
        ..._instance._$data,
        if (branchProtectionRuleId != _undefined &&
            branchProtectionRuleId != null)
          'branchProtectionRuleId': (branchProtectionRuleId as String),
        if (pattern != _undefined) 'pattern': (pattern as String?),
        if (requiresApprovingReviews != _undefined)
          'requiresApprovingReviews': (requiresApprovingReviews as bool?),
        if (requiredApprovingReviewCount != _undefined)
          'requiredApprovingReviewCount':
              (requiredApprovingReviewCount as int?),
        if (requiresCommitSignatures != _undefined)
          'requiresCommitSignatures': (requiresCommitSignatures as bool?),
        if (requiresLinearHistory != _undefined)
          'requiresLinearHistory': (requiresLinearHistory as bool?),
        if (blocksCreations != _undefined)
          'blocksCreations': (blocksCreations as bool?),
        if (allowsForcePushes != _undefined)
          'allowsForcePushes': (allowsForcePushes as bool?),
        if (allowsDeletions != _undefined)
          'allowsDeletions': (allowsDeletions as bool?),
        if (isAdminEnforced != _undefined)
          'isAdminEnforced': (isAdminEnforced as bool?),
        if (requiresStatusChecks != _undefined)
          'requiresStatusChecks': (requiresStatusChecks as bool?),
        if (requiresStrictStatusChecks != _undefined)
          'requiresStrictStatusChecks': (requiresStrictStatusChecks as bool?),
        if (requiresCodeOwnerReviews != _undefined)
          'requiresCodeOwnerReviews': (requiresCodeOwnerReviews as bool?),
        if (dismissesStaleReviews != _undefined)
          'dismissesStaleReviews': (dismissesStaleReviews as bool?),
        if (restrictsReviewDismissals != _undefined)
          'restrictsReviewDismissals': (restrictsReviewDismissals as bool?),
        if (reviewDismissalActorIds != _undefined)
          'reviewDismissalActorIds': (reviewDismissalActorIds as List<String>?),
        if (bypassPullRequestActorIds != _undefined)
          'bypassPullRequestActorIds':
              (bypassPullRequestActorIds as List<String>?),
        if (bypassForcePushActorIds != _undefined)
          'bypassForcePushActorIds': (bypassForcePushActorIds as List<String>?),
        if (restrictsPushes != _undefined)
          'restrictsPushes': (restrictsPushes as bool?),
        if (pushActorIds != _undefined)
          'pushActorIds': (pushActorIds as List<String>?),
        if (requiredStatusCheckContexts != _undefined)
          'requiredStatusCheckContexts':
              (requiredStatusCheckContexts as List<String>?),
        if (requiredStatusChecks != _undefined)
          'requiredStatusChecks':
              (requiredStatusChecks as List<Input$RequiredStatusCheckInput>?),
        if (requiresConversationResolution != _undefined)
          'requiresConversationResolution':
              (requiresConversationResolution as bool?),
        if (requireLastPushApproval != _undefined)
          'requireLastPushApproval': (requireLastPushApproval as bool?),
        if (lockBranch != _undefined) 'lockBranch': (lockBranch as bool?),
        if (lockAllowsFetchAndMerge != _undefined)
          'lockAllowsFetchAndMerge': (lockAllowsFetchAndMerge as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
  TRes requiredStatusChecks(
          Iterable<Input$RequiredStatusCheckInput>? Function(
                  Iterable<
                      CopyWith$Input$RequiredStatusCheckInput<
                          Input$RequiredStatusCheckInput>>?)
              _fn) =>
      call(
          requiredStatusChecks: _fn(_instance.requiredStatusChecks
              ?.map((e) => CopyWith$Input$RequiredStatusCheckInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$UpdateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$UpdateBranchProtectionRuleInput<TRes> {
  _CopyWithStubImpl$Input$UpdateBranchProtectionRuleInput(this._res);

  TRes _res;

  call({
    String? branchProtectionRuleId,
    String? pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
    String? clientMutationId,
  }) =>
      _res;
  requiredStatusChecks(_fn) => _res;
}

class Input$UpdateCheckRunInput {
  factory Input$UpdateCheckRunInput({
    required String repositoryId,
    required String checkRunId,
    String? name,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
    String? clientMutationId,
  }) =>
      Input$UpdateCheckRunInput._({
        r'repositoryId': repositoryId,
        r'checkRunId': checkRunId,
        if (name != null) r'name': name,
        if (detailsUrl != null) r'detailsUrl': detailsUrl,
        if (externalId != null) r'externalId': externalId,
        if (status != null) r'status': status,
        if (startedAt != null) r'startedAt': startedAt,
        if (conclusion != null) r'conclusion': conclusion,
        if (completedAt != null) r'completedAt': completedAt,
        if (output != null) r'output': output,
        if (actions != null) r'actions': actions,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateCheckRunInput._(this._$data);

  factory Input$UpdateCheckRunInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$checkRunId = data['checkRunId'];
    result$data['checkRunId'] = (l$checkRunId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('detailsUrl')) {
      final l$detailsUrl = data['detailsUrl'];
      result$data['detailsUrl'] = (l$detailsUrl as String?);
    }
    if (data.containsKey('externalId')) {
      final l$externalId = data['externalId'];
      result$data['externalId'] = (l$externalId as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$RequestableCheckStatusState((l$status as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = (l$startedAt as String?);
    }
    if (data.containsKey('conclusion')) {
      final l$conclusion = data['conclusion'];
      result$data['conclusion'] = l$conclusion == null
          ? null
          : fromJson$Enum$CheckConclusionState((l$conclusion as String));
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = (l$completedAt as String?);
    }
    if (data.containsKey('output')) {
      final l$output = data['output'];
      result$data['output'] = l$output == null
          ? null
          : Input$CheckRunOutput.fromJson((l$output as Map<String, dynamic>));
    }
    if (data.containsKey('actions')) {
      final l$actions = data['actions'];
      result$data['actions'] = (l$actions as List<dynamic>?)
          ?.map(
              (e) => Input$CheckRunAction.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateCheckRunInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String get checkRunId => (_$data['checkRunId'] as String);
  String? get name => (_$data['name'] as String?);
  String? get detailsUrl => (_$data['detailsUrl'] as String?);
  String? get externalId => (_$data['externalId'] as String?);
  Enum$RequestableCheckStatusState? get status =>
      (_$data['status'] as Enum$RequestableCheckStatusState?);
  String? get startedAt => (_$data['startedAt'] as String?);
  Enum$CheckConclusionState? get conclusion =>
      (_$data['conclusion'] as Enum$CheckConclusionState?);
  String? get completedAt => (_$data['completedAt'] as String?);
  Input$CheckRunOutput? get output =>
      (_$data['output'] as Input$CheckRunOutput?);
  List<Input$CheckRunAction>? get actions =>
      (_$data['actions'] as List<Input$CheckRunAction>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$checkRunId = checkRunId;
    result$data['checkRunId'] = l$checkRunId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('detailsUrl')) {
      final l$detailsUrl = detailsUrl;
      result$data['detailsUrl'] = l$detailsUrl;
    }
    if (_$data.containsKey('externalId')) {
      final l$externalId = externalId;
      result$data['externalId'] = l$externalId;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$RequestableCheckStatusState(l$status);
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt;
    }
    if (_$data.containsKey('conclusion')) {
      final l$conclusion = conclusion;
      result$data['conclusion'] = l$conclusion == null
          ? null
          : toJson$Enum$CheckConclusionState(l$conclusion);
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt;
    }
    if (_$data.containsKey('output')) {
      final l$output = output;
      result$data['output'] = l$output?.toJson();
    }
    if (_$data.containsKey('actions')) {
      final l$actions = actions;
      result$data['actions'] = l$actions?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateCheckRunInput<Input$UpdateCheckRunInput> get copyWith =>
      CopyWith$Input$UpdateCheckRunInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateCheckRunInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$checkRunId = checkRunId;
    final lOther$checkRunId = other.checkRunId;
    if (l$checkRunId != lOther$checkRunId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$detailsUrl = detailsUrl;
    final lOther$detailsUrl = other.detailsUrl;
    if (_$data.containsKey('detailsUrl') !=
        other._$data.containsKey('detailsUrl')) {
      return false;
    }
    if (l$detailsUrl != lOther$detailsUrl) {
      return false;
    }
    final l$externalId = externalId;
    final lOther$externalId = other.externalId;
    if (_$data.containsKey('externalId') !=
        other._$data.containsKey('externalId')) {
      return false;
    }
    if (l$externalId != lOther$externalId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$conclusion = conclusion;
    final lOther$conclusion = other.conclusion;
    if (_$data.containsKey('conclusion') !=
        other._$data.containsKey('conclusion')) {
      return false;
    }
    if (l$conclusion != lOther$conclusion) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$output = output;
    final lOther$output = other.output;
    if (_$data.containsKey('output') != other._$data.containsKey('output')) {
      return false;
    }
    if (l$output != lOther$output) {
      return false;
    }
    final l$actions = actions;
    final lOther$actions = other.actions;
    if (_$data.containsKey('actions') != other._$data.containsKey('actions')) {
      return false;
    }
    if (l$actions != null && lOther$actions != null) {
      if (l$actions.length != lOther$actions.length) {
        return false;
      }
      for (int i = 0; i < l$actions.length; i++) {
        final l$actions$entry = l$actions[i];
        final lOther$actions$entry = lOther$actions[i];
        if (l$actions$entry != lOther$actions$entry) {
          return false;
        }
      }
    } else if (l$actions != lOther$actions) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$checkRunId = checkRunId;
    final l$name = name;
    final l$detailsUrl = detailsUrl;
    final l$externalId = externalId;
    final l$status = status;
    final l$startedAt = startedAt;
    final l$conclusion = conclusion;
    final l$completedAt = completedAt;
    final l$output = output;
    final l$actions = actions;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$checkRunId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('detailsUrl') ? l$detailsUrl : const {},
      _$data.containsKey('externalId') ? l$externalId : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('conclusion') ? l$conclusion : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('output') ? l$output : const {},
      _$data.containsKey('actions')
          ? l$actions == null
              ? null
              : Object.hashAll(l$actions.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateCheckRunInput<TRes> {
  factory CopyWith$Input$UpdateCheckRunInput(
    Input$UpdateCheckRunInput instance,
    TRes Function(Input$UpdateCheckRunInput) then,
  ) = _CopyWithImpl$Input$UpdateCheckRunInput;

  factory CopyWith$Input$UpdateCheckRunInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateCheckRunInput;

  TRes call({
    String? repositoryId,
    String? checkRunId,
    String? name,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
    String? clientMutationId,
  });
  CopyWith$Input$CheckRunOutput<TRes> get output;
  TRes actions(
      Iterable<Input$CheckRunAction>? Function(
              Iterable<CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
          _fn);
}

class _CopyWithImpl$Input$UpdateCheckRunInput<TRes>
    implements CopyWith$Input$UpdateCheckRunInput<TRes> {
  _CopyWithImpl$Input$UpdateCheckRunInput(
    this._instance,
    this._then,
  );

  final Input$UpdateCheckRunInput _instance;

  final TRes Function(Input$UpdateCheckRunInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? checkRunId = _undefined,
    Object? name = _undefined,
    Object? detailsUrl = _undefined,
    Object? externalId = _undefined,
    Object? status = _undefined,
    Object? startedAt = _undefined,
    Object? conclusion = _undefined,
    Object? completedAt = _undefined,
    Object? output = _undefined,
    Object? actions = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateCheckRunInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (checkRunId != _undefined && checkRunId != null)
          'checkRunId': (checkRunId as String),
        if (name != _undefined) 'name': (name as String?),
        if (detailsUrl != _undefined) 'detailsUrl': (detailsUrl as String?),
        if (externalId != _undefined) 'externalId': (externalId as String?),
        if (status != _undefined)
          'status': (status as Enum$RequestableCheckStatusState?),
        if (startedAt != _undefined) 'startedAt': (startedAt as String?),
        if (conclusion != _undefined)
          'conclusion': (conclusion as Enum$CheckConclusionState?),
        if (completedAt != _undefined) 'completedAt': (completedAt as String?),
        if (output != _undefined) 'output': (output as Input$CheckRunOutput?),
        if (actions != _undefined)
          'actions': (actions as List<Input$CheckRunAction>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
  CopyWith$Input$CheckRunOutput<TRes> get output {
    final local$output = _instance.output;
    return local$output == null
        ? CopyWith$Input$CheckRunOutput.stub(_then(_instance))
        : CopyWith$Input$CheckRunOutput(local$output, (e) => call(output: e));
  }

  TRes actions(
          Iterable<Input$CheckRunAction>? Function(
                  Iterable<
                      CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
              _fn) =>
      call(
          actions:
              _fn(_instance.actions?.map((e) => CopyWith$Input$CheckRunAction(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$UpdateCheckRunInput<TRes>
    implements CopyWith$Input$UpdateCheckRunInput<TRes> {
  _CopyWithStubImpl$Input$UpdateCheckRunInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? checkRunId,
    String? name,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
    String? clientMutationId,
  }) =>
      _res;
  CopyWith$Input$CheckRunOutput<TRes> get output =>
      CopyWith$Input$CheckRunOutput.stub(_res);
  actions(_fn) => _res;
}

class Input$UpdateCheckSuitePreferencesInput {
  factory Input$UpdateCheckSuitePreferencesInput({
    required String repositoryId,
    required List<Input$CheckSuiteAutoTriggerPreference> autoTriggerPreferences,
    String? clientMutationId,
  }) =>
      Input$UpdateCheckSuitePreferencesInput._({
        r'repositoryId': repositoryId,
        r'autoTriggerPreferences': autoTriggerPreferences,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateCheckSuitePreferencesInput._(this._$data);

  factory Input$UpdateCheckSuitePreferencesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$autoTriggerPreferences = data['autoTriggerPreferences'];
    result$data['autoTriggerPreferences'] =
        (l$autoTriggerPreferences as List<dynamic>)
            .map((e) => Input$CheckSuiteAutoTriggerPreference.fromJson(
                (e as Map<String, dynamic>)))
            .toList();
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateCheckSuitePreferencesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  List<Input$CheckSuiteAutoTriggerPreference> get autoTriggerPreferences =>
      (_$data['autoTriggerPreferences']
          as List<Input$CheckSuiteAutoTriggerPreference>);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$autoTriggerPreferences = autoTriggerPreferences;
    result$data['autoTriggerPreferences'] =
        l$autoTriggerPreferences.map((e) => e.toJson()).toList();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateCheckSuitePreferencesInput<
          Input$UpdateCheckSuitePreferencesInput>
      get copyWith => CopyWith$Input$UpdateCheckSuitePreferencesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateCheckSuitePreferencesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$autoTriggerPreferences = autoTriggerPreferences;
    final lOther$autoTriggerPreferences = other.autoTriggerPreferences;
    if (l$autoTriggerPreferences.length !=
        lOther$autoTriggerPreferences.length) {
      return false;
    }
    for (int i = 0; i < l$autoTriggerPreferences.length; i++) {
      final l$autoTriggerPreferences$entry = l$autoTriggerPreferences[i];
      final lOther$autoTriggerPreferences$entry =
          lOther$autoTriggerPreferences[i];
      if (l$autoTriggerPreferences$entry !=
          lOther$autoTriggerPreferences$entry) {
        return false;
      }
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$autoTriggerPreferences = autoTriggerPreferences;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      Object.hashAll(l$autoTriggerPreferences.map((v) => v)),
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateCheckSuitePreferencesInput<TRes> {
  factory CopyWith$Input$UpdateCheckSuitePreferencesInput(
    Input$UpdateCheckSuitePreferencesInput instance,
    TRes Function(Input$UpdateCheckSuitePreferencesInput) then,
  ) = _CopyWithImpl$Input$UpdateCheckSuitePreferencesInput;

  factory CopyWith$Input$UpdateCheckSuitePreferencesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateCheckSuitePreferencesInput;

  TRes call({
    String? repositoryId,
    List<Input$CheckSuiteAutoTriggerPreference>? autoTriggerPreferences,
    String? clientMutationId,
  });
  TRes autoTriggerPreferences(
      Iterable<Input$CheckSuiteAutoTriggerPreference> Function(
              Iterable<
                  CopyWith$Input$CheckSuiteAutoTriggerPreference<
                      Input$CheckSuiteAutoTriggerPreference>>)
          _fn);
}

class _CopyWithImpl$Input$UpdateCheckSuitePreferencesInput<TRes>
    implements CopyWith$Input$UpdateCheckSuitePreferencesInput<TRes> {
  _CopyWithImpl$Input$UpdateCheckSuitePreferencesInput(
    this._instance,
    this._then,
  );

  final Input$UpdateCheckSuitePreferencesInput _instance;

  final TRes Function(Input$UpdateCheckSuitePreferencesInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? autoTriggerPreferences = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateCheckSuitePreferencesInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (autoTriggerPreferences != _undefined &&
            autoTriggerPreferences != null)
          'autoTriggerPreferences': (autoTriggerPreferences
              as List<Input$CheckSuiteAutoTriggerPreference>),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
  TRes autoTriggerPreferences(
          Iterable<Input$CheckSuiteAutoTriggerPreference> Function(
                  Iterable<
                      CopyWith$Input$CheckSuiteAutoTriggerPreference<
                          Input$CheckSuiteAutoTriggerPreference>>)
              _fn) =>
      call(
          autoTriggerPreferences: _fn(_instance.autoTriggerPreferences
              .map((e) => CopyWith$Input$CheckSuiteAutoTriggerPreference(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$UpdateCheckSuitePreferencesInput<TRes>
    implements CopyWith$Input$UpdateCheckSuitePreferencesInput<TRes> {
  _CopyWithStubImpl$Input$UpdateCheckSuitePreferencesInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    List<Input$CheckSuiteAutoTriggerPreference>? autoTriggerPreferences,
    String? clientMutationId,
  }) =>
      _res;
  autoTriggerPreferences(_fn) => _res;
}

class Input$UpdateDiscussionCommentInput {
  factory Input$UpdateDiscussionCommentInput({
    required String commentId,
    required String body,
    String? clientMutationId,
  }) =>
      Input$UpdateDiscussionCommentInput._({
        r'commentId': commentId,
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateDiscussionCommentInput._(this._$data);

  factory Input$UpdateDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$commentId = data['commentId'];
    result$data['commentId'] = (l$commentId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get commentId => (_$data['commentId'] as String);
  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$commentId = commentId;
    result$data['commentId'] = l$commentId;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateDiscussionCommentInput<
          Input$UpdateDiscussionCommentInput>
      get copyWith => CopyWith$Input$UpdateDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$commentId = commentId;
    final lOther$commentId = other.commentId;
    if (l$commentId != lOther$commentId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$commentId = commentId;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$commentId,
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateDiscussionCommentInput<TRes> {
  factory CopyWith$Input$UpdateDiscussionCommentInput(
    Input$UpdateDiscussionCommentInput instance,
    TRes Function(Input$UpdateDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$UpdateDiscussionCommentInput;

  factory CopyWith$Input$UpdateDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateDiscussionCommentInput;

  TRes call({
    String? commentId,
    String? body,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$UpdateDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateDiscussionCommentInput _instance;

  final TRes Function(Input$UpdateDiscussionCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? commentId = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateDiscussionCommentInput._({
        ..._instance._$data,
        if (commentId != _undefined && commentId != null)
          'commentId': (commentId as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? commentId,
    String? body,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateDiscussionInput {
  factory Input$UpdateDiscussionInput({
    required String discussionId,
    String? title,
    String? body,
    String? categoryId,
    String? clientMutationId,
  }) =>
      Input$UpdateDiscussionInput._({
        r'discussionId': discussionId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (categoryId != null) r'categoryId': categoryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateDiscussionInput._(this._$data);

  factory Input$UpdateDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('categoryId')) {
      final l$categoryId = data['categoryId'];
      result$data['categoryId'] = (l$categoryId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get discussionId => (_$data['discussionId'] as String);
  String? get title => (_$data['title'] as String?);
  String? get body => (_$data['body'] as String?);
  String? get categoryId => (_$data['categoryId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('categoryId')) {
      final l$categoryId = categoryId;
      result$data['categoryId'] = l$categoryId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateDiscussionInput<Input$UpdateDiscussionInput>
      get copyWith => CopyWith$Input$UpdateDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$categoryId = categoryId;
    final lOther$categoryId = other.categoryId;
    if (_$data.containsKey('categoryId') !=
        other._$data.containsKey('categoryId')) {
      return false;
    }
    if (l$categoryId != lOther$categoryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$discussionId = discussionId;
    final l$title = title;
    final l$body = body;
    final l$categoryId = categoryId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$discussionId,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('categoryId') ? l$categoryId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateDiscussionInput<TRes> {
  factory CopyWith$Input$UpdateDiscussionInput(
    Input$UpdateDiscussionInput instance,
    TRes Function(Input$UpdateDiscussionInput) then,
  ) = _CopyWithImpl$Input$UpdateDiscussionInput;

  factory CopyWith$Input$UpdateDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateDiscussionInput;

  TRes call({
    String? discussionId,
    String? title,
    String? body,
    String? categoryId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateDiscussionInput<TRes>
    implements CopyWith$Input$UpdateDiscussionInput<TRes> {
  _CopyWithImpl$Input$UpdateDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateDiscussionInput _instance;

  final TRes Function(Input$UpdateDiscussionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? discussionId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? categoryId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateDiscussionInput._({
        ..._instance._$data,
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (categoryId != _undefined) 'categoryId': (categoryId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateDiscussionInput<TRes>
    implements CopyWith$Input$UpdateDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateDiscussionInput(this._res);

  TRes _res;

  call({
    String? discussionId,
    String? title,
    String? body,
    String? categoryId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseAdministratorRoleInput {
  factory Input$UpdateEnterpriseAdministratorRoleInput({
    required String enterpriseId,
    required String login,
    required Enum$EnterpriseAdministratorRole role,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseAdministratorRoleInput._({
        r'enterpriseId': enterpriseId,
        r'login': login,
        r'role': role,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseAdministratorRoleInput._(this._$data);

  factory Input$UpdateEnterpriseAdministratorRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    final l$role = data['role'];
    result$data['role'] =
        fromJson$Enum$EnterpriseAdministratorRole((l$role as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseAdministratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  Enum$EnterpriseAdministratorRole get role =>
      (_$data['role'] as Enum$EnterpriseAdministratorRole);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    final l$role = role;
    result$data['role'] = toJson$Enum$EnterpriseAdministratorRole(l$role);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<
          Input$UpdateEnterpriseAdministratorRoleInput>
      get copyWith => CopyWith$Input$UpdateEnterpriseAdministratorRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseAdministratorRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    final l$role = role;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$login,
      l$role,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<TRes> {
  factory CopyWith$Input$UpdateEnterpriseAdministratorRoleInput(
    Input$UpdateEnterpriseAdministratorRoleInput instance,
    TRes Function(Input$UpdateEnterpriseAdministratorRoleInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseAdministratorRoleInput;

  factory CopyWith$Input$UpdateEnterpriseAdministratorRoleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseAdministratorRoleInput;

  TRes call({
    String? enterpriseId,
    String? login,
    Enum$EnterpriseAdministratorRole? role,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseAdministratorRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseAdministratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseAdministratorRoleInput _instance;

  final TRes Function(Input$UpdateEnterpriseAdministratorRoleInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
    Object? role = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseAdministratorRoleInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
        if (role != _undefined && role != null)
          'role': (role as Enum$EnterpriseAdministratorRole),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseAdministratorRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseAdministratorRoleInput(this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? login,
    Enum$EnterpriseAdministratorRole? role,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput {
  factory Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? policyValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (policyValue != null) r'policyValue': policyValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('policyValue')) {
      final l$policyValue = data['policyValue'];
      result$data['policyValue'] = l$policyValue == null
          ? null
          : fromJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
              (l$policyValue as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? get policyValue =>
      (_$data['policyValue']
          as Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    if (_$data.containsKey('policyValue')) {
      final l$policyValue = policyValue;
      result$data['policyValue'] = l$policyValue == null
          ? null
          : toJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
              l$policyValue);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
          Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$policyValue = policyValue;
    final lOther$policyValue = other.policyValue;
    if (_$data.containsKey('policyValue') !=
        other._$data.containsKey('policyValue')) {
      return false;
    }
    if (l$policyValue != lOther$policyValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$policyValue = policyValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('policyValue') ? l$policyValue : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
    Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;

  factory CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? policyValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? policyValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
        if (policyValue != _undefined)
          'policyValue': (policyValue
              as Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? policyValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput {
  factory Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseDefaultRepositoryPermissionSettingValue
        settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._(this._$data);

  factory Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseDefaultRepositoryPermissionSettingValue get settingValue =>
      (_$data['settingValue']
          as Enum$EnterpriseDefaultRepositoryPermissionSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
            l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
          Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
    Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput instance,
    TRes Function(Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput;

  factory CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseDefaultRepositoryPermissionSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput _instance;

  final TRes Function(
      Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue
              as Enum$EnterpriseDefaultRepositoryPermissionSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseDefaultRepositoryPermissionSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput {
  factory Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput({
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
          Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
    Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
        instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
      _instance;

  final TRes Function(
          Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(
          Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
              ._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput {
  factory Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput({
    required String enterpriseId,
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? settingValue,
    bool? membersCanCreateRepositoriesPolicyEnabled,
    bool? membersCanCreatePublicRepositories,
    bool? membersCanCreatePrivateRepositories,
    bool? membersCanCreateInternalRepositories,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._({
        r'enterpriseId': enterpriseId,
        if (settingValue != null) r'settingValue': settingValue,
        if (membersCanCreateRepositoriesPolicyEnabled != null)
          r'membersCanCreateRepositoriesPolicyEnabled':
              membersCanCreateRepositoriesPolicyEnabled,
        if (membersCanCreatePublicRepositories != null)
          r'membersCanCreatePublicRepositories':
              membersCanCreatePublicRepositories,
        if (membersCanCreatePrivateRepositories != null)
          r'membersCanCreatePrivateRepositories':
              membersCanCreatePrivateRepositories,
        if (membersCanCreateInternalRepositories != null)
          r'membersCanCreateInternalRepositories':
              membersCanCreateInternalRepositories,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('settingValue')) {
      final l$settingValue = data['settingValue'];
      result$data['settingValue'] = l$settingValue == null
          ? null
          : fromJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
              (l$settingValue as String));
    }
    if (data.containsKey('membersCanCreateRepositoriesPolicyEnabled')) {
      final l$membersCanCreateRepositoriesPolicyEnabled =
          data['membersCanCreateRepositoriesPolicyEnabled'];
      result$data['membersCanCreateRepositoriesPolicyEnabled'] =
          (l$membersCanCreateRepositoriesPolicyEnabled as bool?);
    }
    if (data.containsKey('membersCanCreatePublicRepositories')) {
      final l$membersCanCreatePublicRepositories =
          data['membersCanCreatePublicRepositories'];
      result$data['membersCanCreatePublicRepositories'] =
          (l$membersCanCreatePublicRepositories as bool?);
    }
    if (data.containsKey('membersCanCreatePrivateRepositories')) {
      final l$membersCanCreatePrivateRepositories =
          data['membersCanCreatePrivateRepositories'];
      result$data['membersCanCreatePrivateRepositories'] =
          (l$membersCanCreatePrivateRepositories as bool?);
    }
    if (data.containsKey('membersCanCreateInternalRepositories')) {
      final l$membersCanCreateInternalRepositories =
          data['membersCanCreateInternalRepositories'];
      result$data['membersCanCreateInternalRepositories'] =
          (l$membersCanCreateInternalRepositories as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? get settingValue =>
      (_$data['settingValue']
          as Enum$EnterpriseMembersCanCreateRepositoriesSettingValue?);
  bool? get membersCanCreateRepositoriesPolicyEnabled =>
      (_$data['membersCanCreateRepositoriesPolicyEnabled'] as bool?);
  bool? get membersCanCreatePublicRepositories =>
      (_$data['membersCanCreatePublicRepositories'] as bool?);
  bool? get membersCanCreatePrivateRepositories =>
      (_$data['membersCanCreatePrivateRepositories'] as bool?);
  bool? get membersCanCreateInternalRepositories =>
      (_$data['membersCanCreateInternalRepositories'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('settingValue')) {
      final l$settingValue = settingValue;
      result$data['settingValue'] = l$settingValue == null
          ? null
          : toJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
              l$settingValue);
    }
    if (_$data.containsKey('membersCanCreateRepositoriesPolicyEnabled')) {
      final l$membersCanCreateRepositoriesPolicyEnabled =
          membersCanCreateRepositoriesPolicyEnabled;
      result$data['membersCanCreateRepositoriesPolicyEnabled'] =
          l$membersCanCreateRepositoriesPolicyEnabled;
    }
    if (_$data.containsKey('membersCanCreatePublicRepositories')) {
      final l$membersCanCreatePublicRepositories =
          membersCanCreatePublicRepositories;
      result$data['membersCanCreatePublicRepositories'] =
          l$membersCanCreatePublicRepositories;
    }
    if (_$data.containsKey('membersCanCreatePrivateRepositories')) {
      final l$membersCanCreatePrivateRepositories =
          membersCanCreatePrivateRepositories;
      result$data['membersCanCreatePrivateRepositories'] =
          l$membersCanCreatePrivateRepositories;
    }
    if (_$data.containsKey('membersCanCreateInternalRepositories')) {
      final l$membersCanCreateInternalRepositories =
          membersCanCreateInternalRepositories;
      result$data['membersCanCreateInternalRepositories'] =
          l$membersCanCreateInternalRepositories;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
          Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (_$data.containsKey('settingValue') !=
        other._$data.containsKey('settingValue')) {
      return false;
    }
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$membersCanCreateRepositoriesPolicyEnabled =
        membersCanCreateRepositoriesPolicyEnabled;
    final lOther$membersCanCreateRepositoriesPolicyEnabled =
        other.membersCanCreateRepositoriesPolicyEnabled;
    if (_$data.containsKey('membersCanCreateRepositoriesPolicyEnabled') !=
        other._$data.containsKey('membersCanCreateRepositoriesPolicyEnabled')) {
      return false;
    }
    if (l$membersCanCreateRepositoriesPolicyEnabled !=
        lOther$membersCanCreateRepositoriesPolicyEnabled) {
      return false;
    }
    final l$membersCanCreatePublicRepositories =
        membersCanCreatePublicRepositories;
    final lOther$membersCanCreatePublicRepositories =
        other.membersCanCreatePublicRepositories;
    if (_$data.containsKey('membersCanCreatePublicRepositories') !=
        other._$data.containsKey('membersCanCreatePublicRepositories')) {
      return false;
    }
    if (l$membersCanCreatePublicRepositories !=
        lOther$membersCanCreatePublicRepositories) {
      return false;
    }
    final l$membersCanCreatePrivateRepositories =
        membersCanCreatePrivateRepositories;
    final lOther$membersCanCreatePrivateRepositories =
        other.membersCanCreatePrivateRepositories;
    if (_$data.containsKey('membersCanCreatePrivateRepositories') !=
        other._$data.containsKey('membersCanCreatePrivateRepositories')) {
      return false;
    }
    if (l$membersCanCreatePrivateRepositories !=
        lOther$membersCanCreatePrivateRepositories) {
      return false;
    }
    final l$membersCanCreateInternalRepositories =
        membersCanCreateInternalRepositories;
    final lOther$membersCanCreateInternalRepositories =
        other.membersCanCreateInternalRepositories;
    if (_$data.containsKey('membersCanCreateInternalRepositories') !=
        other._$data.containsKey('membersCanCreateInternalRepositories')) {
      return false;
    }
    if (l$membersCanCreateInternalRepositories !=
        lOther$membersCanCreateInternalRepositories) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$membersCanCreateRepositoriesPolicyEnabled =
        membersCanCreateRepositoriesPolicyEnabled;
    final l$membersCanCreatePublicRepositories =
        membersCanCreatePublicRepositories;
    final l$membersCanCreatePrivateRepositories =
        membersCanCreatePrivateRepositories;
    final l$membersCanCreateInternalRepositories =
        membersCanCreateInternalRepositories;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      _$data.containsKey('settingValue') ? l$settingValue : const {},
      _$data.containsKey('membersCanCreateRepositoriesPolicyEnabled')
          ? l$membersCanCreateRepositoriesPolicyEnabled
          : const {},
      _$data.containsKey('membersCanCreatePublicRepositories')
          ? l$membersCanCreatePublicRepositories
          : const {},
      _$data.containsKey('membersCanCreatePrivateRepositories')
          ? l$membersCanCreatePrivateRepositories
          : const {},
      _$data.containsKey('membersCanCreateInternalRepositories')
          ? l$membersCanCreateInternalRepositories
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
    Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? settingValue,
    bool? membersCanCreateRepositoriesPolicyEnabled,
    bool? membersCanCreatePublicRepositories,
    bool? membersCanCreatePrivateRepositories,
    bool? membersCanCreateInternalRepositories,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? membersCanCreateRepositoriesPolicyEnabled = _undefined,
    Object? membersCanCreatePublicRepositories = _undefined,
    Object? membersCanCreatePrivateRepositories = _undefined,
    Object? membersCanCreateInternalRepositories = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined)
          'settingValue': (settingValue
              as Enum$EnterpriseMembersCanCreateRepositoriesSettingValue?),
        if (membersCanCreateRepositoriesPolicyEnabled != _undefined)
          'membersCanCreateRepositoriesPolicyEnabled':
              (membersCanCreateRepositoriesPolicyEnabled as bool?),
        if (membersCanCreatePublicRepositories != _undefined)
          'membersCanCreatePublicRepositories':
              (membersCanCreatePublicRepositories as bool?),
        if (membersCanCreatePrivateRepositories != _undefined)
          'membersCanCreatePrivateRepositories':
              (membersCanCreatePrivateRepositories as bool?),
        if (membersCanCreateInternalRepositories != _undefined)
          'membersCanCreateInternalRepositories':
              (membersCanCreateInternalRepositories as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? settingValue,
    bool? membersCanCreateRepositoriesPolicyEnabled,
    bool? membersCanCreatePublicRepositories,
    bool? membersCanCreatePrivateRepositories,
    bool? membersCanCreateInternalRepositories,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput {
  factory Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
          Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
    Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput instance,
    TRes Function(Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput {
  factory Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
          Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
    Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput {
  factory Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
          Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
    Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput {
  factory Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseMembersCanMakePurchasesSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseMembersCanMakePurchasesSettingValue get settingValue =>
      (_$data['settingValue']
          as Enum$EnterpriseMembersCanMakePurchasesSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(
            l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
          Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
    Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput instance,
    TRes Function(Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseMembersCanMakePurchasesSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue
              as Enum$EnterpriseMembersCanMakePurchasesSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseMembersCanMakePurchasesSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput {
  factory Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
          Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
    Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
        instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
      _instance;

  final TRes Function(
          Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
          ._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput {
  factory Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
          Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
    Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(
          Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseOrganizationProjectsSettingInput {
  factory Input$UpdateEnterpriseOrganizationProjectsSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseOrganizationProjectsSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseOrganizationProjectsSettingInput._(this._$data);

  factory Input$UpdateEnterpriseOrganizationProjectsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseOrganizationProjectsSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<
          Input$UpdateEnterpriseOrganizationProjectsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseOrganizationProjectsSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
    Input$UpdateEnterpriseOrganizationProjectsSettingInput instance,
    TRes Function(Input$UpdateEnterpriseOrganizationProjectsSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseOrganizationProjectsSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseOrganizationProjectsSettingInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseOrganizationProjectsSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseOwnerOrganizationRoleInput {
  factory Input$UpdateEnterpriseOwnerOrganizationRoleInput({
    required String enterpriseId,
    required String organizationId,
    required Enum$RoleInOrganization organizationRole,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseOwnerOrganizationRoleInput._({
        r'enterpriseId': enterpriseId,
        r'organizationId': organizationId,
        r'organizationRole': organizationRole,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseOwnerOrganizationRoleInput._(this._$data);

  factory Input$UpdateEnterpriseOwnerOrganizationRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$organizationRole = data['organizationRole'];
    result$data['organizationRole'] =
        fromJson$Enum$RoleInOrganization((l$organizationRole as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseOwnerOrganizationRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get organizationId => (_$data['organizationId'] as String);
  Enum$RoleInOrganization get organizationRole =>
      (_$data['organizationRole'] as Enum$RoleInOrganization);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$organizationRole = organizationRole;
    result$data['organizationRole'] =
        toJson$Enum$RoleInOrganization(l$organizationRole);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<
          Input$UpdateEnterpriseOwnerOrganizationRoleInput>
      get copyWith => CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseOwnerOrganizationRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$organizationRole = organizationRole;
    final lOther$organizationRole = other.organizationRole;
    if (l$organizationRole != lOther$organizationRole) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$organizationId = organizationId;
    final l$organizationRole = organizationRole;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$organizationId,
      l$organizationRole,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes> {
  factory CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput(
    Input$UpdateEnterpriseOwnerOrganizationRoleInput instance,
    TRes Function(Input$UpdateEnterpriseOwnerOrganizationRoleInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput;

  factory CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput;

  TRes call({
    String? enterpriseId,
    String? organizationId,
    Enum$RoleInOrganization? organizationRole,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseOwnerOrganizationRoleInput _instance;

  final TRes Function(Input$UpdateEnterpriseOwnerOrganizationRoleInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? organizationId = _undefined,
    Object? organizationRole = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseOwnerOrganizationRoleInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (organizationRole != _undefined && organizationRole != null)
          'organizationRole': (organizationRole as Enum$RoleInOrganization),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput(this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? organizationId,
    Enum$RoleInOrganization? organizationRole,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseProfileInput {
  factory Input$UpdateEnterpriseProfileInput({
    required String enterpriseId,
    String? name,
    String? description,
    String? websiteUrl,
    String? location,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseProfileInput._({
        r'enterpriseId': enterpriseId,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (websiteUrl != null) r'websiteUrl': websiteUrl,
        if (location != null) r'location': location,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseProfileInput._(this._$data);

  factory Input$UpdateEnterpriseProfileInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('websiteUrl')) {
      final l$websiteUrl = data['websiteUrl'];
      result$data['websiteUrl'] = (l$websiteUrl as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseProfileInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  String? get name => (_$data['name'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get websiteUrl => (_$data['websiteUrl'] as String?);
  String? get location => (_$data['location'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('websiteUrl')) {
      final l$websiteUrl = websiteUrl;
      result$data['websiteUrl'] = l$websiteUrl;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseProfileInput<
          Input$UpdateEnterpriseProfileInput>
      get copyWith => CopyWith$Input$UpdateEnterpriseProfileInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseProfileInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$websiteUrl = websiteUrl;
    final lOther$websiteUrl = other.websiteUrl;
    if (_$data.containsKey('websiteUrl') !=
        other._$data.containsKey('websiteUrl')) {
      return false;
    }
    if (l$websiteUrl != lOther$websiteUrl) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$name = name;
    final l$description = description;
    final l$websiteUrl = websiteUrl;
    final l$location = location;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('websiteUrl') ? l$websiteUrl : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseProfileInput<TRes> {
  factory CopyWith$Input$UpdateEnterpriseProfileInput(
    Input$UpdateEnterpriseProfileInput instance,
    TRes Function(Input$UpdateEnterpriseProfileInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseProfileInput;

  factory CopyWith$Input$UpdateEnterpriseProfileInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseProfileInput;

  TRes call({
    String? enterpriseId,
    String? name,
    String? description,
    String? websiteUrl,
    String? location,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseProfileInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseProfileInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseProfileInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseProfileInput _instance;

  final TRes Function(Input$UpdateEnterpriseProfileInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? websiteUrl = _undefined,
    Object? location = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseProfileInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (websiteUrl != _undefined) 'websiteUrl': (websiteUrl as String?),
        if (location != _undefined) 'location': (location as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseProfileInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseProfileInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseProfileInput(this._res);

  TRes _res;

  call({
    String? enterpriseId,
    String? name,
    String? description,
    String? websiteUrl,
    String? location,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseRepositoryProjectsSettingInput {
  factory Input$UpdateEnterpriseRepositoryProjectsSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseRepositoryProjectsSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseRepositoryProjectsSettingInput._(this._$data);

  factory Input$UpdateEnterpriseRepositoryProjectsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseRepositoryProjectsSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<
          Input$UpdateEnterpriseRepositoryProjectsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseRepositoryProjectsSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
    Input$UpdateEnterpriseRepositoryProjectsSettingInput instance,
    TRes Function(Input$UpdateEnterpriseRepositoryProjectsSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseRepositoryProjectsSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseRepositoryProjectsSettingInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseRepositoryProjectsSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseTeamDiscussionsSettingInput {
  factory Input$UpdateEnterpriseTeamDiscussionsSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseTeamDiscussionsSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseTeamDiscussionsSettingInput._(this._$data);

  factory Input$UpdateEnterpriseTeamDiscussionsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseTeamDiscussionsSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<
          Input$UpdateEnterpriseTeamDiscussionsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseTeamDiscussionsSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
    Input$UpdateEnterpriseTeamDiscussionsSettingInput instance,
    TRes Function(Input$UpdateEnterpriseTeamDiscussionsSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseTeamDiscussionsSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseTeamDiscussionsSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseTeamDiscussionsSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput {
  factory Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput({
    required String enterpriseId,
    required Enum$EnterpriseEnabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._({
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledSettingValue((l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
          Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
    Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;

  factory CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;

  TRes call({
    String? enterpriseId,
    Enum$EnterpriseEnabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(
          Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._({
        ..._instance._$data,
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue as Enum$EnterpriseEnabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
      this._res);

  TRes _res;

  call({
    String? enterpriseId,
    Enum$EnterpriseEnabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateEnvironmentInput {
  factory Input$UpdateEnvironmentInput({
    required String environmentId,
    int? waitTimer,
    List<String>? reviewers,
    String? clientMutationId,
  }) =>
      Input$UpdateEnvironmentInput._({
        r'environmentId': environmentId,
        if (waitTimer != null) r'waitTimer': waitTimer,
        if (reviewers != null) r'reviewers': reviewers,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateEnvironmentInput._(this._$data);

  factory Input$UpdateEnvironmentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$environmentId = data['environmentId'];
    result$data['environmentId'] = (l$environmentId as String);
    if (data.containsKey('waitTimer')) {
      final l$waitTimer = data['waitTimer'];
      result$data['waitTimer'] = (l$waitTimer as int?);
    }
    if (data.containsKey('reviewers')) {
      final l$reviewers = data['reviewers'];
      result$data['reviewers'] =
          (l$reviewers as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateEnvironmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get environmentId => (_$data['environmentId'] as String);
  int? get waitTimer => (_$data['waitTimer'] as int?);
  List<String>? get reviewers => (_$data['reviewers'] as List<String>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$environmentId = environmentId;
    result$data['environmentId'] = l$environmentId;
    if (_$data.containsKey('waitTimer')) {
      final l$waitTimer = waitTimer;
      result$data['waitTimer'] = l$waitTimer;
    }
    if (_$data.containsKey('reviewers')) {
      final l$reviewers = reviewers;
      result$data['reviewers'] = l$reviewers?.map((e) => e).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnvironmentInput<Input$UpdateEnvironmentInput>
      get copyWith => CopyWith$Input$UpdateEnvironmentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnvironmentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$environmentId = environmentId;
    final lOther$environmentId = other.environmentId;
    if (l$environmentId != lOther$environmentId) {
      return false;
    }
    final l$waitTimer = waitTimer;
    final lOther$waitTimer = other.waitTimer;
    if (_$data.containsKey('waitTimer') !=
        other._$data.containsKey('waitTimer')) {
      return false;
    }
    if (l$waitTimer != lOther$waitTimer) {
      return false;
    }
    final l$reviewers = reviewers;
    final lOther$reviewers = other.reviewers;
    if (_$data.containsKey('reviewers') !=
        other._$data.containsKey('reviewers')) {
      return false;
    }
    if (l$reviewers != null && lOther$reviewers != null) {
      if (l$reviewers.length != lOther$reviewers.length) {
        return false;
      }
      for (int i = 0; i < l$reviewers.length; i++) {
        final l$reviewers$entry = l$reviewers[i];
        final lOther$reviewers$entry = lOther$reviewers[i];
        if (l$reviewers$entry != lOther$reviewers$entry) {
          return false;
        }
      }
    } else if (l$reviewers != lOther$reviewers) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$environmentId = environmentId;
    final l$waitTimer = waitTimer;
    final l$reviewers = reviewers;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$environmentId,
      _$data.containsKey('waitTimer') ? l$waitTimer : const {},
      _$data.containsKey('reviewers')
          ? l$reviewers == null
              ? null
              : Object.hashAll(l$reviewers.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnvironmentInput<TRes> {
  factory CopyWith$Input$UpdateEnvironmentInput(
    Input$UpdateEnvironmentInput instance,
    TRes Function(Input$UpdateEnvironmentInput) then,
  ) = _CopyWithImpl$Input$UpdateEnvironmentInput;

  factory CopyWith$Input$UpdateEnvironmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEnvironmentInput;

  TRes call({
    String? environmentId,
    int? waitTimer,
    List<String>? reviewers,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateEnvironmentInput<TRes>
    implements CopyWith$Input$UpdateEnvironmentInput<TRes> {
  _CopyWithImpl$Input$UpdateEnvironmentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnvironmentInput _instance;

  final TRes Function(Input$UpdateEnvironmentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? environmentId = _undefined,
    Object? waitTimer = _undefined,
    Object? reviewers = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateEnvironmentInput._({
        ..._instance._$data,
        if (environmentId != _undefined && environmentId != null)
          'environmentId': (environmentId as String),
        if (waitTimer != _undefined) 'waitTimer': (waitTimer as int?),
        if (reviewers != _undefined) 'reviewers': (reviewers as List<String>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnvironmentInput<TRes>
    implements CopyWith$Input$UpdateEnvironmentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnvironmentInput(this._res);

  TRes _res;

  call({
    String? environmentId,
    int? waitTimer,
    List<String>? reviewers,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateIpAllowListEnabledSettingInput {
  factory Input$UpdateIpAllowListEnabledSettingInput({
    required String ownerId,
    required Enum$IpAllowListEnabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateIpAllowListEnabledSettingInput._({
        r'ownerId': ownerId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateIpAllowListEnabledSettingInput._(this._$data);

  factory Input$UpdateIpAllowListEnabledSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] = fromJson$Enum$IpAllowListEnabledSettingValue(
        (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateIpAllowListEnabledSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get ownerId => (_$data['ownerId'] as String);
  Enum$IpAllowListEnabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$IpAllowListEnabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$IpAllowListEnabledSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateIpAllowListEnabledSettingInput<
          Input$UpdateIpAllowListEnabledSettingInput>
      get copyWith => CopyWith$Input$UpdateIpAllowListEnabledSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateIpAllowListEnabledSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ownerId = ownerId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$ownerId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateIpAllowListEnabledSettingInput<TRes> {
  factory CopyWith$Input$UpdateIpAllowListEnabledSettingInput(
    Input$UpdateIpAllowListEnabledSettingInput instance,
    TRes Function(Input$UpdateIpAllowListEnabledSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateIpAllowListEnabledSettingInput;

  factory CopyWith$Input$UpdateIpAllowListEnabledSettingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIpAllowListEnabledSettingInput;

  TRes call({
    String? ownerId,
    Enum$IpAllowListEnabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateIpAllowListEnabledSettingInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEnabledSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateIpAllowListEnabledSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIpAllowListEnabledSettingInput _instance;

  final TRes Function(Input$UpdateIpAllowListEnabledSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? ownerId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateIpAllowListEnabledSettingInput._({
        ..._instance._$data,
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue as Enum$IpAllowListEnabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateIpAllowListEnabledSettingInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEnabledSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIpAllowListEnabledSettingInput(this._res);

  TRes _res;

  call({
    String? ownerId,
    Enum$IpAllowListEnabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateIpAllowListEntryInput {
  factory Input$UpdateIpAllowListEntryInput({
    required String ipAllowListEntryId,
    required String allowListValue,
    String? name,
    required bool isActive,
    String? clientMutationId,
  }) =>
      Input$UpdateIpAllowListEntryInput._({
        r'ipAllowListEntryId': ipAllowListEntryId,
        r'allowListValue': allowListValue,
        if (name != null) r'name': name,
        r'isActive': isActive,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateIpAllowListEntryInput._(this._$data);

  factory Input$UpdateIpAllowListEntryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$ipAllowListEntryId = data['ipAllowListEntryId'];
    result$data['ipAllowListEntryId'] = (l$ipAllowListEntryId as String);
    final l$allowListValue = data['allowListValue'];
    result$data['allowListValue'] = (l$allowListValue as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    final l$isActive = data['isActive'];
    result$data['isActive'] = (l$isActive as bool);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateIpAllowListEntryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get ipAllowListEntryId => (_$data['ipAllowListEntryId'] as String);
  String get allowListValue => (_$data['allowListValue'] as String);
  String? get name => (_$data['name'] as String?);
  bool get isActive => (_$data['isActive'] as bool);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ipAllowListEntryId = ipAllowListEntryId;
    result$data['ipAllowListEntryId'] = l$ipAllowListEntryId;
    final l$allowListValue = allowListValue;
    result$data['allowListValue'] = l$allowListValue;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    final l$isActive = isActive;
    result$data['isActive'] = l$isActive;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateIpAllowListEntryInput<Input$UpdateIpAllowListEntryInput>
      get copyWith => CopyWith$Input$UpdateIpAllowListEntryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateIpAllowListEntryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ipAllowListEntryId = ipAllowListEntryId;
    final lOther$ipAllowListEntryId = other.ipAllowListEntryId;
    if (l$ipAllowListEntryId != lOther$ipAllowListEntryId) {
      return false;
    }
    final l$allowListValue = allowListValue;
    final lOther$allowListValue = other.allowListValue;
    if (l$allowListValue != lOther$allowListValue) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ipAllowListEntryId = ipAllowListEntryId;
    final l$allowListValue = allowListValue;
    final l$name = name;
    final l$isActive = isActive;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$ipAllowListEntryId,
      l$allowListValue,
      _$data.containsKey('name') ? l$name : const {},
      l$isActive,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateIpAllowListEntryInput<TRes> {
  factory CopyWith$Input$UpdateIpAllowListEntryInput(
    Input$UpdateIpAllowListEntryInput instance,
    TRes Function(Input$UpdateIpAllowListEntryInput) then,
  ) = _CopyWithImpl$Input$UpdateIpAllowListEntryInput;

  factory CopyWith$Input$UpdateIpAllowListEntryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIpAllowListEntryInput;

  TRes call({
    String? ipAllowListEntryId,
    String? allowListValue,
    String? name,
    bool? isActive,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEntryInput<TRes> {
  _CopyWithImpl$Input$UpdateIpAllowListEntryInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIpAllowListEntryInput _instance;

  final TRes Function(Input$UpdateIpAllowListEntryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? ipAllowListEntryId = _undefined,
    Object? allowListValue = _undefined,
    Object? name = _undefined,
    Object? isActive = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateIpAllowListEntryInput._({
        ..._instance._$data,
        if (ipAllowListEntryId != _undefined && ipAllowListEntryId != null)
          'ipAllowListEntryId': (ipAllowListEntryId as String),
        if (allowListValue != _undefined && allowListValue != null)
          'allowListValue': (allowListValue as String),
        if (name != _undefined) 'name': (name as String?),
        if (isActive != _undefined && isActive != null)
          'isActive': (isActive as bool),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEntryInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIpAllowListEntryInput(this._res);

  TRes _res;

  call({
    String? ipAllowListEntryId,
    String? allowListValue,
    String? name,
    bool? isActive,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput {
  factory Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput({
    required String ownerId,
    required Enum$IpAllowListForInstalledAppsEnabledSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._({
        r'ownerId': ownerId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._(this._$data);

  factory Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get ownerId => (_$data['ownerId'] as String);
  Enum$IpAllowListForInstalledAppsEnabledSettingValue get settingValue =>
      (_$data['settingValue']
          as Enum$IpAllowListForInstalledAppsEnabledSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(
            l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
          Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ownerId = ownerId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$ownerId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
    Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput instance,
    TRes Function(Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput;

  factory CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput;

  TRes call({
    String? ownerId,
    Enum$IpAllowListForInstalledAppsEnabledSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput _instance;

  final TRes Function(
      Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? ownerId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._({
        ..._instance._$data,
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue
              as Enum$IpAllowListForInstalledAppsEnabledSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
      this._res);

  TRes _res;

  call({
    String? ownerId,
    Enum$IpAllowListForInstalledAppsEnabledSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateIssueCommentInput {
  factory Input$UpdateIssueCommentInput({
    required String id,
    required String body,
    String? clientMutationId,
  }) =>
      Input$UpdateIssueCommentInput._({
        r'id': id,
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateIssueCommentInput._(this._$data);

  factory Input$UpdateIssueCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateIssueCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateIssueCommentInput<Input$UpdateIssueCommentInput>
      get copyWith => CopyWith$Input$UpdateIssueCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateIssueCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateIssueCommentInput<TRes> {
  factory CopyWith$Input$UpdateIssueCommentInput(
    Input$UpdateIssueCommentInput instance,
    TRes Function(Input$UpdateIssueCommentInput) then,
  ) = _CopyWithImpl$Input$UpdateIssueCommentInput;

  factory CopyWith$Input$UpdateIssueCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIssueCommentInput;

  TRes call({
    String? id,
    String? body,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateIssueCommentInput<TRes>
    implements CopyWith$Input$UpdateIssueCommentInput<TRes> {
  _CopyWithImpl$Input$UpdateIssueCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIssueCommentInput _instance;

  final TRes Function(Input$UpdateIssueCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateIssueCommentInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateIssueCommentInput<TRes>
    implements CopyWith$Input$UpdateIssueCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIssueCommentInput(this._res);

  TRes _res;

  call({
    String? id,
    String? body,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateIssueInput {
  factory Input$UpdateIssueInput({
    required String id,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    Enum$IssueState? state,
    List<String>? projectIds,
    String? clientMutationId,
  }) =>
      Input$UpdateIssueInput._({
        r'id': id,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (labelIds != null) r'labelIds': labelIds,
        if (state != null) r'state': state,
        if (projectIds != null) r'projectIds': projectIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateIssueInput._(this._$data);

  factory Input$UpdateIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$IssueState((l$state as String));
    }
    if (data.containsKey('projectIds')) {
      final l$projectIds = data['projectIds'];
      result$data['projectIds'] =
          (l$projectIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get title => (_$data['title'] as String?);
  String? get body => (_$data['body'] as String?);
  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  Enum$IssueState? get state => (_$data['state'] as Enum$IssueState?);
  List<String>? get projectIds => (_$data['projectIds'] as List<String>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$IssueState(l$state);
    }
    if (_$data.containsKey('projectIds')) {
      final l$projectIds = projectIds;
      result$data['projectIds'] = l$projectIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateIssueInput<Input$UpdateIssueInput> get copyWith =>
      CopyWith$Input$UpdateIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$projectIds = projectIds;
    final lOther$projectIds = other.projectIds;
    if (_$data.containsKey('projectIds') !=
        other._$data.containsKey('projectIds')) {
      return false;
    }
    if (l$projectIds != null && lOther$projectIds != null) {
      if (l$projectIds.length != lOther$projectIds.length) {
        return false;
      }
      for (int i = 0; i < l$projectIds.length; i++) {
        final l$projectIds$entry = l$projectIds[i];
        final lOther$projectIds$entry = lOther$projectIds[i];
        if (l$projectIds$entry != lOther$projectIds$entry) {
          return false;
        }
      }
    } else if (l$projectIds != lOther$projectIds) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$title = title;
    final l$body = body;
    final l$assigneeIds = assigneeIds;
    final l$milestoneId = milestoneId;
    final l$labelIds = labelIds;
    final l$state = state;
    final l$projectIds = projectIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('projectIds')
          ? l$projectIds == null
              ? null
              : Object.hashAll(l$projectIds.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateIssueInput<TRes> {
  factory CopyWith$Input$UpdateIssueInput(
    Input$UpdateIssueInput instance,
    TRes Function(Input$UpdateIssueInput) then,
  ) = _CopyWithImpl$Input$UpdateIssueInput;

  factory CopyWith$Input$UpdateIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIssueInput;

  TRes call({
    String? id,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    Enum$IssueState? state,
    List<String>? projectIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateIssueInput<TRes>
    implements CopyWith$Input$UpdateIssueInput<TRes> {
  _CopyWithImpl$Input$UpdateIssueInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIssueInput _instance;

  final TRes Function(Input$UpdateIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? assigneeIds = _undefined,
    Object? milestoneId = _undefined,
    Object? labelIds = _undefined,
    Object? state = _undefined,
    Object? projectIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateIssueInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (state != _undefined) 'state': (state as Enum$IssueState?),
        if (projectIds != _undefined)
          'projectIds': (projectIds as List<String>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateIssueInput<TRes>
    implements CopyWith$Input$UpdateIssueInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIssueInput(this._res);

  TRes _res;

  call({
    String? id,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    Enum$IssueState? state,
    List<String>? projectIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateNotificationRestrictionSettingInput {
  factory Input$UpdateNotificationRestrictionSettingInput({
    required String ownerId,
    required Enum$NotificationRestrictionSettingValue settingValue,
    String? clientMutationId,
  }) =>
      Input$UpdateNotificationRestrictionSettingInput._({
        r'ownerId': ownerId,
        r'settingValue': settingValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateNotificationRestrictionSettingInput._(this._$data);

  factory Input$UpdateNotificationRestrictionSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$NotificationRestrictionSettingValue(
            (l$settingValue as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateNotificationRestrictionSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get ownerId => (_$data['ownerId'] as String);
  Enum$NotificationRestrictionSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$NotificationRestrictionSettingValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$NotificationRestrictionSettingValue(l$settingValue);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateNotificationRestrictionSettingInput<
          Input$UpdateNotificationRestrictionSettingInput>
      get copyWith => CopyWith$Input$UpdateNotificationRestrictionSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateNotificationRestrictionSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$ownerId = ownerId;
    final l$settingValue = settingValue;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$ownerId,
      l$settingValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateNotificationRestrictionSettingInput<TRes> {
  factory CopyWith$Input$UpdateNotificationRestrictionSettingInput(
    Input$UpdateNotificationRestrictionSettingInput instance,
    TRes Function(Input$UpdateNotificationRestrictionSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateNotificationRestrictionSettingInput;

  factory CopyWith$Input$UpdateNotificationRestrictionSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateNotificationRestrictionSettingInput;

  TRes call({
    String? ownerId,
    Enum$NotificationRestrictionSettingValue? settingValue,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateNotificationRestrictionSettingInput<TRes>
    implements CopyWith$Input$UpdateNotificationRestrictionSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateNotificationRestrictionSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateNotificationRestrictionSettingInput _instance;

  final TRes Function(Input$UpdateNotificationRestrictionSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? ownerId = _undefined,
    Object? settingValue = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateNotificationRestrictionSettingInput._({
        ..._instance._$data,
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$NotificationRestrictionSettingValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateNotificationRestrictionSettingInput<TRes>
    implements CopyWith$Input$UpdateNotificationRestrictionSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateNotificationRestrictionSettingInput(this._res);

  TRes _res;

  call({
    String? ownerId,
    Enum$NotificationRestrictionSettingValue? settingValue,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput {
  factory Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput({
    required String organizationId,
    required bool forkingEnabled,
    String? clientMutationId,
  }) =>
      Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._({
        r'organizationId': organizationId,
        r'forkingEnabled': forkingEnabled,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._(
      this._$data);

  factory Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$forkingEnabled = data['forkingEnabled'];
    result$data['forkingEnabled'] = (l$forkingEnabled as bool);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String get organizationId => (_$data['organizationId'] as String);
  bool get forkingEnabled => (_$data['forkingEnabled'] as bool);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$forkingEnabled = forkingEnabled;
    result$data['forkingEnabled'] = l$forkingEnabled;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
          Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$forkingEnabled = forkingEnabled;
    final lOther$forkingEnabled = other.forkingEnabled;
    if (l$forkingEnabled != lOther$forkingEnabled) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$organizationId = organizationId;
    final l$forkingEnabled = forkingEnabled;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$organizationId,
      l$forkingEnabled,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
    Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput instance,
    TRes Function(
            Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;

  factory CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;

  TRes call({
    String? organizationId,
    bool? forkingEnabled,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput
      _instance;

  final TRes Function(
      Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? organizationId = _undefined,
    Object? forkingEnabled = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(
          Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._({
        ..._instance._$data,
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (forkingEnabled != _undefined && forkingEnabled != null)
          'forkingEnabled': (forkingEnabled as bool),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
      this._res);

  TRes _res;

  call({
    String? organizationId,
    bool? forkingEnabled,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateOrganizationWebCommitSignoffSettingInput {
  factory Input$UpdateOrganizationWebCommitSignoffSettingInput({
    required String organizationId,
    required bool webCommitSignoffRequired,
    String? clientMutationId,
  }) =>
      Input$UpdateOrganizationWebCommitSignoffSettingInput._({
        r'organizationId': organizationId,
        r'webCommitSignoffRequired': webCommitSignoffRequired,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateOrganizationWebCommitSignoffSettingInput._(this._$data);

  factory Input$UpdateOrganizationWebCommitSignoffSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$webCommitSignoffRequired = data['webCommitSignoffRequired'];
    result$data['webCommitSignoffRequired'] =
        (l$webCommitSignoffRequired as bool);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateOrganizationWebCommitSignoffSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get organizationId => (_$data['organizationId'] as String);
  bool get webCommitSignoffRequired =>
      (_$data['webCommitSignoffRequired'] as bool);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    result$data['webCommitSignoffRequired'] = l$webCommitSignoffRequired;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<
          Input$UpdateOrganizationWebCommitSignoffSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateOrganizationWebCommitSignoffSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    final lOther$webCommitSignoffRequired = other.webCommitSignoffRequired;
    if (l$webCommitSignoffRequired != lOther$webCommitSignoffRequired) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$organizationId = organizationId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$organizationId,
      l$webCommitSignoffRequired,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput(
    Input$UpdateOrganizationWebCommitSignoffSettingInput instance,
    TRes Function(Input$UpdateOrganizationWebCommitSignoffSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput;

  factory CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput;

  TRes call({
    String? organizationId,
    bool? webCommitSignoffRequired,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput<TRes>
    implements
        CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateOrganizationWebCommitSignoffSettingInput _instance;

  final TRes Function(Input$UpdateOrganizationWebCommitSignoffSettingInput)
      _then;

  static const _undefined = {};

  TRes call({
    Object? organizationId = _undefined,
    Object? webCommitSignoffRequired = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateOrganizationWebCommitSignoffSettingInput._({
        ..._instance._$data,
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (webCommitSignoffRequired != _undefined &&
            webCommitSignoffRequired != null)
          'webCommitSignoffRequired': (webCommitSignoffRequired as bool),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput(
      this._res);

  TRes _res;

  call({
    String? organizationId,
    bool? webCommitSignoffRequired,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateProjectCardInput {
  factory Input$UpdateProjectCardInput({
    required String projectCardId,
    bool? isArchived,
    String? note,
    String? clientMutationId,
  }) =>
      Input$UpdateProjectCardInput._({
        r'projectCardId': projectCardId,
        if (isArchived != null) r'isArchived': isArchived,
        if (note != null) r'note': note,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateProjectCardInput._(this._$data);

  factory Input$UpdateProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectCardId = data['projectCardId'];
    result$data['projectCardId'] = (l$projectCardId as String);
    if (data.containsKey('isArchived')) {
      final l$isArchived = data['isArchived'];
      result$data['isArchived'] = (l$isArchived as bool?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectCardId => (_$data['projectCardId'] as String);
  bool? get isArchived => (_$data['isArchived'] as bool?);
  String? get note => (_$data['note'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectCardId = projectCardId;
    result$data['projectCardId'] = l$projectCardId;
    if (_$data.containsKey('isArchived')) {
      final l$isArchived = isArchived;
      result$data['isArchived'] = l$isArchived;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectCardInput<Input$UpdateProjectCardInput>
      get copyWith => CopyWith$Input$UpdateProjectCardInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectCardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectCardId = projectCardId;
    final lOther$projectCardId = other.projectCardId;
    if (l$projectCardId != lOther$projectCardId) {
      return false;
    }
    final l$isArchived = isArchived;
    final lOther$isArchived = other.isArchived;
    if (_$data.containsKey('isArchived') !=
        other._$data.containsKey('isArchived')) {
      return false;
    }
    if (l$isArchived != lOther$isArchived) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectCardId = projectCardId;
    final l$isArchived = isArchived;
    final l$note = note;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectCardId,
      _$data.containsKey('isArchived') ? l$isArchived : const {},
      _$data.containsKey('note') ? l$note : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectCardInput<TRes> {
  factory CopyWith$Input$UpdateProjectCardInput(
    Input$UpdateProjectCardInput instance,
    TRes Function(Input$UpdateProjectCardInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectCardInput;

  factory CopyWith$Input$UpdateProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectCardInput;

  TRes call({
    String? projectCardId,
    bool? isArchived,
    String? note,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateProjectCardInput<TRes>
    implements CopyWith$Input$UpdateProjectCardInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectCardInput _instance;

  final TRes Function(Input$UpdateProjectCardInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectCardId = _undefined,
    Object? isArchived = _undefined,
    Object? note = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateProjectCardInput._({
        ..._instance._$data,
        if (projectCardId != _undefined && projectCardId != null)
          'projectCardId': (projectCardId as String),
        if (isArchived != _undefined) 'isArchived': (isArchived as bool?),
        if (note != _undefined) 'note': (note as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectCardInput<TRes>
    implements CopyWith$Input$UpdateProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectCardInput(this._res);

  TRes _res;

  call({
    String? projectCardId,
    bool? isArchived,
    String? note,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateProjectColumnInput {
  factory Input$UpdateProjectColumnInput({
    required String projectColumnId,
    required String name,
    String? clientMutationId,
  }) =>
      Input$UpdateProjectColumnInput._({
        r'projectColumnId': projectColumnId,
        r'name': name,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateProjectColumnInput._(this._$data);

  factory Input$UpdateProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectColumnId = data['projectColumnId'];
    result$data['projectColumnId'] = (l$projectColumnId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectColumnId => (_$data['projectColumnId'] as String);
  String get name => (_$data['name'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectColumnId = projectColumnId;
    result$data['projectColumnId'] = l$projectColumnId;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectColumnInput<Input$UpdateProjectColumnInput>
      get copyWith => CopyWith$Input$UpdateProjectColumnInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectColumnInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectColumnId = projectColumnId;
    final lOther$projectColumnId = other.projectColumnId;
    if (l$projectColumnId != lOther$projectColumnId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectColumnId = projectColumnId;
    final l$name = name;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectColumnId,
      l$name,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectColumnInput<TRes> {
  factory CopyWith$Input$UpdateProjectColumnInput(
    Input$UpdateProjectColumnInput instance,
    TRes Function(Input$UpdateProjectColumnInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectColumnInput;

  factory CopyWith$Input$UpdateProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectColumnInput;

  TRes call({
    String? projectColumnId,
    String? name,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateProjectColumnInput<TRes>
    implements CopyWith$Input$UpdateProjectColumnInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectColumnInput _instance;

  final TRes Function(Input$UpdateProjectColumnInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectColumnId = _undefined,
    Object? name = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateProjectColumnInput._({
        ..._instance._$data,
        if (projectColumnId != _undefined && projectColumnId != null)
          'projectColumnId': (projectColumnId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectColumnInput<TRes>
    implements CopyWith$Input$UpdateProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectColumnInput(this._res);

  TRes _res;

  call({
    String? projectColumnId,
    String? name,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateProjectDraftIssueInput {
  factory Input$UpdateProjectDraftIssueInput({
    required String draftIssueId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      Input$UpdateProjectDraftIssueInput._({
        r'draftIssueId': draftIssueId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateProjectDraftIssueInput._(this._$data);

  factory Input$UpdateProjectDraftIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$draftIssueId = data['draftIssueId'];
    result$data['draftIssueId'] = (l$draftIssueId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateProjectDraftIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get draftIssueId => (_$data['draftIssueId'] as String);
  String? get title => (_$data['title'] as String?);
  String? get body => (_$data['body'] as String?);
  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$draftIssueId = draftIssueId;
    result$data['draftIssueId'] = l$draftIssueId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectDraftIssueInput<
          Input$UpdateProjectDraftIssueInput>
      get copyWith => CopyWith$Input$UpdateProjectDraftIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectDraftIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$draftIssueId = draftIssueId;
    final lOther$draftIssueId = other.draftIssueId;
    if (l$draftIssueId != lOther$draftIssueId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$draftIssueId = draftIssueId;
    final l$title = title;
    final l$body = body;
    final l$assigneeIds = assigneeIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$draftIssueId,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectDraftIssueInput<TRes> {
  factory CopyWith$Input$UpdateProjectDraftIssueInput(
    Input$UpdateProjectDraftIssueInput instance,
    TRes Function(Input$UpdateProjectDraftIssueInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectDraftIssueInput;

  factory CopyWith$Input$UpdateProjectDraftIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectDraftIssueInput;

  TRes call({
    String? draftIssueId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateProjectDraftIssueInput<TRes>
    implements CopyWith$Input$UpdateProjectDraftIssueInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectDraftIssueInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectDraftIssueInput _instance;

  final TRes Function(Input$UpdateProjectDraftIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? draftIssueId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? assigneeIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateProjectDraftIssueInput._({
        ..._instance._$data,
        if (draftIssueId != _undefined && draftIssueId != null)
          'draftIssueId': (draftIssueId as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectDraftIssueInput<TRes>
    implements CopyWith$Input$UpdateProjectDraftIssueInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectDraftIssueInput(this._res);

  TRes _res;

  call({
    String? draftIssueId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateProjectInput {
  factory Input$UpdateProjectInput({
    required String projectId,
    String? name,
    String? body,
    Enum$ProjectState? state,
    bool? public,
    String? clientMutationId,
  }) =>
      Input$UpdateProjectInput._({
        r'projectId': projectId,
        if (name != null) r'name': name,
        if (body != null) r'body': body,
        if (state != null) r'state': state,
        if (public != null) r'public': public,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateProjectInput._(this._$data);

  factory Input$UpdateProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$ProjectState((l$state as String));
    }
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String? get name => (_$data['name'] as String?);
  String? get body => (_$data['body'] as String?);
  Enum$ProjectState? get state => (_$data['state'] as Enum$ProjectState?);
  bool? get public => (_$data['public'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$ProjectState(l$state);
    }
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectInput<Input$UpdateProjectInput> get copyWith =>
      CopyWith$Input$UpdateProjectInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$name = name;
    final l$body = body;
    final l$state = state;
    final l$public = public;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('public') ? l$public : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectInput<TRes> {
  factory CopyWith$Input$UpdateProjectInput(
    Input$UpdateProjectInput instance,
    TRes Function(Input$UpdateProjectInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectInput;

  factory CopyWith$Input$UpdateProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectInput;

  TRes call({
    String? projectId,
    String? name,
    String? body,
    Enum$ProjectState? state,
    bool? public,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateProjectInput<TRes>
    implements CopyWith$Input$UpdateProjectInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectInput _instance;

  final TRes Function(Input$UpdateProjectInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? name = _undefined,
    Object? body = _undefined,
    Object? state = _undefined,
    Object? public = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateProjectInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (name != _undefined) 'name': (name as String?),
        if (body != _undefined) 'body': (body as String?),
        if (state != _undefined) 'state': (state as Enum$ProjectState?),
        if (public != _undefined) 'public': (public as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectInput<TRes>
    implements CopyWith$Input$UpdateProjectInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? name,
    String? body,
    Enum$ProjectState? state,
    bool? public,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateProjectNextInput {
  factory Input$UpdateProjectNextInput({
    String? projectId,
    String? title,
    String? description,
    String? shortDescription,
    bool? closed,
    bool? public,
    String? clientMutationId,
  }) =>
      Input$UpdateProjectNextInput._({
        if (projectId != null) r'projectId': projectId,
        if (title != null) r'title': title,
        if (description != null) r'description': description,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (closed != null) r'closed': closed,
        if (public != null) r'public': public,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateProjectNextInput._(this._$data);

  factory Input$UpdateProjectNextInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('projectId')) {
      final l$projectId = data['projectId'];
      result$data['projectId'] = (l$projectId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('closed')) {
      final l$closed = data['closed'];
      result$data['closed'] = (l$closed as bool?);
    }
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateProjectNextInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get projectId => (_$data['projectId'] as String?);
  String? get title => (_$data['title'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get shortDescription => (_$data['shortDescription'] as String?);
  bool? get closed => (_$data['closed'] as bool?);
  bool? get public => (_$data['public'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('projectId')) {
      final l$projectId = projectId;
      result$data['projectId'] = l$projectId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('closed')) {
      final l$closed = closed;
      result$data['closed'] = l$closed;
    }
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectNextInput<Input$UpdateProjectNextInput>
      get copyWith => CopyWith$Input$UpdateProjectNextInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectNextInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (_$data.containsKey('projectId') !=
        other._$data.containsKey('projectId')) {
      return false;
    }
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$closed = closed;
    final lOther$closed = other.closed;
    if (_$data.containsKey('closed') != other._$data.containsKey('closed')) {
      return false;
    }
    if (l$closed != lOther$closed) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$title = title;
    final l$description = description;
    final l$shortDescription = shortDescription;
    final l$closed = closed;
    final l$public = public;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('projectId') ? l$projectId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('closed') ? l$closed : const {},
      _$data.containsKey('public') ? l$public : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectNextInput<TRes> {
  factory CopyWith$Input$UpdateProjectNextInput(
    Input$UpdateProjectNextInput instance,
    TRes Function(Input$UpdateProjectNextInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectNextInput;

  factory CopyWith$Input$UpdateProjectNextInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectNextInput;

  TRes call({
    String? projectId,
    String? title,
    String? description,
    String? shortDescription,
    bool? closed,
    bool? public,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateProjectNextInput<TRes>
    implements CopyWith$Input$UpdateProjectNextInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectNextInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectNextInput _instance;

  final TRes Function(Input$UpdateProjectNextInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? title = _undefined,
    Object? description = _undefined,
    Object? shortDescription = _undefined,
    Object? closed = _undefined,
    Object? public = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateProjectNextInput._({
        ..._instance._$data,
        if (projectId != _undefined) 'projectId': (projectId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (description != _undefined) 'description': (description as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (closed != _undefined) 'closed': (closed as bool?),
        if (public != _undefined) 'public': (public as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectNextInput<TRes>
    implements CopyWith$Input$UpdateProjectNextInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectNextInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? title,
    String? description,
    String? shortDescription,
    bool? closed,
    bool? public,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateProjectNextItemFieldInput {
  factory Input$UpdateProjectNextItemFieldInput({
    String? projectId,
    String? itemId,
    String? fieldId,
    String? value,
    String? clientMutationId,
  }) =>
      Input$UpdateProjectNextItemFieldInput._({
        if (projectId != null) r'projectId': projectId,
        if (itemId != null) r'itemId': itemId,
        if (fieldId != null) r'fieldId': fieldId,
        if (value != null) r'value': value,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateProjectNextItemFieldInput._(this._$data);

  factory Input$UpdateProjectNextItemFieldInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('projectId')) {
      final l$projectId = data['projectId'];
      result$data['projectId'] = (l$projectId as String?);
    }
    if (data.containsKey('itemId')) {
      final l$itemId = data['itemId'];
      result$data['itemId'] = (l$itemId as String?);
    }
    if (data.containsKey('fieldId')) {
      final l$fieldId = data['fieldId'];
      result$data['fieldId'] = (l$fieldId as String?);
    }
    if (data.containsKey('value')) {
      final l$value = data['value'];
      result$data['value'] = (l$value as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateProjectNextItemFieldInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get projectId => (_$data['projectId'] as String?);
  String? get itemId => (_$data['itemId'] as String?);
  String? get fieldId => (_$data['fieldId'] as String?);
  String? get value => (_$data['value'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('projectId')) {
      final l$projectId = projectId;
      result$data['projectId'] = l$projectId;
    }
    if (_$data.containsKey('itemId')) {
      final l$itemId = itemId;
      result$data['itemId'] = l$itemId;
    }
    if (_$data.containsKey('fieldId')) {
      final l$fieldId = fieldId;
      result$data['fieldId'] = l$fieldId;
    }
    if (_$data.containsKey('value')) {
      final l$value = value;
      result$data['value'] = l$value;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectNextItemFieldInput<
          Input$UpdateProjectNextItemFieldInput>
      get copyWith => CopyWith$Input$UpdateProjectNextItemFieldInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectNextItemFieldInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (_$data.containsKey('projectId') !=
        other._$data.containsKey('projectId')) {
      return false;
    }
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (_$data.containsKey('itemId') != other._$data.containsKey('itemId')) {
      return false;
    }
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$fieldId = fieldId;
    final lOther$fieldId = other.fieldId;
    if (_$data.containsKey('fieldId') != other._$data.containsKey('fieldId')) {
      return false;
    }
    if (l$fieldId != lOther$fieldId) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (_$data.containsKey('value') != other._$data.containsKey('value')) {
      return false;
    }
    if (l$value != lOther$value) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$itemId = itemId;
    final l$fieldId = fieldId;
    final l$value = value;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('projectId') ? l$projectId : const {},
      _$data.containsKey('itemId') ? l$itemId : const {},
      _$data.containsKey('fieldId') ? l$fieldId : const {},
      _$data.containsKey('value') ? l$value : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectNextItemFieldInput<TRes> {
  factory CopyWith$Input$UpdateProjectNextItemFieldInput(
    Input$UpdateProjectNextItemFieldInput instance,
    TRes Function(Input$UpdateProjectNextItemFieldInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectNextItemFieldInput;

  factory CopyWith$Input$UpdateProjectNextItemFieldInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectNextItemFieldInput;

  TRes call({
    String? projectId,
    String? itemId,
    String? fieldId,
    String? value,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateProjectNextItemFieldInput<TRes>
    implements CopyWith$Input$UpdateProjectNextItemFieldInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectNextItemFieldInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectNextItemFieldInput _instance;

  final TRes Function(Input$UpdateProjectNextItemFieldInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? itemId = _undefined,
    Object? fieldId = _undefined,
    Object? value = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateProjectNextItemFieldInput._({
        ..._instance._$data,
        if (projectId != _undefined) 'projectId': (projectId as String?),
        if (itemId != _undefined) 'itemId': (itemId as String?),
        if (fieldId != _undefined) 'fieldId': (fieldId as String?),
        if (value != _undefined) 'value': (value as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectNextItemFieldInput<TRes>
    implements CopyWith$Input$UpdateProjectNextItemFieldInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectNextItemFieldInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? itemId,
    String? fieldId,
    String? value,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateProjectV2DraftIssueInput {
  factory Input$UpdateProjectV2DraftIssueInput({
    required String draftIssueId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      Input$UpdateProjectV2DraftIssueInput._({
        r'draftIssueId': draftIssueId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateProjectV2DraftIssueInput._(this._$data);

  factory Input$UpdateProjectV2DraftIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$draftIssueId = data['draftIssueId'];
    result$data['draftIssueId'] = (l$draftIssueId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateProjectV2DraftIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get draftIssueId => (_$data['draftIssueId'] as String);
  String? get title => (_$data['title'] as String?);
  String? get body => (_$data['body'] as String?);
  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$draftIssueId = draftIssueId;
    result$data['draftIssueId'] = l$draftIssueId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2DraftIssueInput<
          Input$UpdateProjectV2DraftIssueInput>
      get copyWith => CopyWith$Input$UpdateProjectV2DraftIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectV2DraftIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$draftIssueId = draftIssueId;
    final lOther$draftIssueId = other.draftIssueId;
    if (l$draftIssueId != lOther$draftIssueId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$draftIssueId = draftIssueId;
    final l$title = title;
    final l$body = body;
    final l$assigneeIds = assigneeIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$draftIssueId,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2DraftIssueInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2DraftIssueInput(
    Input$UpdateProjectV2DraftIssueInput instance,
    TRes Function(Input$UpdateProjectV2DraftIssueInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2DraftIssueInput;

  factory CopyWith$Input$UpdateProjectV2DraftIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2DraftIssueInput;

  TRes call({
    String? draftIssueId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2DraftIssueInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2DraftIssueInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2DraftIssueInput _instance;

  final TRes Function(Input$UpdateProjectV2DraftIssueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? draftIssueId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? assigneeIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateProjectV2DraftIssueInput._({
        ..._instance._$data,
        if (draftIssueId != _undefined && draftIssueId != null)
          'draftIssueId': (draftIssueId as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2DraftIssueInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2DraftIssueInput(this._res);

  TRes _res;

  call({
    String? draftIssueId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateProjectV2Input {
  factory Input$UpdateProjectV2Input({
    required String projectId,
    String? title,
    String? shortDescription,
    String? readme,
    bool? closed,
    bool? public,
    String? clientMutationId,
  }) =>
      Input$UpdateProjectV2Input._({
        r'projectId': projectId,
        if (title != null) r'title': title,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (readme != null) r'readme': readme,
        if (closed != null) r'closed': closed,
        if (public != null) r'public': public,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateProjectV2Input._(this._$data);

  factory Input$UpdateProjectV2Input.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('readme')) {
      final l$readme = data['readme'];
      result$data['readme'] = (l$readme as String?);
    }
    if (data.containsKey('closed')) {
      final l$closed = data['closed'];
      result$data['closed'] = (l$closed as bool?);
    }
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateProjectV2Input._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String? get title => (_$data['title'] as String?);
  String? get shortDescription => (_$data['shortDescription'] as String?);
  String? get readme => (_$data['readme'] as String?);
  bool? get closed => (_$data['closed'] as bool?);
  bool? get public => (_$data['public'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('readme')) {
      final l$readme = readme;
      result$data['readme'] = l$readme;
    }
    if (_$data.containsKey('closed')) {
      final l$closed = closed;
      result$data['closed'] = l$closed;
    }
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2Input<Input$UpdateProjectV2Input>
      get copyWith => CopyWith$Input$UpdateProjectV2Input(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectV2Input) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$readme = readme;
    final lOther$readme = other.readme;
    if (_$data.containsKey('readme') != other._$data.containsKey('readme')) {
      return false;
    }
    if (l$readme != lOther$readme) {
      return false;
    }
    final l$closed = closed;
    final lOther$closed = other.closed;
    if (_$data.containsKey('closed') != other._$data.containsKey('closed')) {
      return false;
    }
    if (l$closed != lOther$closed) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$title = title;
    final l$shortDescription = shortDescription;
    final l$readme = readme;
    final l$closed = closed;
    final l$public = public;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('readme') ? l$readme : const {},
      _$data.containsKey('closed') ? l$closed : const {},
      _$data.containsKey('public') ? l$public : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2Input<TRes> {
  factory CopyWith$Input$UpdateProjectV2Input(
    Input$UpdateProjectV2Input instance,
    TRes Function(Input$UpdateProjectV2Input) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2Input;

  factory CopyWith$Input$UpdateProjectV2Input.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2Input;

  TRes call({
    String? projectId,
    String? title,
    String? shortDescription,
    String? readme,
    bool? closed,
    bool? public,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateProjectV2Input<TRes>
    implements CopyWith$Input$UpdateProjectV2Input<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2Input(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2Input _instance;

  final TRes Function(Input$UpdateProjectV2Input) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? title = _undefined,
    Object? shortDescription = _undefined,
    Object? readme = _undefined,
    Object? closed = _undefined,
    Object? public = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateProjectV2Input._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (title != _undefined) 'title': (title as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (readme != _undefined) 'readme': (readme as String?),
        if (closed != _undefined) 'closed': (closed as bool?),
        if (public != _undefined) 'public': (public as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectV2Input<TRes>
    implements CopyWith$Input$UpdateProjectV2Input<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2Input(this._res);

  TRes _res;

  call({
    String? projectId,
    String? title,
    String? shortDescription,
    String? readme,
    bool? closed,
    bool? public,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateProjectV2ItemFieldValueInput {
  factory Input$UpdateProjectV2ItemFieldValueInput({
    required String projectId,
    required String itemId,
    required String fieldId,
    required Input$ProjectV2FieldValue value,
    String? clientMutationId,
  }) =>
      Input$UpdateProjectV2ItemFieldValueInput._({
        r'projectId': projectId,
        r'itemId': itemId,
        r'fieldId': fieldId,
        r'value': value,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateProjectV2ItemFieldValueInput._(this._$data);

  factory Input$UpdateProjectV2ItemFieldValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$fieldId = data['fieldId'];
    result$data['fieldId'] = (l$fieldId as String);
    final l$value = data['value'];
    result$data['value'] =
        Input$ProjectV2FieldValue.fromJson((l$value as Map<String, dynamic>));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateProjectV2ItemFieldValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get itemId => (_$data['itemId'] as String);
  String get fieldId => (_$data['fieldId'] as String);
  Input$ProjectV2FieldValue get value =>
      (_$data['value'] as Input$ProjectV2FieldValue);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$fieldId = fieldId;
    result$data['fieldId'] = l$fieldId;
    final l$value = value;
    result$data['value'] = l$value.toJson();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2ItemFieldValueInput<
          Input$UpdateProjectV2ItemFieldValueInput>
      get copyWith => CopyWith$Input$UpdateProjectV2ItemFieldValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectV2ItemFieldValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$fieldId = fieldId;
    final lOther$fieldId = other.fieldId;
    if (l$fieldId != lOther$fieldId) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$itemId = itemId;
    final l$fieldId = fieldId;
    final l$value = value;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$itemId,
      l$fieldId,
      l$value,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2ItemFieldValueInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2ItemFieldValueInput(
    Input$UpdateProjectV2ItemFieldValueInput instance,
    TRes Function(Input$UpdateProjectV2ItemFieldValueInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2ItemFieldValueInput;

  factory CopyWith$Input$UpdateProjectV2ItemFieldValueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2ItemFieldValueInput;

  TRes call({
    String? projectId,
    String? itemId,
    String? fieldId,
    Input$ProjectV2FieldValue? value,
    String? clientMutationId,
  });
  CopyWith$Input$ProjectV2FieldValue<TRes> get value;
}

class _CopyWithImpl$Input$UpdateProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemFieldValueInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2ItemFieldValueInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2ItemFieldValueInput _instance;

  final TRes Function(Input$UpdateProjectV2ItemFieldValueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? itemId = _undefined,
    Object? fieldId = _undefined,
    Object? value = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateProjectV2ItemFieldValueInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (fieldId != _undefined && fieldId != null)
          'fieldId': (fieldId as String),
        if (value != _undefined && value != null)
          'value': (value as Input$ProjectV2FieldValue),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
  CopyWith$Input$ProjectV2FieldValue<TRes> get value {
    final local$value = _instance.value;
    return CopyWith$Input$ProjectV2FieldValue(
        local$value, (e) => call(value: e));
  }
}

class _CopyWithStubImpl$Input$UpdateProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemFieldValueInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2ItemFieldValueInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? itemId,
    String? fieldId,
    Input$ProjectV2FieldValue? value,
    String? clientMutationId,
  }) =>
      _res;
  CopyWith$Input$ProjectV2FieldValue<TRes> get value =>
      CopyWith$Input$ProjectV2FieldValue.stub(_res);
}

class Input$UpdateProjectV2ItemPositionInput {
  factory Input$UpdateProjectV2ItemPositionInput({
    required String projectId,
    required String itemId,
    String? afterId,
    String? clientMutationId,
  }) =>
      Input$UpdateProjectV2ItemPositionInput._({
        r'projectId': projectId,
        r'itemId': itemId,
        if (afterId != null) r'afterId': afterId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateProjectV2ItemPositionInput._(this._$data);

  factory Input$UpdateProjectV2ItemPositionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    if (data.containsKey('afterId')) {
      final l$afterId = data['afterId'];
      result$data['afterId'] = (l$afterId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateProjectV2ItemPositionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get projectId => (_$data['projectId'] as String);
  String get itemId => (_$data['itemId'] as String);
  String? get afterId => (_$data['afterId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    if (_$data.containsKey('afterId')) {
      final l$afterId = afterId;
      result$data['afterId'] = l$afterId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2ItemPositionInput<
          Input$UpdateProjectV2ItemPositionInput>
      get copyWith => CopyWith$Input$UpdateProjectV2ItemPositionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectV2ItemPositionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$afterId = afterId;
    final lOther$afterId = other.afterId;
    if (_$data.containsKey('afterId') != other._$data.containsKey('afterId')) {
      return false;
    }
    if (l$afterId != lOther$afterId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$projectId = projectId;
    final l$itemId = itemId;
    final l$afterId = afterId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$projectId,
      l$itemId,
      _$data.containsKey('afterId') ? l$afterId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2ItemPositionInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2ItemPositionInput(
    Input$UpdateProjectV2ItemPositionInput instance,
    TRes Function(Input$UpdateProjectV2ItemPositionInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2ItemPositionInput;

  factory CopyWith$Input$UpdateProjectV2ItemPositionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2ItemPositionInput;

  TRes call({
    String? projectId,
    String? itemId,
    String? afterId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateProjectV2ItemPositionInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemPositionInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2ItemPositionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2ItemPositionInput _instance;

  final TRes Function(Input$UpdateProjectV2ItemPositionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? projectId = _undefined,
    Object? itemId = _undefined,
    Object? afterId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateProjectV2ItemPositionInput._({
        ..._instance._$data,
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (afterId != _undefined) 'afterId': (afterId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectV2ItemPositionInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemPositionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2ItemPositionInput(this._res);

  TRes _res;

  call({
    String? projectId,
    String? itemId,
    String? afterId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdatePullRequestBranchInput {
  factory Input$UpdatePullRequestBranchInput({
    required String pullRequestId,
    String? expectedHeadOid,
    String? clientMutationId,
  }) =>
      Input$UpdatePullRequestBranchInput._({
        r'pullRequestId': pullRequestId,
        if (expectedHeadOid != null) r'expectedHeadOid': expectedHeadOid,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdatePullRequestBranchInput._(this._$data);

  factory Input$UpdatePullRequestBranchInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = data['expectedHeadOid'];
      result$data['expectedHeadOid'] = (l$expectedHeadOid as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdatePullRequestBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String? get expectedHeadOid => (_$data['expectedHeadOid'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = expectedHeadOid;
      result$data['expectedHeadOid'] = l$expectedHeadOid;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestBranchInput<
          Input$UpdatePullRequestBranchInput>
      get copyWith => CopyWith$Input$UpdatePullRequestBranchInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdatePullRequestBranchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (_$data.containsKey('expectedHeadOid') !=
        other._$data.containsKey('expectedHeadOid')) {
      return false;
    }
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$expectedHeadOid = expectedHeadOid;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      _$data.containsKey('expectedHeadOid') ? l$expectedHeadOid : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestBranchInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestBranchInput(
    Input$UpdatePullRequestBranchInput instance,
    TRes Function(Input$UpdatePullRequestBranchInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestBranchInput;

  factory CopyWith$Input$UpdatePullRequestBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestBranchInput;

  TRes call({
    String? pullRequestId,
    String? expectedHeadOid,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestBranchInput<TRes>
    implements CopyWith$Input$UpdatePullRequestBranchInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestBranchInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestBranchInput _instance;

  final TRes Function(Input$UpdatePullRequestBranchInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? expectedHeadOid = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdatePullRequestBranchInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (expectedHeadOid != _undefined)
          'expectedHeadOid': (expectedHeadOid as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestBranchInput<TRes>
    implements CopyWith$Input$UpdatePullRequestBranchInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestBranchInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? expectedHeadOid,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdatePullRequestInput {
  factory Input$UpdatePullRequestInput({
    required String pullRequestId,
    String? baseRefName,
    String? title,
    String? body,
    Enum$PullRequestUpdateState? state,
    bool? maintainerCanModify,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
    String? clientMutationId,
  }) =>
      Input$UpdatePullRequestInput._({
        r'pullRequestId': pullRequestId,
        if (baseRefName != null) r'baseRefName': baseRefName,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (state != null) r'state': state,
        if (maintainerCanModify != null)
          r'maintainerCanModify': maintainerCanModify,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (labelIds != null) r'labelIds': labelIds,
        if (projectIds != null) r'projectIds': projectIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdatePullRequestInput._(this._$data);

  factory Input$UpdatePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('baseRefName')) {
      final l$baseRefName = data['baseRefName'];
      result$data['baseRefName'] = (l$baseRefName as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$PullRequestUpdateState((l$state as String));
    }
    if (data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = data['maintainerCanModify'];
      result$data['maintainerCanModify'] = (l$maintainerCanModify as bool?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('projectIds')) {
      final l$projectIds = data['projectIds'];
      result$data['projectIds'] =
          (l$projectIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdatePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestId => (_$data['pullRequestId'] as String);
  String? get baseRefName => (_$data['baseRefName'] as String?);
  String? get title => (_$data['title'] as String?);
  String? get body => (_$data['body'] as String?);
  Enum$PullRequestUpdateState? get state =>
      (_$data['state'] as Enum$PullRequestUpdateState?);
  bool? get maintainerCanModify => (_$data['maintainerCanModify'] as bool?);
  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  List<String>? get projectIds => (_$data['projectIds'] as List<String>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('baseRefName')) {
      final l$baseRefName = baseRefName;
      result$data['baseRefName'] = l$baseRefName;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$PullRequestUpdateState(l$state);
    }
    if (_$data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = maintainerCanModify;
      result$data['maintainerCanModify'] = l$maintainerCanModify;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('projectIds')) {
      final l$projectIds = projectIds;
      result$data['projectIds'] = l$projectIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestInput<Input$UpdatePullRequestInput>
      get copyWith => CopyWith$Input$UpdatePullRequestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdatePullRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$baseRefName = baseRefName;
    final lOther$baseRefName = other.baseRefName;
    if (_$data.containsKey('baseRefName') !=
        other._$data.containsKey('baseRefName')) {
      return false;
    }
    if (l$baseRefName != lOther$baseRefName) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$maintainerCanModify = maintainerCanModify;
    final lOther$maintainerCanModify = other.maintainerCanModify;
    if (_$data.containsKey('maintainerCanModify') !=
        other._$data.containsKey('maintainerCanModify')) {
      return false;
    }
    if (l$maintainerCanModify != lOther$maintainerCanModify) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$projectIds = projectIds;
    final lOther$projectIds = other.projectIds;
    if (_$data.containsKey('projectIds') !=
        other._$data.containsKey('projectIds')) {
      return false;
    }
    if (l$projectIds != null && lOther$projectIds != null) {
      if (l$projectIds.length != lOther$projectIds.length) {
        return false;
      }
      for (int i = 0; i < l$projectIds.length; i++) {
        final l$projectIds$entry = l$projectIds[i];
        final lOther$projectIds$entry = lOther$projectIds[i];
        if (l$projectIds$entry != lOther$projectIds$entry) {
          return false;
        }
      }
    } else if (l$projectIds != lOther$projectIds) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestId = pullRequestId;
    final l$baseRefName = baseRefName;
    final l$title = title;
    final l$body = body;
    final l$state = state;
    final l$maintainerCanModify = maintainerCanModify;
    final l$assigneeIds = assigneeIds;
    final l$milestoneId = milestoneId;
    final l$labelIds = labelIds;
    final l$projectIds = projectIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestId,
      _$data.containsKey('baseRefName') ? l$baseRefName : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('maintainerCanModify')
          ? l$maintainerCanModify
          : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('projectIds')
          ? l$projectIds == null
              ? null
              : Object.hashAll(l$projectIds.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestInput(
    Input$UpdatePullRequestInput instance,
    TRes Function(Input$UpdatePullRequestInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestInput;

  factory CopyWith$Input$UpdatePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestInput;

  TRes call({
    String? pullRequestId,
    String? baseRefName,
    String? title,
    String? body,
    Enum$PullRequestUpdateState? state,
    bool? maintainerCanModify,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestInput<TRes>
    implements CopyWith$Input$UpdatePullRequestInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestInput _instance;

  final TRes Function(Input$UpdatePullRequestInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestId = _undefined,
    Object? baseRefName = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? state = _undefined,
    Object? maintainerCanModify = _undefined,
    Object? assigneeIds = _undefined,
    Object? milestoneId = _undefined,
    Object? labelIds = _undefined,
    Object? projectIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdatePullRequestInput._({
        ..._instance._$data,
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (baseRefName != _undefined) 'baseRefName': (baseRefName as String?),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (state != _undefined)
          'state': (state as Enum$PullRequestUpdateState?),
        if (maintainerCanModify != _undefined)
          'maintainerCanModify': (maintainerCanModify as bool?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (projectIds != _undefined)
          'projectIds': (projectIds as List<String>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestInput<TRes>
    implements CopyWith$Input$UpdatePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestInput(this._res);

  TRes _res;

  call({
    String? pullRequestId,
    String? baseRefName,
    String? title,
    String? body,
    Enum$PullRequestUpdateState? state,
    bool? maintainerCanModify,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdatePullRequestReviewCommentInput {
  factory Input$UpdatePullRequestReviewCommentInput({
    required String pullRequestReviewCommentId,
    required String body,
    String? clientMutationId,
  }) =>
      Input$UpdatePullRequestReviewCommentInput._({
        r'pullRequestReviewCommentId': pullRequestReviewCommentId,
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdatePullRequestReviewCommentInput._(this._$data);

  factory Input$UpdatePullRequestReviewCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestReviewCommentId = data['pullRequestReviewCommentId'];
    result$data['pullRequestReviewCommentId'] =
        (l$pullRequestReviewCommentId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdatePullRequestReviewCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestReviewCommentId =>
      (_$data['pullRequestReviewCommentId'] as String);
  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestReviewCommentId = pullRequestReviewCommentId;
    result$data['pullRequestReviewCommentId'] = l$pullRequestReviewCommentId;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestReviewCommentInput<
          Input$UpdatePullRequestReviewCommentInput>
      get copyWith => CopyWith$Input$UpdatePullRequestReviewCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdatePullRequestReviewCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestReviewCommentId = pullRequestReviewCommentId;
    final lOther$pullRequestReviewCommentId = other.pullRequestReviewCommentId;
    if (l$pullRequestReviewCommentId != lOther$pullRequestReviewCommentId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestReviewCommentId = pullRequestReviewCommentId;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestReviewCommentId,
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestReviewCommentInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestReviewCommentInput(
    Input$UpdatePullRequestReviewCommentInput instance,
    TRes Function(Input$UpdatePullRequestReviewCommentInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestReviewCommentInput;

  factory CopyWith$Input$UpdatePullRequestReviewCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestReviewCommentInput;

  TRes call({
    String? pullRequestReviewCommentId,
    String? body,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewCommentInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestReviewCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestReviewCommentInput _instance;

  final TRes Function(Input$UpdatePullRequestReviewCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestReviewCommentId = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdatePullRequestReviewCommentInput._({
        ..._instance._$data,
        if (pullRequestReviewCommentId != _undefined &&
            pullRequestReviewCommentId != null)
          'pullRequestReviewCommentId': (pullRequestReviewCommentId as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestReviewCommentInput(this._res);

  TRes _res;

  call({
    String? pullRequestReviewCommentId,
    String? body,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdatePullRequestReviewInput {
  factory Input$UpdatePullRequestReviewInput({
    required String pullRequestReviewId,
    required String body,
    String? clientMutationId,
  }) =>
      Input$UpdatePullRequestReviewInput._({
        r'pullRequestReviewId': pullRequestReviewId,
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdatePullRequestReviewInput._(this._$data);

  factory Input$UpdatePullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$pullRequestReviewId = data['pullRequestReviewId'];
    result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdatePullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get pullRequestReviewId => (_$data['pullRequestReviewId'] as String);
  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$pullRequestReviewId = pullRequestReviewId;
    result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestReviewInput<
          Input$UpdatePullRequestReviewInput>
      get copyWith => CopyWith$Input$UpdatePullRequestReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdatePullRequestReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$pullRequestReviewId,
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestReviewInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestReviewInput(
    Input$UpdatePullRequestReviewInput instance,
    TRes Function(Input$UpdatePullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestReviewInput;

  factory CopyWith$Input$UpdatePullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestReviewInput;

  TRes call({
    String? pullRequestReviewId,
    String? body,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestReviewInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestReviewInput _instance;

  final TRes Function(Input$UpdatePullRequestReviewInput) _then;

  static const _undefined = {};

  TRes call({
    Object? pullRequestReviewId = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdatePullRequestReviewInput._({
        ..._instance._$data,
        if (pullRequestReviewId != _undefined && pullRequestReviewId != null)
          'pullRequestReviewId': (pullRequestReviewId as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestReviewInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? pullRequestReviewId,
    String? body,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateRefInput {
  factory Input$UpdateRefInput({
    required String refId,
    required String oid,
    bool? force,
    String? clientMutationId,
  }) =>
      Input$UpdateRefInput._({
        r'refId': refId,
        r'oid': oid,
        if (force != null) r'force': force,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateRefInput._(this._$data);

  factory Input$UpdateRefInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$refId = data['refId'];
    result$data['refId'] = (l$refId as String);
    final l$oid = data['oid'];
    result$data['oid'] = (l$oid as String);
    if (data.containsKey('force')) {
      final l$force = data['force'];
      result$data['force'] = (l$force as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateRefInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get refId => (_$data['refId'] as String);
  String get oid => (_$data['oid'] as String);
  bool? get force => (_$data['force'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$refId = refId;
    result$data['refId'] = l$refId;
    final l$oid = oid;
    result$data['oid'] = l$oid;
    if (_$data.containsKey('force')) {
      final l$force = force;
      result$data['force'] = l$force;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateRefInput<Input$UpdateRefInput> get copyWith =>
      CopyWith$Input$UpdateRefInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateRefInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$oid = oid;
    final lOther$oid = other.oid;
    if (l$oid != lOther$oid) {
      return false;
    }
    final l$force = force;
    final lOther$force = other.force;
    if (_$data.containsKey('force') != other._$data.containsKey('force')) {
      return false;
    }
    if (l$force != lOther$force) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$refId = refId;
    final l$oid = oid;
    final l$force = force;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$refId,
      l$oid,
      _$data.containsKey('force') ? l$force : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateRefInput<TRes> {
  factory CopyWith$Input$UpdateRefInput(
    Input$UpdateRefInput instance,
    TRes Function(Input$UpdateRefInput) then,
  ) = _CopyWithImpl$Input$UpdateRefInput;

  factory CopyWith$Input$UpdateRefInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRefInput;

  TRes call({
    String? refId,
    String? oid,
    bool? force,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateRefInput<TRes>
    implements CopyWith$Input$UpdateRefInput<TRes> {
  _CopyWithImpl$Input$UpdateRefInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRefInput _instance;

  final TRes Function(Input$UpdateRefInput) _then;

  static const _undefined = {};

  TRes call({
    Object? refId = _undefined,
    Object? oid = _undefined,
    Object? force = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateRefInput._({
        ..._instance._$data,
        if (refId != _undefined && refId != null) 'refId': (refId as String),
        if (oid != _undefined && oid != null) 'oid': (oid as String),
        if (force != _undefined) 'force': (force as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateRefInput<TRes>
    implements CopyWith$Input$UpdateRefInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRefInput(this._res);

  TRes _res;

  call({
    String? refId,
    String? oid,
    bool? force,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateRepositoryInput {
  factory Input$UpdateRepositoryInput({
    required String repositoryId,
    String? name,
    String? description,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    bool? hasProjectsEnabled,
    bool? hasDiscussionsEnabled,
    String? clientMutationId,
  }) =>
      Input$UpdateRepositoryInput._({
        r'repositoryId': repositoryId,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (template != null) r'template': template,
        if (homepageUrl != null) r'homepageUrl': homepageUrl,
        if (hasWikiEnabled != null) r'hasWikiEnabled': hasWikiEnabled,
        if (hasIssuesEnabled != null) r'hasIssuesEnabled': hasIssuesEnabled,
        if (hasProjectsEnabled != null)
          r'hasProjectsEnabled': hasProjectsEnabled,
        if (hasDiscussionsEnabled != null)
          r'hasDiscussionsEnabled': hasDiscussionsEnabled,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateRepositoryInput._(this._$data);

  factory Input$UpdateRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = (l$template as bool?);
    }
    if (data.containsKey('homepageUrl')) {
      final l$homepageUrl = data['homepageUrl'];
      result$data['homepageUrl'] = (l$homepageUrl as String?);
    }
    if (data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = data['hasWikiEnabled'];
      result$data['hasWikiEnabled'] = (l$hasWikiEnabled as bool?);
    }
    if (data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = data['hasIssuesEnabled'];
      result$data['hasIssuesEnabled'] = (l$hasIssuesEnabled as bool?);
    }
    if (data.containsKey('hasProjectsEnabled')) {
      final l$hasProjectsEnabled = data['hasProjectsEnabled'];
      result$data['hasProjectsEnabled'] = (l$hasProjectsEnabled as bool?);
    }
    if (data.containsKey('hasDiscussionsEnabled')) {
      final l$hasDiscussionsEnabled = data['hasDiscussionsEnabled'];
      result$data['hasDiscussionsEnabled'] = (l$hasDiscussionsEnabled as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  String? get name => (_$data['name'] as String?);
  String? get description => (_$data['description'] as String?);
  bool? get template => (_$data['template'] as bool?);
  String? get homepageUrl => (_$data['homepageUrl'] as String?);
  bool? get hasWikiEnabled => (_$data['hasWikiEnabled'] as bool?);
  bool? get hasIssuesEnabled => (_$data['hasIssuesEnabled'] as bool?);
  bool? get hasProjectsEnabled => (_$data['hasProjectsEnabled'] as bool?);
  bool? get hasDiscussionsEnabled => (_$data['hasDiscussionsEnabled'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] = l$template;
    }
    if (_$data.containsKey('homepageUrl')) {
      final l$homepageUrl = homepageUrl;
      result$data['homepageUrl'] = l$homepageUrl;
    }
    if (_$data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = hasWikiEnabled;
      result$data['hasWikiEnabled'] = l$hasWikiEnabled;
    }
    if (_$data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = hasIssuesEnabled;
      result$data['hasIssuesEnabled'] = l$hasIssuesEnabled;
    }
    if (_$data.containsKey('hasProjectsEnabled')) {
      final l$hasProjectsEnabled = hasProjectsEnabled;
      result$data['hasProjectsEnabled'] = l$hasProjectsEnabled;
    }
    if (_$data.containsKey('hasDiscussionsEnabled')) {
      final l$hasDiscussionsEnabled = hasDiscussionsEnabled;
      result$data['hasDiscussionsEnabled'] = l$hasDiscussionsEnabled;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateRepositoryInput<Input$UpdateRepositoryInput>
      get copyWith => CopyWith$Input$UpdateRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    final l$homepageUrl = homepageUrl;
    final lOther$homepageUrl = other.homepageUrl;
    if (_$data.containsKey('homepageUrl') !=
        other._$data.containsKey('homepageUrl')) {
      return false;
    }
    if (l$homepageUrl != lOther$homepageUrl) {
      return false;
    }
    final l$hasWikiEnabled = hasWikiEnabled;
    final lOther$hasWikiEnabled = other.hasWikiEnabled;
    if (_$data.containsKey('hasWikiEnabled') !=
        other._$data.containsKey('hasWikiEnabled')) {
      return false;
    }
    if (l$hasWikiEnabled != lOther$hasWikiEnabled) {
      return false;
    }
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final lOther$hasIssuesEnabled = other.hasIssuesEnabled;
    if (_$data.containsKey('hasIssuesEnabled') !=
        other._$data.containsKey('hasIssuesEnabled')) {
      return false;
    }
    if (l$hasIssuesEnabled != lOther$hasIssuesEnabled) {
      return false;
    }
    final l$hasProjectsEnabled = hasProjectsEnabled;
    final lOther$hasProjectsEnabled = other.hasProjectsEnabled;
    if (_$data.containsKey('hasProjectsEnabled') !=
        other._$data.containsKey('hasProjectsEnabled')) {
      return false;
    }
    if (l$hasProjectsEnabled != lOther$hasProjectsEnabled) {
      return false;
    }
    final l$hasDiscussionsEnabled = hasDiscussionsEnabled;
    final lOther$hasDiscussionsEnabled = other.hasDiscussionsEnabled;
    if (_$data.containsKey('hasDiscussionsEnabled') !=
        other._$data.containsKey('hasDiscussionsEnabled')) {
      return false;
    }
    if (l$hasDiscussionsEnabled != lOther$hasDiscussionsEnabled) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$description = description;
    final l$template = template;
    final l$homepageUrl = homepageUrl;
    final l$hasWikiEnabled = hasWikiEnabled;
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final l$hasProjectsEnabled = hasProjectsEnabled;
    final l$hasDiscussionsEnabled = hasDiscussionsEnabled;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('template') ? l$template : const {},
      _$data.containsKey('homepageUrl') ? l$homepageUrl : const {},
      _$data.containsKey('hasWikiEnabled') ? l$hasWikiEnabled : const {},
      _$data.containsKey('hasIssuesEnabled') ? l$hasIssuesEnabled : const {},
      _$data.containsKey('hasProjectsEnabled')
          ? l$hasProjectsEnabled
          : const {},
      _$data.containsKey('hasDiscussionsEnabled')
          ? l$hasDiscussionsEnabled
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateRepositoryInput<TRes> {
  factory CopyWith$Input$UpdateRepositoryInput(
    Input$UpdateRepositoryInput instance,
    TRes Function(Input$UpdateRepositoryInput) then,
  ) = _CopyWithImpl$Input$UpdateRepositoryInput;

  factory CopyWith$Input$UpdateRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRepositoryInput;

  TRes call({
    String? repositoryId,
    String? name,
    String? description,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    bool? hasProjectsEnabled,
    bool? hasDiscussionsEnabled,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateRepositoryInput<TRes>
    implements CopyWith$Input$UpdateRepositoryInput<TRes> {
  _CopyWithImpl$Input$UpdateRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRepositoryInput _instance;

  final TRes Function(Input$UpdateRepositoryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? template = _undefined,
    Object? homepageUrl = _undefined,
    Object? hasWikiEnabled = _undefined,
    Object? hasIssuesEnabled = _undefined,
    Object? hasProjectsEnabled = _undefined,
    Object? hasDiscussionsEnabled = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateRepositoryInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (template != _undefined) 'template': (template as bool?),
        if (homepageUrl != _undefined) 'homepageUrl': (homepageUrl as String?),
        if (hasWikiEnabled != _undefined)
          'hasWikiEnabled': (hasWikiEnabled as bool?),
        if (hasIssuesEnabled != _undefined)
          'hasIssuesEnabled': (hasIssuesEnabled as bool?),
        if (hasProjectsEnabled != _undefined)
          'hasProjectsEnabled': (hasProjectsEnabled as bool?),
        if (hasDiscussionsEnabled != _undefined)
          'hasDiscussionsEnabled': (hasDiscussionsEnabled as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateRepositoryInput<TRes>
    implements CopyWith$Input$UpdateRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRepositoryInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    String? name,
    String? description,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    bool? hasProjectsEnabled,
    bool? hasDiscussionsEnabled,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateRepositoryWebCommitSignoffSettingInput {
  factory Input$UpdateRepositoryWebCommitSignoffSettingInput({
    required String repositoryId,
    required bool webCommitSignoffRequired,
    String? clientMutationId,
  }) =>
      Input$UpdateRepositoryWebCommitSignoffSettingInput._({
        r'repositoryId': repositoryId,
        r'webCommitSignoffRequired': webCommitSignoffRequired,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateRepositoryWebCommitSignoffSettingInput._(this._$data);

  factory Input$UpdateRepositoryWebCommitSignoffSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$webCommitSignoffRequired = data['webCommitSignoffRequired'];
    result$data['webCommitSignoffRequired'] =
        (l$webCommitSignoffRequired as bool);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateRepositoryWebCommitSignoffSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  bool get webCommitSignoffRequired =>
      (_$data['webCommitSignoffRequired'] as bool);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    result$data['webCommitSignoffRequired'] = l$webCommitSignoffRequired;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<
          Input$UpdateRepositoryWebCommitSignoffSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateRepositoryWebCommitSignoffSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    final lOther$webCommitSignoffRequired = other.webCommitSignoffRequired;
    if (l$webCommitSignoffRequired != lOther$webCommitSignoffRequired) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      l$webCommitSignoffRequired,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput(
    Input$UpdateRepositoryWebCommitSignoffSettingInput instance,
    TRes Function(Input$UpdateRepositoryWebCommitSignoffSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput;

  factory CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput;

  TRes call({
    String? repositoryId,
    bool? webCommitSignoffRequired,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes>
    implements
        CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRepositoryWebCommitSignoffSettingInput _instance;

  final TRes Function(Input$UpdateRepositoryWebCommitSignoffSettingInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? webCommitSignoffRequired = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateRepositoryWebCommitSignoffSettingInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (webCommitSignoffRequired != _undefined &&
            webCommitSignoffRequired != null)
          'webCommitSignoffRequired': (webCommitSignoffRequired as bool),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes>
    implements
        CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput(
      this._res);

  TRes _res;

  call({
    String? repositoryId,
    bool? webCommitSignoffRequired,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateSponsorshipPreferencesInput {
  factory Input$UpdateSponsorshipPreferencesInput({
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
    String? clientMutationId,
  }) =>
      Input$UpdateSponsorshipPreferencesInput._({
        if (sponsorId != null) r'sponsorId': sponsorId,
        if (sponsorLogin != null) r'sponsorLogin': sponsorLogin,
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        if (receiveEmails != null) r'receiveEmails': receiveEmails,
        if (privacyLevel != null) r'privacyLevel': privacyLevel,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateSponsorshipPreferencesInput._(this._$data);

  factory Input$UpdateSponsorshipPreferencesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('sponsorId')) {
      final l$sponsorId = data['sponsorId'];
      result$data['sponsorId'] = (l$sponsorId as String?);
    }
    if (data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = data['sponsorLogin'];
      result$data['sponsorLogin'] = (l$sponsorLogin as String?);
    }
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    if (data.containsKey('receiveEmails')) {
      final l$receiveEmails = data['receiveEmails'];
      result$data['receiveEmails'] = (l$receiveEmails as bool?);
    }
    if (data.containsKey('privacyLevel')) {
      final l$privacyLevel = data['privacyLevel'];
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : fromJson$Enum$SponsorshipPrivacy((l$privacyLevel as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateSponsorshipPreferencesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get sponsorId => (_$data['sponsorId'] as String?);
  String? get sponsorLogin => (_$data['sponsorLogin'] as String?);
  String? get sponsorableId => (_$data['sponsorableId'] as String?);
  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);
  bool? get receiveEmails => (_$data['receiveEmails'] as bool?);
  Enum$SponsorshipPrivacy? get privacyLevel =>
      (_$data['privacyLevel'] as Enum$SponsorshipPrivacy?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('sponsorId')) {
      final l$sponsorId = sponsorId;
      result$data['sponsorId'] = l$sponsorId;
    }
    if (_$data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = sponsorLogin;
      result$data['sponsorLogin'] = l$sponsorLogin;
    }
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    if (_$data.containsKey('receiveEmails')) {
      final l$receiveEmails = receiveEmails;
      result$data['receiveEmails'] = l$receiveEmails;
    }
    if (_$data.containsKey('privacyLevel')) {
      final l$privacyLevel = privacyLevel;
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : toJson$Enum$SponsorshipPrivacy(l$privacyLevel);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateSponsorshipPreferencesInput<
          Input$UpdateSponsorshipPreferencesInput>
      get copyWith => CopyWith$Input$UpdateSponsorshipPreferencesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateSponsorshipPreferencesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$sponsorId = sponsorId;
    final lOther$sponsorId = other.sponsorId;
    if (_$data.containsKey('sponsorId') !=
        other._$data.containsKey('sponsorId')) {
      return false;
    }
    if (l$sponsorId != lOther$sponsorId) {
      return false;
    }
    final l$sponsorLogin = sponsorLogin;
    final lOther$sponsorLogin = other.sponsorLogin;
    if (_$data.containsKey('sponsorLogin') !=
        other._$data.containsKey('sponsorLogin')) {
      return false;
    }
    if (l$sponsorLogin != lOther$sponsorLogin) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$receiveEmails = receiveEmails;
    final lOther$receiveEmails = other.receiveEmails;
    if (_$data.containsKey('receiveEmails') !=
        other._$data.containsKey('receiveEmails')) {
      return false;
    }
    if (l$receiveEmails != lOther$receiveEmails) {
      return false;
    }
    final l$privacyLevel = privacyLevel;
    final lOther$privacyLevel = other.privacyLevel;
    if (_$data.containsKey('privacyLevel') !=
        other._$data.containsKey('privacyLevel')) {
      return false;
    }
    if (l$privacyLevel != lOther$privacyLevel) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sponsorId = sponsorId;
    final l$sponsorLogin = sponsorLogin;
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$receiveEmails = receiveEmails;
    final l$privacyLevel = privacyLevel;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      _$data.containsKey('sponsorId') ? l$sponsorId : const {},
      _$data.containsKey('sponsorLogin') ? l$sponsorLogin : const {},
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      _$data.containsKey('receiveEmails') ? l$receiveEmails : const {},
      _$data.containsKey('privacyLevel') ? l$privacyLevel : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateSponsorshipPreferencesInput<TRes> {
  factory CopyWith$Input$UpdateSponsorshipPreferencesInput(
    Input$UpdateSponsorshipPreferencesInput instance,
    TRes Function(Input$UpdateSponsorshipPreferencesInput) then,
  ) = _CopyWithImpl$Input$UpdateSponsorshipPreferencesInput;

  factory CopyWith$Input$UpdateSponsorshipPreferencesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateSponsorshipPreferencesInput;

  TRes call({
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateSponsorshipPreferencesInput<TRes>
    implements CopyWith$Input$UpdateSponsorshipPreferencesInput<TRes> {
  _CopyWithImpl$Input$UpdateSponsorshipPreferencesInput(
    this._instance,
    this._then,
  );

  final Input$UpdateSponsorshipPreferencesInput _instance;

  final TRes Function(Input$UpdateSponsorshipPreferencesInput) _then;

  static const _undefined = {};

  TRes call({
    Object? sponsorId = _undefined,
    Object? sponsorLogin = _undefined,
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? receiveEmails = _undefined,
    Object? privacyLevel = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateSponsorshipPreferencesInput._({
        ..._instance._$data,
        if (sponsorId != _undefined) 'sponsorId': (sponsorId as String?),
        if (sponsorLogin != _undefined)
          'sponsorLogin': (sponsorLogin as String?),
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (receiveEmails != _undefined)
          'receiveEmails': (receiveEmails as bool?),
        if (privacyLevel != _undefined)
          'privacyLevel': (privacyLevel as Enum$SponsorshipPrivacy?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateSponsorshipPreferencesInput<TRes>
    implements CopyWith$Input$UpdateSponsorshipPreferencesInput<TRes> {
  _CopyWithStubImpl$Input$UpdateSponsorshipPreferencesInput(this._res);

  TRes _res;

  call({
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateSubscriptionInput {
  factory Input$UpdateSubscriptionInput({
    required String subscribableId,
    required Enum$SubscriptionState state,
    String? clientMutationId,
  }) =>
      Input$UpdateSubscriptionInput._({
        r'subscribableId': subscribableId,
        r'state': state,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateSubscriptionInput._(this._$data);

  factory Input$UpdateSubscriptionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$subscribableId = data['subscribableId'];
    result$data['subscribableId'] = (l$subscribableId as String);
    final l$state = data['state'];
    result$data['state'] = fromJson$Enum$SubscriptionState((l$state as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateSubscriptionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get subscribableId => (_$data['subscribableId'] as String);
  Enum$SubscriptionState get state =>
      (_$data['state'] as Enum$SubscriptionState);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$subscribableId = subscribableId;
    result$data['subscribableId'] = l$subscribableId;
    final l$state = state;
    result$data['state'] = toJson$Enum$SubscriptionState(l$state);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateSubscriptionInput<Input$UpdateSubscriptionInput>
      get copyWith => CopyWith$Input$UpdateSubscriptionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateSubscriptionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$subscribableId = subscribableId;
    final lOther$subscribableId = other.subscribableId;
    if (l$subscribableId != lOther$subscribableId) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (l$state != lOther$state) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$subscribableId = subscribableId;
    final l$state = state;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$subscribableId,
      l$state,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateSubscriptionInput<TRes> {
  factory CopyWith$Input$UpdateSubscriptionInput(
    Input$UpdateSubscriptionInput instance,
    TRes Function(Input$UpdateSubscriptionInput) then,
  ) = _CopyWithImpl$Input$UpdateSubscriptionInput;

  factory CopyWith$Input$UpdateSubscriptionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateSubscriptionInput;

  TRes call({
    String? subscribableId,
    Enum$SubscriptionState? state,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateSubscriptionInput<TRes>
    implements CopyWith$Input$UpdateSubscriptionInput<TRes> {
  _CopyWithImpl$Input$UpdateSubscriptionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateSubscriptionInput _instance;

  final TRes Function(Input$UpdateSubscriptionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? subscribableId = _undefined,
    Object? state = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateSubscriptionInput._({
        ..._instance._$data,
        if (subscribableId != _undefined && subscribableId != null)
          'subscribableId': (subscribableId as String),
        if (state != _undefined && state != null)
          'state': (state as Enum$SubscriptionState),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateSubscriptionInput<TRes>
    implements CopyWith$Input$UpdateSubscriptionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateSubscriptionInput(this._res);

  TRes _res;

  call({
    String? subscribableId,
    Enum$SubscriptionState? state,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateTeamDiscussionCommentInput {
  factory Input$UpdateTeamDiscussionCommentInput({
    required String id,
    required String body,
    String? bodyVersion,
    String? clientMutationId,
  }) =>
      Input$UpdateTeamDiscussionCommentInput._({
        r'id': id,
        r'body': body,
        if (bodyVersion != null) r'bodyVersion': bodyVersion,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateTeamDiscussionCommentInput._(this._$data);

  factory Input$UpdateTeamDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('bodyVersion')) {
      final l$bodyVersion = data['bodyVersion'];
      result$data['bodyVersion'] = (l$bodyVersion as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateTeamDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String get body => (_$data['body'] as String);
  String? get bodyVersion => (_$data['bodyVersion'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('bodyVersion')) {
      final l$bodyVersion = bodyVersion;
      result$data['bodyVersion'] = l$bodyVersion;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateTeamDiscussionCommentInput<
          Input$UpdateTeamDiscussionCommentInput>
      get copyWith => CopyWith$Input$UpdateTeamDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateTeamDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$bodyVersion = bodyVersion;
    final lOther$bodyVersion = other.bodyVersion;
    if (_$data.containsKey('bodyVersion') !=
        other._$data.containsKey('bodyVersion')) {
      return false;
    }
    if (l$bodyVersion != lOther$bodyVersion) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$body = body;
    final l$bodyVersion = bodyVersion;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      l$body,
      _$data.containsKey('bodyVersion') ? l$bodyVersion : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateTeamDiscussionCommentInput<TRes> {
  factory CopyWith$Input$UpdateTeamDiscussionCommentInput(
    Input$UpdateTeamDiscussionCommentInput instance,
    TRes Function(Input$UpdateTeamDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$UpdateTeamDiscussionCommentInput;

  factory CopyWith$Input$UpdateTeamDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTeamDiscussionCommentInput;

  TRes call({
    String? id,
    String? body,
    String? bodyVersion,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$UpdateTeamDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTeamDiscussionCommentInput _instance;

  final TRes Function(Input$UpdateTeamDiscussionCommentInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? body = _undefined,
    Object? bodyVersion = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateTeamDiscussionCommentInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (bodyVersion != _undefined) 'bodyVersion': (bodyVersion as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTeamDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? id,
    String? body,
    String? bodyVersion,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateTeamDiscussionInput {
  factory Input$UpdateTeamDiscussionInput({
    required String id,
    String? title,
    String? body,
    String? bodyVersion,
    bool? pinned,
    String? clientMutationId,
  }) =>
      Input$UpdateTeamDiscussionInput._({
        r'id': id,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (bodyVersion != null) r'bodyVersion': bodyVersion,
        if (pinned != null) r'pinned': pinned,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateTeamDiscussionInput._(this._$data);

  factory Input$UpdateTeamDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('bodyVersion')) {
      final l$bodyVersion = data['bodyVersion'];
      result$data['bodyVersion'] = (l$bodyVersion as String?);
    }
    if (data.containsKey('pinned')) {
      final l$pinned = data['pinned'];
      result$data['pinned'] = (l$pinned as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateTeamDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get title => (_$data['title'] as String?);
  String? get body => (_$data['body'] as String?);
  String? get bodyVersion => (_$data['bodyVersion'] as String?);
  bool? get pinned => (_$data['pinned'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('bodyVersion')) {
      final l$bodyVersion = bodyVersion;
      result$data['bodyVersion'] = l$bodyVersion;
    }
    if (_$data.containsKey('pinned')) {
      final l$pinned = pinned;
      result$data['pinned'] = l$pinned;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateTeamDiscussionInput<Input$UpdateTeamDiscussionInput>
      get copyWith => CopyWith$Input$UpdateTeamDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateTeamDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$bodyVersion = bodyVersion;
    final lOther$bodyVersion = other.bodyVersion;
    if (_$data.containsKey('bodyVersion') !=
        other._$data.containsKey('bodyVersion')) {
      return false;
    }
    if (l$bodyVersion != lOther$bodyVersion) {
      return false;
    }
    final l$pinned = pinned;
    final lOther$pinned = other.pinned;
    if (_$data.containsKey('pinned') != other._$data.containsKey('pinned')) {
      return false;
    }
    if (l$pinned != lOther$pinned) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$title = title;
    final l$body = body;
    final l$bodyVersion = bodyVersion;
    final l$pinned = pinned;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('bodyVersion') ? l$bodyVersion : const {},
      _$data.containsKey('pinned') ? l$pinned : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateTeamDiscussionInput<TRes> {
  factory CopyWith$Input$UpdateTeamDiscussionInput(
    Input$UpdateTeamDiscussionInput instance,
    TRes Function(Input$UpdateTeamDiscussionInput) then,
  ) = _CopyWithImpl$Input$UpdateTeamDiscussionInput;

  factory CopyWith$Input$UpdateTeamDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTeamDiscussionInput;

  TRes call({
    String? id,
    String? title,
    String? body,
    String? bodyVersion,
    bool? pinned,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateTeamDiscussionInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionInput<TRes> {
  _CopyWithImpl$Input$UpdateTeamDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTeamDiscussionInput _instance;

  final TRes Function(Input$UpdateTeamDiscussionInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? bodyVersion = _undefined,
    Object? pinned = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateTeamDiscussionInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (bodyVersion != _undefined) 'bodyVersion': (bodyVersion as String?),
        if (pinned != _undefined) 'pinned': (pinned as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateTeamDiscussionInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTeamDiscussionInput(this._res);

  TRes _res;

  call({
    String? id,
    String? title,
    String? body,
    String? bodyVersion,
    bool? pinned,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateTeamsRepositoryInput {
  factory Input$UpdateTeamsRepositoryInput({
    required String repositoryId,
    required List<String> teamIds,
    required Enum$RepositoryPermission permission,
    String? clientMutationId,
  }) =>
      Input$UpdateTeamsRepositoryInput._({
        r'repositoryId': repositoryId,
        r'teamIds': teamIds,
        r'permission': permission,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateTeamsRepositoryInput._(this._$data);

  factory Input$UpdateTeamsRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$teamIds = data['teamIds'];
    result$data['teamIds'] =
        (l$teamIds as List<dynamic>).map((e) => (e as String)).toList();
    final l$permission = data['permission'];
    result$data['permission'] =
        fromJson$Enum$RepositoryPermission((l$permission as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateTeamsRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  List<String> get teamIds => (_$data['teamIds'] as List<String>);
  Enum$RepositoryPermission get permission =>
      (_$data['permission'] as Enum$RepositoryPermission);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$teamIds = teamIds;
    result$data['teamIds'] = l$teamIds.map((e) => e).toList();
    final l$permission = permission;
    result$data['permission'] = toJson$Enum$RepositoryPermission(l$permission);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateTeamsRepositoryInput<Input$UpdateTeamsRepositoryInput>
      get copyWith => CopyWith$Input$UpdateTeamsRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateTeamsRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$teamIds = teamIds;
    final lOther$teamIds = other.teamIds;
    if (l$teamIds.length != lOther$teamIds.length) {
      return false;
    }
    for (int i = 0; i < l$teamIds.length; i++) {
      final l$teamIds$entry = l$teamIds[i];
      final lOther$teamIds$entry = lOther$teamIds[i];
      if (l$teamIds$entry != lOther$teamIds$entry) {
        return false;
      }
    }
    final l$permission = permission;
    final lOther$permission = other.permission;
    if (l$permission != lOther$permission) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$teamIds = teamIds;
    final l$permission = permission;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      Object.hashAll(l$teamIds.map((v) => v)),
      l$permission,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateTeamsRepositoryInput<TRes> {
  factory CopyWith$Input$UpdateTeamsRepositoryInput(
    Input$UpdateTeamsRepositoryInput instance,
    TRes Function(Input$UpdateTeamsRepositoryInput) then,
  ) = _CopyWithImpl$Input$UpdateTeamsRepositoryInput;

  factory CopyWith$Input$UpdateTeamsRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTeamsRepositoryInput;

  TRes call({
    String? repositoryId,
    List<String>? teamIds,
    Enum$RepositoryPermission? permission,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateTeamsRepositoryInput<TRes>
    implements CopyWith$Input$UpdateTeamsRepositoryInput<TRes> {
  _CopyWithImpl$Input$UpdateTeamsRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTeamsRepositoryInput _instance;

  final TRes Function(Input$UpdateTeamsRepositoryInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? teamIds = _undefined,
    Object? permission = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateTeamsRepositoryInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (teamIds != _undefined && teamIds != null)
          'teamIds': (teamIds as List<String>),
        if (permission != _undefined && permission != null)
          'permission': (permission as Enum$RepositoryPermission),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateTeamsRepositoryInput<TRes>
    implements CopyWith$Input$UpdateTeamsRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTeamsRepositoryInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    List<String>? teamIds,
    Enum$RepositoryPermission? permission,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UpdateTopicsInput {
  factory Input$UpdateTopicsInput({
    required String repositoryId,
    required List<String> topicNames,
    String? clientMutationId,
  }) =>
      Input$UpdateTopicsInput._({
        r'repositoryId': repositoryId,
        r'topicNames': topicNames,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$UpdateTopicsInput._(this._$data);

  factory Input$UpdateTopicsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$topicNames = data['topicNames'];
    result$data['topicNames'] =
        (l$topicNames as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$UpdateTopicsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repositoryId => (_$data['repositoryId'] as String);
  List<String> get topicNames => (_$data['topicNames'] as List<String>);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$topicNames = topicNames;
    result$data['topicNames'] = l$topicNames.map((e) => e).toList();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateTopicsInput<Input$UpdateTopicsInput> get copyWith =>
      CopyWith$Input$UpdateTopicsInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateTopicsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$topicNames = topicNames;
    final lOther$topicNames = other.topicNames;
    if (l$topicNames.length != lOther$topicNames.length) {
      return false;
    }
    for (int i = 0; i < l$topicNames.length; i++) {
      final l$topicNames$entry = l$topicNames[i];
      final lOther$topicNames$entry = lOther$topicNames[i];
      if (l$topicNames$entry != lOther$topicNames$entry) {
        return false;
      }
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryId = repositoryId;
    final l$topicNames = topicNames;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$repositoryId,
      Object.hashAll(l$topicNames.map((v) => v)),
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateTopicsInput<TRes> {
  factory CopyWith$Input$UpdateTopicsInput(
    Input$UpdateTopicsInput instance,
    TRes Function(Input$UpdateTopicsInput) then,
  ) = _CopyWithImpl$Input$UpdateTopicsInput;

  factory CopyWith$Input$UpdateTopicsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTopicsInput;

  TRes call({
    String? repositoryId,
    List<String>? topicNames,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$UpdateTopicsInput<TRes>
    implements CopyWith$Input$UpdateTopicsInput<TRes> {
  _CopyWithImpl$Input$UpdateTopicsInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTopicsInput _instance;

  final TRes Function(Input$UpdateTopicsInput) _then;

  static const _undefined = {};

  TRes call({
    Object? repositoryId = _undefined,
    Object? topicNames = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$UpdateTopicsInput._({
        ..._instance._$data,
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (topicNames != _undefined && topicNames != null)
          'topicNames': (topicNames as List<String>),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateTopicsInput<TRes>
    implements CopyWith$Input$UpdateTopicsInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTopicsInput(this._res);

  TRes _res;

  call({
    String? repositoryId,
    List<String>? topicNames,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$UserStatusOrder {
  factory Input$UserStatusOrder({
    required Enum$UserStatusOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$UserStatusOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$UserStatusOrder._(this._$data);

  factory Input$UserStatusOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$UserStatusOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$UserStatusOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserStatusOrderField get field =>
      (_$data['field'] as Enum$UserStatusOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$UserStatusOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$UserStatusOrder<Input$UserStatusOrder> get copyWith =>
      CopyWith$Input$UserStatusOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserStatusOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$UserStatusOrder<TRes> {
  factory CopyWith$Input$UserStatusOrder(
    Input$UserStatusOrder instance,
    TRes Function(Input$UserStatusOrder) then,
  ) = _CopyWithImpl$Input$UserStatusOrder;

  factory CopyWith$Input$UserStatusOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$UserStatusOrder;

  TRes call({
    Enum$UserStatusOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$UserStatusOrder<TRes>
    implements CopyWith$Input$UserStatusOrder<TRes> {
  _CopyWithImpl$Input$UserStatusOrder(
    this._instance,
    this._then,
  );

  final Input$UserStatusOrder _instance;

  final TRes Function(Input$UserStatusOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$UserStatusOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$UserStatusOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$UserStatusOrder<TRes>
    implements CopyWith$Input$UserStatusOrder<TRes> {
  _CopyWithStubImpl$Input$UserStatusOrder(this._res);

  TRes _res;

  call({
    Enum$UserStatusOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$VerifiableDomainOrder {
  factory Input$VerifiableDomainOrder({
    required Enum$VerifiableDomainOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$VerifiableDomainOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$VerifiableDomainOrder._(this._$data);

  factory Input$VerifiableDomainOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$VerifiableDomainOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$VerifiableDomainOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$VerifiableDomainOrderField get field =>
      (_$data['field'] as Enum$VerifiableDomainOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$VerifiableDomainOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$VerifiableDomainOrder<Input$VerifiableDomainOrder>
      get copyWith => CopyWith$Input$VerifiableDomainOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VerifiableDomainOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$VerifiableDomainOrder<TRes> {
  factory CopyWith$Input$VerifiableDomainOrder(
    Input$VerifiableDomainOrder instance,
    TRes Function(Input$VerifiableDomainOrder) then,
  ) = _CopyWithImpl$Input$VerifiableDomainOrder;

  factory CopyWith$Input$VerifiableDomainOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$VerifiableDomainOrder;

  TRes call({
    Enum$VerifiableDomainOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$VerifiableDomainOrder<TRes>
    implements CopyWith$Input$VerifiableDomainOrder<TRes> {
  _CopyWithImpl$Input$VerifiableDomainOrder(
    this._instance,
    this._then,
  );

  final Input$VerifiableDomainOrder _instance;

  final TRes Function(Input$VerifiableDomainOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$VerifiableDomainOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$VerifiableDomainOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$VerifiableDomainOrder<TRes>
    implements CopyWith$Input$VerifiableDomainOrder<TRes> {
  _CopyWithStubImpl$Input$VerifiableDomainOrder(this._res);

  TRes _res;

  call({
    Enum$VerifiableDomainOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$VerifyVerifiableDomainInput {
  factory Input$VerifyVerifiableDomainInput({
    required String id,
    String? clientMutationId,
  }) =>
      Input$VerifyVerifiableDomainInput._({
        r'id': id,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$VerifyVerifiableDomainInput._(this._$data);

  factory Input$VerifyVerifiableDomainInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$VerifyVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$VerifyVerifiableDomainInput<Input$VerifyVerifiableDomainInput>
      get copyWith => CopyWith$Input$VerifyVerifiableDomainInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VerifyVerifiableDomainInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$id,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$VerifyVerifiableDomainInput<TRes> {
  factory CopyWith$Input$VerifyVerifiableDomainInput(
    Input$VerifyVerifiableDomainInput instance,
    TRes Function(Input$VerifyVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$VerifyVerifiableDomainInput;

  factory CopyWith$Input$VerifyVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VerifyVerifiableDomainInput;

  TRes call({
    String? id,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$VerifyVerifiableDomainInput<TRes>
    implements CopyWith$Input$VerifyVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$VerifyVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$VerifyVerifiableDomainInput _instance;

  final TRes Function(Input$VerifyVerifiableDomainInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$VerifyVerifiableDomainInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$VerifyVerifiableDomainInput<TRes>
    implements CopyWith$Input$VerifyVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$VerifyVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? id,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$WorkflowRunOrder {
  factory Input$WorkflowRunOrder({
    required Enum$WorkflowRunOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$WorkflowRunOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$WorkflowRunOrder._(this._$data);

  factory Input$WorkflowRunOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$WorkflowRunOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$WorkflowRunOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$WorkflowRunOrderField get field =>
      (_$data['field'] as Enum$WorkflowRunOrderField);
  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$WorkflowRunOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$WorkflowRunOrder<Input$WorkflowRunOrder> get copyWith =>
      CopyWith$Input$WorkflowRunOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkflowRunOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$WorkflowRunOrder<TRes> {
  factory CopyWith$Input$WorkflowRunOrder(
    Input$WorkflowRunOrder instance,
    TRes Function(Input$WorkflowRunOrder) then,
  ) = _CopyWithImpl$Input$WorkflowRunOrder;

  factory CopyWith$Input$WorkflowRunOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkflowRunOrder;

  TRes call({
    Enum$WorkflowRunOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$WorkflowRunOrder<TRes>
    implements CopyWith$Input$WorkflowRunOrder<TRes> {
  _CopyWithImpl$Input$WorkflowRunOrder(
    this._instance,
    this._then,
  );

  final Input$WorkflowRunOrder _instance;

  final TRes Function(Input$WorkflowRunOrder) _then;

  static const _undefined = {};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$WorkflowRunOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$WorkflowRunOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$WorkflowRunOrder<TRes>
    implements CopyWith$Input$WorkflowRunOrder<TRes> {
  _CopyWithStubImpl$Input$WorkflowRunOrder(this._res);

  TRes _res;

  call({
    Enum$WorkflowRunOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

enum Enum$ActorType { USER, TEAM, $unknown }

String toJson$Enum$ActorType(Enum$ActorType e) {
  switch (e) {
    case Enum$ActorType.USER:
      return r'USER';
    case Enum$ActorType.TEAM:
      return r'TEAM';
    case Enum$ActorType.$unknown:
      return r'$unknown';
  }
}

Enum$ActorType fromJson$Enum$ActorType(String value) {
  switch (value) {
    case r'USER':
      return Enum$ActorType.USER;
    case r'TEAM':
      return Enum$ActorType.TEAM;
    default:
      return Enum$ActorType.$unknown;
  }
}

enum Enum$AuditLogOrderField { CREATED_AT, $unknown }

String toJson$Enum$AuditLogOrderField(Enum$AuditLogOrderField e) {
  switch (e) {
    case Enum$AuditLogOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$AuditLogOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$AuditLogOrderField fromJson$Enum$AuditLogOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$AuditLogOrderField.CREATED_AT;
    default:
      return Enum$AuditLogOrderField.$unknown;
  }
}

enum Enum$CheckAnnotationLevel { FAILURE, NOTICE, WARNING, $unknown }

String toJson$Enum$CheckAnnotationLevel(Enum$CheckAnnotationLevel e) {
  switch (e) {
    case Enum$CheckAnnotationLevel.FAILURE:
      return r'FAILURE';
    case Enum$CheckAnnotationLevel.NOTICE:
      return r'NOTICE';
    case Enum$CheckAnnotationLevel.WARNING:
      return r'WARNING';
    case Enum$CheckAnnotationLevel.$unknown:
      return r'$unknown';
  }
}

Enum$CheckAnnotationLevel fromJson$Enum$CheckAnnotationLevel(String value) {
  switch (value) {
    case r'FAILURE':
      return Enum$CheckAnnotationLevel.FAILURE;
    case r'NOTICE':
      return Enum$CheckAnnotationLevel.NOTICE;
    case r'WARNING':
      return Enum$CheckAnnotationLevel.WARNING;
    default:
      return Enum$CheckAnnotationLevel.$unknown;
  }
}

enum Enum$CheckConclusionState {
  ACTION_REQUIRED,
  TIMED_OUT,
  CANCELLED,
  FAILURE,
  SUCCESS,
  NEUTRAL,
  SKIPPED,
  STARTUP_FAILURE,
  STALE,
  $unknown
}

String toJson$Enum$CheckConclusionState(Enum$CheckConclusionState e) {
  switch (e) {
    case Enum$CheckConclusionState.ACTION_REQUIRED:
      return r'ACTION_REQUIRED';
    case Enum$CheckConclusionState.TIMED_OUT:
      return r'TIMED_OUT';
    case Enum$CheckConclusionState.CANCELLED:
      return r'CANCELLED';
    case Enum$CheckConclusionState.FAILURE:
      return r'FAILURE';
    case Enum$CheckConclusionState.SUCCESS:
      return r'SUCCESS';
    case Enum$CheckConclusionState.NEUTRAL:
      return r'NEUTRAL';
    case Enum$CheckConclusionState.SKIPPED:
      return r'SKIPPED';
    case Enum$CheckConclusionState.STARTUP_FAILURE:
      return r'STARTUP_FAILURE';
    case Enum$CheckConclusionState.STALE:
      return r'STALE';
    case Enum$CheckConclusionState.$unknown:
      return r'$unknown';
  }
}

Enum$CheckConclusionState fromJson$Enum$CheckConclusionState(String value) {
  switch (value) {
    case r'ACTION_REQUIRED':
      return Enum$CheckConclusionState.ACTION_REQUIRED;
    case r'TIMED_OUT':
      return Enum$CheckConclusionState.TIMED_OUT;
    case r'CANCELLED':
      return Enum$CheckConclusionState.CANCELLED;
    case r'FAILURE':
      return Enum$CheckConclusionState.FAILURE;
    case r'SUCCESS':
      return Enum$CheckConclusionState.SUCCESS;
    case r'NEUTRAL':
      return Enum$CheckConclusionState.NEUTRAL;
    case r'SKIPPED':
      return Enum$CheckConclusionState.SKIPPED;
    case r'STARTUP_FAILURE':
      return Enum$CheckConclusionState.STARTUP_FAILURE;
    case r'STALE':
      return Enum$CheckConclusionState.STALE;
    default:
      return Enum$CheckConclusionState.$unknown;
  }
}

enum Enum$CheckRunState {
  ACTION_REQUIRED,
  CANCELLED,
  COMPLETED,
  FAILURE,
  IN_PROGRESS,
  NEUTRAL,
  PENDING,
  QUEUED,
  SKIPPED,
  STALE,
  STARTUP_FAILURE,
  SUCCESS,
  TIMED_OUT,
  WAITING,
  $unknown
}

String toJson$Enum$CheckRunState(Enum$CheckRunState e) {
  switch (e) {
    case Enum$CheckRunState.ACTION_REQUIRED:
      return r'ACTION_REQUIRED';
    case Enum$CheckRunState.CANCELLED:
      return r'CANCELLED';
    case Enum$CheckRunState.COMPLETED:
      return r'COMPLETED';
    case Enum$CheckRunState.FAILURE:
      return r'FAILURE';
    case Enum$CheckRunState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$CheckRunState.NEUTRAL:
      return r'NEUTRAL';
    case Enum$CheckRunState.PENDING:
      return r'PENDING';
    case Enum$CheckRunState.QUEUED:
      return r'QUEUED';
    case Enum$CheckRunState.SKIPPED:
      return r'SKIPPED';
    case Enum$CheckRunState.STALE:
      return r'STALE';
    case Enum$CheckRunState.STARTUP_FAILURE:
      return r'STARTUP_FAILURE';
    case Enum$CheckRunState.SUCCESS:
      return r'SUCCESS';
    case Enum$CheckRunState.TIMED_OUT:
      return r'TIMED_OUT';
    case Enum$CheckRunState.WAITING:
      return r'WAITING';
    case Enum$CheckRunState.$unknown:
      return r'$unknown';
  }
}

Enum$CheckRunState fromJson$Enum$CheckRunState(String value) {
  switch (value) {
    case r'ACTION_REQUIRED':
      return Enum$CheckRunState.ACTION_REQUIRED;
    case r'CANCELLED':
      return Enum$CheckRunState.CANCELLED;
    case r'COMPLETED':
      return Enum$CheckRunState.COMPLETED;
    case r'FAILURE':
      return Enum$CheckRunState.FAILURE;
    case r'IN_PROGRESS':
      return Enum$CheckRunState.IN_PROGRESS;
    case r'NEUTRAL':
      return Enum$CheckRunState.NEUTRAL;
    case r'PENDING':
      return Enum$CheckRunState.PENDING;
    case r'QUEUED':
      return Enum$CheckRunState.QUEUED;
    case r'SKIPPED':
      return Enum$CheckRunState.SKIPPED;
    case r'STALE':
      return Enum$CheckRunState.STALE;
    case r'STARTUP_FAILURE':
      return Enum$CheckRunState.STARTUP_FAILURE;
    case r'SUCCESS':
      return Enum$CheckRunState.SUCCESS;
    case r'TIMED_OUT':
      return Enum$CheckRunState.TIMED_OUT;
    case r'WAITING':
      return Enum$CheckRunState.WAITING;
    default:
      return Enum$CheckRunState.$unknown;
  }
}

enum Enum$CheckRunType { ALL, LATEST, $unknown }

String toJson$Enum$CheckRunType(Enum$CheckRunType e) {
  switch (e) {
    case Enum$CheckRunType.ALL:
      return r'ALL';
    case Enum$CheckRunType.LATEST:
      return r'LATEST';
    case Enum$CheckRunType.$unknown:
      return r'$unknown';
  }
}

Enum$CheckRunType fromJson$Enum$CheckRunType(String value) {
  switch (value) {
    case r'ALL':
      return Enum$CheckRunType.ALL;
    case r'LATEST':
      return Enum$CheckRunType.LATEST;
    default:
      return Enum$CheckRunType.$unknown;
  }
}

enum Enum$CheckStatusState {
  QUEUED,
  IN_PROGRESS,
  COMPLETED,
  WAITING,
  PENDING,
  REQUESTED,
  $unknown
}

String toJson$Enum$CheckStatusState(Enum$CheckStatusState e) {
  switch (e) {
    case Enum$CheckStatusState.QUEUED:
      return r'QUEUED';
    case Enum$CheckStatusState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$CheckStatusState.COMPLETED:
      return r'COMPLETED';
    case Enum$CheckStatusState.WAITING:
      return r'WAITING';
    case Enum$CheckStatusState.PENDING:
      return r'PENDING';
    case Enum$CheckStatusState.REQUESTED:
      return r'REQUESTED';
    case Enum$CheckStatusState.$unknown:
      return r'$unknown';
  }
}

Enum$CheckStatusState fromJson$Enum$CheckStatusState(String value) {
  switch (value) {
    case r'QUEUED':
      return Enum$CheckStatusState.QUEUED;
    case r'IN_PROGRESS':
      return Enum$CheckStatusState.IN_PROGRESS;
    case r'COMPLETED':
      return Enum$CheckStatusState.COMPLETED;
    case r'WAITING':
      return Enum$CheckStatusState.WAITING;
    case r'PENDING':
      return Enum$CheckStatusState.PENDING;
    case r'REQUESTED':
      return Enum$CheckStatusState.REQUESTED;
    default:
      return Enum$CheckStatusState.$unknown;
  }
}

enum Enum$CollaboratorAffiliation { OUTSIDE, DIRECT, ALL, $unknown }

String toJson$Enum$CollaboratorAffiliation(Enum$CollaboratorAffiliation e) {
  switch (e) {
    case Enum$CollaboratorAffiliation.OUTSIDE:
      return r'OUTSIDE';
    case Enum$CollaboratorAffiliation.DIRECT:
      return r'DIRECT';
    case Enum$CollaboratorAffiliation.ALL:
      return r'ALL';
    case Enum$CollaboratorAffiliation.$unknown:
      return r'$unknown';
  }
}

Enum$CollaboratorAffiliation fromJson$Enum$CollaboratorAffiliation(
    String value) {
  switch (value) {
    case r'OUTSIDE':
      return Enum$CollaboratorAffiliation.OUTSIDE;
    case r'DIRECT':
      return Enum$CollaboratorAffiliation.DIRECT;
    case r'ALL':
      return Enum$CollaboratorAffiliation.ALL;
    default:
      return Enum$CollaboratorAffiliation.$unknown;
  }
}

enum Enum$CommentAuthorAssociation {
  MEMBER,
  OWNER,
  MANNEQUIN,
  COLLABORATOR,
  CONTRIBUTOR,
  FIRST_TIME_CONTRIBUTOR,
  FIRST_TIMER,
  NONE,
  $unknown
}

String toJson$Enum$CommentAuthorAssociation(Enum$CommentAuthorAssociation e) {
  switch (e) {
    case Enum$CommentAuthorAssociation.MEMBER:
      return r'MEMBER';
    case Enum$CommentAuthorAssociation.OWNER:
      return r'OWNER';
    case Enum$CommentAuthorAssociation.MANNEQUIN:
      return r'MANNEQUIN';
    case Enum$CommentAuthorAssociation.COLLABORATOR:
      return r'COLLABORATOR';
    case Enum$CommentAuthorAssociation.CONTRIBUTOR:
      return r'CONTRIBUTOR';
    case Enum$CommentAuthorAssociation.FIRST_TIME_CONTRIBUTOR:
      return r'FIRST_TIME_CONTRIBUTOR';
    case Enum$CommentAuthorAssociation.FIRST_TIMER:
      return r'FIRST_TIMER';
    case Enum$CommentAuthorAssociation.NONE:
      return r'NONE';
    case Enum$CommentAuthorAssociation.$unknown:
      return r'$unknown';
  }
}

Enum$CommentAuthorAssociation fromJson$Enum$CommentAuthorAssociation(
    String value) {
  switch (value) {
    case r'MEMBER':
      return Enum$CommentAuthorAssociation.MEMBER;
    case r'OWNER':
      return Enum$CommentAuthorAssociation.OWNER;
    case r'MANNEQUIN':
      return Enum$CommentAuthorAssociation.MANNEQUIN;
    case r'COLLABORATOR':
      return Enum$CommentAuthorAssociation.COLLABORATOR;
    case r'CONTRIBUTOR':
      return Enum$CommentAuthorAssociation.CONTRIBUTOR;
    case r'FIRST_TIME_CONTRIBUTOR':
      return Enum$CommentAuthorAssociation.FIRST_TIME_CONTRIBUTOR;
    case r'FIRST_TIMER':
      return Enum$CommentAuthorAssociation.FIRST_TIMER;
    case r'NONE':
      return Enum$CommentAuthorAssociation.NONE;
    default:
      return Enum$CommentAuthorAssociation.$unknown;
  }
}

enum Enum$CommentCannotUpdateReason {
  ARCHIVED,
  INSUFFICIENT_ACCESS,
  LOCKED,
  LOGIN_REQUIRED,
  MAINTENANCE,
  VERIFIED_EMAIL_REQUIRED,
  DENIED,
  $unknown
}

String toJson$Enum$CommentCannotUpdateReason(Enum$CommentCannotUpdateReason e) {
  switch (e) {
    case Enum$CommentCannotUpdateReason.ARCHIVED:
      return r'ARCHIVED';
    case Enum$CommentCannotUpdateReason.INSUFFICIENT_ACCESS:
      return r'INSUFFICIENT_ACCESS';
    case Enum$CommentCannotUpdateReason.LOCKED:
      return r'LOCKED';
    case Enum$CommentCannotUpdateReason.LOGIN_REQUIRED:
      return r'LOGIN_REQUIRED';
    case Enum$CommentCannotUpdateReason.MAINTENANCE:
      return r'MAINTENANCE';
    case Enum$CommentCannotUpdateReason.VERIFIED_EMAIL_REQUIRED:
      return r'VERIFIED_EMAIL_REQUIRED';
    case Enum$CommentCannotUpdateReason.DENIED:
      return r'DENIED';
    case Enum$CommentCannotUpdateReason.$unknown:
      return r'$unknown';
  }
}

Enum$CommentCannotUpdateReason fromJson$Enum$CommentCannotUpdateReason(
    String value) {
  switch (value) {
    case r'ARCHIVED':
      return Enum$CommentCannotUpdateReason.ARCHIVED;
    case r'INSUFFICIENT_ACCESS':
      return Enum$CommentCannotUpdateReason.INSUFFICIENT_ACCESS;
    case r'LOCKED':
      return Enum$CommentCannotUpdateReason.LOCKED;
    case r'LOGIN_REQUIRED':
      return Enum$CommentCannotUpdateReason.LOGIN_REQUIRED;
    case r'MAINTENANCE':
      return Enum$CommentCannotUpdateReason.MAINTENANCE;
    case r'VERIFIED_EMAIL_REQUIRED':
      return Enum$CommentCannotUpdateReason.VERIFIED_EMAIL_REQUIRED;
    case r'DENIED':
      return Enum$CommentCannotUpdateReason.DENIED;
    default:
      return Enum$CommentCannotUpdateReason.$unknown;
  }
}

enum Enum$CommitContributionOrderField { OCCURRED_AT, COMMIT_COUNT, $unknown }

String toJson$Enum$CommitContributionOrderField(
    Enum$CommitContributionOrderField e) {
  switch (e) {
    case Enum$CommitContributionOrderField.OCCURRED_AT:
      return r'OCCURRED_AT';
    case Enum$CommitContributionOrderField.COMMIT_COUNT:
      return r'COMMIT_COUNT';
    case Enum$CommitContributionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$CommitContributionOrderField fromJson$Enum$CommitContributionOrderField(
    String value) {
  switch (value) {
    case r'OCCURRED_AT':
      return Enum$CommitContributionOrderField.OCCURRED_AT;
    case r'COMMIT_COUNT':
      return Enum$CommitContributionOrderField.COMMIT_COUNT;
    default:
      return Enum$CommitContributionOrderField.$unknown;
  }
}

enum Enum$ComparisonStatus { DIVERGED, AHEAD, BEHIND, IDENTICAL, $unknown }

String toJson$Enum$ComparisonStatus(Enum$ComparisonStatus e) {
  switch (e) {
    case Enum$ComparisonStatus.DIVERGED:
      return r'DIVERGED';
    case Enum$ComparisonStatus.AHEAD:
      return r'AHEAD';
    case Enum$ComparisonStatus.BEHIND:
      return r'BEHIND';
    case Enum$ComparisonStatus.IDENTICAL:
      return r'IDENTICAL';
    case Enum$ComparisonStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ComparisonStatus fromJson$Enum$ComparisonStatus(String value) {
  switch (value) {
    case r'DIVERGED':
      return Enum$ComparisonStatus.DIVERGED;
    case r'AHEAD':
      return Enum$ComparisonStatus.AHEAD;
    case r'BEHIND':
      return Enum$ComparisonStatus.BEHIND;
    case r'IDENTICAL':
      return Enum$ComparisonStatus.IDENTICAL;
    default:
      return Enum$ComparisonStatus.$unknown;
  }
}

enum Enum$ContributionLevel {
  NONE,
  FIRST_QUARTILE,
  SECOND_QUARTILE,
  THIRD_QUARTILE,
  FOURTH_QUARTILE,
  $unknown
}

String toJson$Enum$ContributionLevel(Enum$ContributionLevel e) {
  switch (e) {
    case Enum$ContributionLevel.NONE:
      return r'NONE';
    case Enum$ContributionLevel.FIRST_QUARTILE:
      return r'FIRST_QUARTILE';
    case Enum$ContributionLevel.SECOND_QUARTILE:
      return r'SECOND_QUARTILE';
    case Enum$ContributionLevel.THIRD_QUARTILE:
      return r'THIRD_QUARTILE';
    case Enum$ContributionLevel.FOURTH_QUARTILE:
      return r'FOURTH_QUARTILE';
    case Enum$ContributionLevel.$unknown:
      return r'$unknown';
  }
}

Enum$ContributionLevel fromJson$Enum$ContributionLevel(String value) {
  switch (value) {
    case r'NONE':
      return Enum$ContributionLevel.NONE;
    case r'FIRST_QUARTILE':
      return Enum$ContributionLevel.FIRST_QUARTILE;
    case r'SECOND_QUARTILE':
      return Enum$ContributionLevel.SECOND_QUARTILE;
    case r'THIRD_QUARTILE':
      return Enum$ContributionLevel.THIRD_QUARTILE;
    case r'FOURTH_QUARTILE':
      return Enum$ContributionLevel.FOURTH_QUARTILE;
    default:
      return Enum$ContributionLevel.$unknown;
  }
}

enum Enum$DefaultRepositoryPermissionField {
  NONE,
  READ,
  WRITE,
  ADMIN,
  $unknown
}

String toJson$Enum$DefaultRepositoryPermissionField(
    Enum$DefaultRepositoryPermissionField e) {
  switch (e) {
    case Enum$DefaultRepositoryPermissionField.NONE:
      return r'NONE';
    case Enum$DefaultRepositoryPermissionField.READ:
      return r'READ';
    case Enum$DefaultRepositoryPermissionField.WRITE:
      return r'WRITE';
    case Enum$DefaultRepositoryPermissionField.ADMIN:
      return r'ADMIN';
    case Enum$DefaultRepositoryPermissionField.$unknown:
      return r'$unknown';
  }
}

Enum$DefaultRepositoryPermissionField
    fromJson$Enum$DefaultRepositoryPermissionField(String value) {
  switch (value) {
    case r'NONE':
      return Enum$DefaultRepositoryPermissionField.NONE;
    case r'READ':
      return Enum$DefaultRepositoryPermissionField.READ;
    case r'WRITE':
      return Enum$DefaultRepositoryPermissionField.WRITE;
    case r'ADMIN':
      return Enum$DefaultRepositoryPermissionField.ADMIN;
    default:
      return Enum$DefaultRepositoryPermissionField.$unknown;
  }
}

enum Enum$DependencyGraphEcosystem {
  RUBYGEMS,
  NPM,
  PIP,
  MAVEN,
  NUGET,
  COMPOSER,
  GO,
  ACTIONS,
  RUST,
  PUB,
  $unknown
}

String toJson$Enum$DependencyGraphEcosystem(Enum$DependencyGraphEcosystem e) {
  switch (e) {
    case Enum$DependencyGraphEcosystem.RUBYGEMS:
      return r'RUBYGEMS';
    case Enum$DependencyGraphEcosystem.NPM:
      return r'NPM';
    case Enum$DependencyGraphEcosystem.PIP:
      return r'PIP';
    case Enum$DependencyGraphEcosystem.MAVEN:
      return r'MAVEN';
    case Enum$DependencyGraphEcosystem.NUGET:
      return r'NUGET';
    case Enum$DependencyGraphEcosystem.COMPOSER:
      return r'COMPOSER';
    case Enum$DependencyGraphEcosystem.GO:
      return r'GO';
    case Enum$DependencyGraphEcosystem.ACTIONS:
      return r'ACTIONS';
    case Enum$DependencyGraphEcosystem.RUST:
      return r'RUST';
    case Enum$DependencyGraphEcosystem.PUB:
      return r'PUB';
    case Enum$DependencyGraphEcosystem.$unknown:
      return r'$unknown';
  }
}

Enum$DependencyGraphEcosystem fromJson$Enum$DependencyGraphEcosystem(
    String value) {
  switch (value) {
    case r'RUBYGEMS':
      return Enum$DependencyGraphEcosystem.RUBYGEMS;
    case r'NPM':
      return Enum$DependencyGraphEcosystem.NPM;
    case r'PIP':
      return Enum$DependencyGraphEcosystem.PIP;
    case r'MAVEN':
      return Enum$DependencyGraphEcosystem.MAVEN;
    case r'NUGET':
      return Enum$DependencyGraphEcosystem.NUGET;
    case r'COMPOSER':
      return Enum$DependencyGraphEcosystem.COMPOSER;
    case r'GO':
      return Enum$DependencyGraphEcosystem.GO;
    case r'ACTIONS':
      return Enum$DependencyGraphEcosystem.ACTIONS;
    case r'RUST':
      return Enum$DependencyGraphEcosystem.RUST;
    case r'PUB':
      return Enum$DependencyGraphEcosystem.PUB;
    default:
      return Enum$DependencyGraphEcosystem.$unknown;
  }
}

enum Enum$DeploymentOrderField { CREATED_AT, $unknown }

String toJson$Enum$DeploymentOrderField(Enum$DeploymentOrderField e) {
  switch (e) {
    case Enum$DeploymentOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$DeploymentOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentOrderField fromJson$Enum$DeploymentOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$DeploymentOrderField.CREATED_AT;
    default:
      return Enum$DeploymentOrderField.$unknown;
  }
}

enum Enum$DeploymentProtectionRuleType {
  REQUIRED_REVIEWERS,
  WAIT_TIMER,
  $unknown
}

String toJson$Enum$DeploymentProtectionRuleType(
    Enum$DeploymentProtectionRuleType e) {
  switch (e) {
    case Enum$DeploymentProtectionRuleType.REQUIRED_REVIEWERS:
      return r'REQUIRED_REVIEWERS';
    case Enum$DeploymentProtectionRuleType.WAIT_TIMER:
      return r'WAIT_TIMER';
    case Enum$DeploymentProtectionRuleType.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentProtectionRuleType fromJson$Enum$DeploymentProtectionRuleType(
    String value) {
  switch (value) {
    case r'REQUIRED_REVIEWERS':
      return Enum$DeploymentProtectionRuleType.REQUIRED_REVIEWERS;
    case r'WAIT_TIMER':
      return Enum$DeploymentProtectionRuleType.WAIT_TIMER;
    default:
      return Enum$DeploymentProtectionRuleType.$unknown;
  }
}

enum Enum$DeploymentReviewState { APPROVED, REJECTED, $unknown }

String toJson$Enum$DeploymentReviewState(Enum$DeploymentReviewState e) {
  switch (e) {
    case Enum$DeploymentReviewState.APPROVED:
      return r'APPROVED';
    case Enum$DeploymentReviewState.REJECTED:
      return r'REJECTED';
    case Enum$DeploymentReviewState.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentReviewState fromJson$Enum$DeploymentReviewState(String value) {
  switch (value) {
    case r'APPROVED':
      return Enum$DeploymentReviewState.APPROVED;
    case r'REJECTED':
      return Enum$DeploymentReviewState.REJECTED;
    default:
      return Enum$DeploymentReviewState.$unknown;
  }
}

enum Enum$DeploymentState {
  ABANDONED,
  ACTIVE,
  DESTROYED,
  ERROR,
  FAILURE,
  INACTIVE,
  PENDING,
  QUEUED,
  IN_PROGRESS,
  WAITING,
  $unknown
}

String toJson$Enum$DeploymentState(Enum$DeploymentState e) {
  switch (e) {
    case Enum$DeploymentState.ABANDONED:
      return r'ABANDONED';
    case Enum$DeploymentState.ACTIVE:
      return r'ACTIVE';
    case Enum$DeploymentState.DESTROYED:
      return r'DESTROYED';
    case Enum$DeploymentState.ERROR:
      return r'ERROR';
    case Enum$DeploymentState.FAILURE:
      return r'FAILURE';
    case Enum$DeploymentState.INACTIVE:
      return r'INACTIVE';
    case Enum$DeploymentState.PENDING:
      return r'PENDING';
    case Enum$DeploymentState.QUEUED:
      return r'QUEUED';
    case Enum$DeploymentState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$DeploymentState.WAITING:
      return r'WAITING';
    case Enum$DeploymentState.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentState fromJson$Enum$DeploymentState(String value) {
  switch (value) {
    case r'ABANDONED':
      return Enum$DeploymentState.ABANDONED;
    case r'ACTIVE':
      return Enum$DeploymentState.ACTIVE;
    case r'DESTROYED':
      return Enum$DeploymentState.DESTROYED;
    case r'ERROR':
      return Enum$DeploymentState.ERROR;
    case r'FAILURE':
      return Enum$DeploymentState.FAILURE;
    case r'INACTIVE':
      return Enum$DeploymentState.INACTIVE;
    case r'PENDING':
      return Enum$DeploymentState.PENDING;
    case r'QUEUED':
      return Enum$DeploymentState.QUEUED;
    case r'IN_PROGRESS':
      return Enum$DeploymentState.IN_PROGRESS;
    case r'WAITING':
      return Enum$DeploymentState.WAITING;
    default:
      return Enum$DeploymentState.$unknown;
  }
}

enum Enum$DeploymentStatusState {
  PENDING,
  SUCCESS,
  FAILURE,
  INACTIVE,
  ERROR,
  QUEUED,
  IN_PROGRESS,
  WAITING,
  $unknown
}

String toJson$Enum$DeploymentStatusState(Enum$DeploymentStatusState e) {
  switch (e) {
    case Enum$DeploymentStatusState.PENDING:
      return r'PENDING';
    case Enum$DeploymentStatusState.SUCCESS:
      return r'SUCCESS';
    case Enum$DeploymentStatusState.FAILURE:
      return r'FAILURE';
    case Enum$DeploymentStatusState.INACTIVE:
      return r'INACTIVE';
    case Enum$DeploymentStatusState.ERROR:
      return r'ERROR';
    case Enum$DeploymentStatusState.QUEUED:
      return r'QUEUED';
    case Enum$DeploymentStatusState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$DeploymentStatusState.WAITING:
      return r'WAITING';
    case Enum$DeploymentStatusState.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentStatusState fromJson$Enum$DeploymentStatusState(String value) {
  switch (value) {
    case r'PENDING':
      return Enum$DeploymentStatusState.PENDING;
    case r'SUCCESS':
      return Enum$DeploymentStatusState.SUCCESS;
    case r'FAILURE':
      return Enum$DeploymentStatusState.FAILURE;
    case r'INACTIVE':
      return Enum$DeploymentStatusState.INACTIVE;
    case r'ERROR':
      return Enum$DeploymentStatusState.ERROR;
    case r'QUEUED':
      return Enum$DeploymentStatusState.QUEUED;
    case r'IN_PROGRESS':
      return Enum$DeploymentStatusState.IN_PROGRESS;
    case r'WAITING':
      return Enum$DeploymentStatusState.WAITING;
    default:
      return Enum$DeploymentStatusState.$unknown;
  }
}

enum Enum$DiffSide { LEFT, RIGHT, $unknown }

String toJson$Enum$DiffSide(Enum$DiffSide e) {
  switch (e) {
    case Enum$DiffSide.LEFT:
      return r'LEFT';
    case Enum$DiffSide.RIGHT:
      return r'RIGHT';
    case Enum$DiffSide.$unknown:
      return r'$unknown';
  }
}

Enum$DiffSide fromJson$Enum$DiffSide(String value) {
  switch (value) {
    case r'LEFT':
      return Enum$DiffSide.LEFT;
    case r'RIGHT':
      return Enum$DiffSide.RIGHT;
    default:
      return Enum$DiffSide.$unknown;
  }
}

enum Enum$DiscussionOrderField { CREATED_AT, UPDATED_AT, $unknown }

String toJson$Enum$DiscussionOrderField(Enum$DiscussionOrderField e) {
  switch (e) {
    case Enum$DiscussionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$DiscussionOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$DiscussionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionOrderField fromJson$Enum$DiscussionOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$DiscussionOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$DiscussionOrderField.UPDATED_AT;
    default:
      return Enum$DiscussionOrderField.$unknown;
  }
}

enum Enum$DiscussionPollOptionOrderField {
  AUTHORED_ORDER,
  VOTE_COUNT,
  $unknown
}

String toJson$Enum$DiscussionPollOptionOrderField(
    Enum$DiscussionPollOptionOrderField e) {
  switch (e) {
    case Enum$DiscussionPollOptionOrderField.AUTHORED_ORDER:
      return r'AUTHORED_ORDER';
    case Enum$DiscussionPollOptionOrderField.VOTE_COUNT:
      return r'VOTE_COUNT';
    case Enum$DiscussionPollOptionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionPollOptionOrderField
    fromJson$Enum$DiscussionPollOptionOrderField(String value) {
  switch (value) {
    case r'AUTHORED_ORDER':
      return Enum$DiscussionPollOptionOrderField.AUTHORED_ORDER;
    case r'VOTE_COUNT':
      return Enum$DiscussionPollOptionOrderField.VOTE_COUNT;
    default:
      return Enum$DiscussionPollOptionOrderField.$unknown;
  }
}

enum Enum$DismissReason {
  FIX_STARTED,
  NO_BANDWIDTH,
  TOLERABLE_RISK,
  INACCURATE,
  NOT_USED,
  $unknown
}

String toJson$Enum$DismissReason(Enum$DismissReason e) {
  switch (e) {
    case Enum$DismissReason.FIX_STARTED:
      return r'FIX_STARTED';
    case Enum$DismissReason.NO_BANDWIDTH:
      return r'NO_BANDWIDTH';
    case Enum$DismissReason.TOLERABLE_RISK:
      return r'TOLERABLE_RISK';
    case Enum$DismissReason.INACCURATE:
      return r'INACCURATE';
    case Enum$DismissReason.NOT_USED:
      return r'NOT_USED';
    case Enum$DismissReason.$unknown:
      return r'$unknown';
  }
}

Enum$DismissReason fromJson$Enum$DismissReason(String value) {
  switch (value) {
    case r'FIX_STARTED':
      return Enum$DismissReason.FIX_STARTED;
    case r'NO_BANDWIDTH':
      return Enum$DismissReason.NO_BANDWIDTH;
    case r'TOLERABLE_RISK':
      return Enum$DismissReason.TOLERABLE_RISK;
    case r'INACCURATE':
      return Enum$DismissReason.INACCURATE;
    case r'NOT_USED':
      return Enum$DismissReason.NOT_USED;
    default:
      return Enum$DismissReason.$unknown;
  }
}

enum Enum$EnterpriseAdministratorInvitationOrderField { CREATED_AT, $unknown }

String toJson$Enum$EnterpriseAdministratorInvitationOrderField(
    Enum$EnterpriseAdministratorInvitationOrderField e) {
  switch (e) {
    case Enum$EnterpriseAdministratorInvitationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseAdministratorInvitationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseAdministratorInvitationOrderField
    fromJson$Enum$EnterpriseAdministratorInvitationOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$EnterpriseAdministratorInvitationOrderField.CREATED_AT;
    default:
      return Enum$EnterpriseAdministratorInvitationOrderField.$unknown;
  }
}

enum Enum$EnterpriseAdministratorRole { OWNER, BILLING_MANAGER, $unknown }

String toJson$Enum$EnterpriseAdministratorRole(
    Enum$EnterpriseAdministratorRole e) {
  switch (e) {
    case Enum$EnterpriseAdministratorRole.OWNER:
      return r'OWNER';
    case Enum$EnterpriseAdministratorRole.BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$EnterpriseAdministratorRole.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseAdministratorRole fromJson$Enum$EnterpriseAdministratorRole(
    String value) {
  switch (value) {
    case r'OWNER':
      return Enum$EnterpriseAdministratorRole.OWNER;
    case r'BILLING_MANAGER':
      return Enum$EnterpriseAdministratorRole.BILLING_MANAGER;
    default:
      return Enum$EnterpriseAdministratorRole.$unknown;
  }
}

enum Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue {
  ENTERPRISE_ORGANIZATIONS,
  SAME_ORGANIZATION,
  SAME_ORGANIZATION_USER_ACCOUNTS,
  ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS,
  USER_ACCOUNTS,
  EVERYWHERE,
  $unknown
}

String toJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue e) {
  switch (e) {
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
        .ENTERPRISE_ORGANIZATIONS:
      return r'ENTERPRISE_ORGANIZATIONS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
        .SAME_ORGANIZATION:
      return r'SAME_ORGANIZATION';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
        .SAME_ORGANIZATION_USER_ACCOUNTS:
      return r'SAME_ORGANIZATION_USER_ACCOUNTS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
        .ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS:
      return r'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.USER_ACCOUNTS:
      return r'USER_ACCOUNTS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.EVERYWHERE:
      return r'EVERYWHERE';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
    fromJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
        String value) {
  switch (value) {
    case r'ENTERPRISE_ORGANIZATIONS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .ENTERPRISE_ORGANIZATIONS;
    case r'SAME_ORGANIZATION':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .SAME_ORGANIZATION;
    case r'SAME_ORGANIZATION_USER_ACCOUNTS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .SAME_ORGANIZATION_USER_ACCOUNTS;
    case r'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS;
    case r'USER_ACCOUNTS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .USER_ACCOUNTS;
    case r'EVERYWHERE':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.EVERYWHERE;
    default:
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.$unknown;
  }
}

enum Enum$EnterpriseDefaultRepositoryPermissionSettingValue {
  NO_POLICY,
  ADMIN,
  WRITE,
  READ,
  NONE,
  $unknown
}

String toJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
    Enum$EnterpriseDefaultRepositoryPermissionSettingValue e) {
  switch (e) {
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.ADMIN:
      return r'ADMIN';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.WRITE:
      return r'WRITE';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.READ:
      return r'READ';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NONE:
      return r'NONE';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseDefaultRepositoryPermissionSettingValue
    fromJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
        String value) {
  switch (value) {
    case r'NO_POLICY':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NO_POLICY;
    case r'ADMIN':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.ADMIN;
    case r'WRITE':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.WRITE;
    case r'READ':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.READ;
    case r'NONE':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NONE;
    default:
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.$unknown;
  }
}

enum Enum$EnterpriseEnabledDisabledSettingValue {
  ENABLED,
  DISABLED,
  NO_POLICY,
  $unknown
}

String toJson$Enum$EnterpriseEnabledDisabledSettingValue(
    Enum$EnterpriseEnabledDisabledSettingValue e) {
  switch (e) {
    case Enum$EnterpriseEnabledDisabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$EnterpriseEnabledDisabledSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$EnterpriseEnabledDisabledSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseEnabledDisabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseEnabledDisabledSettingValue
    fromJson$Enum$EnterpriseEnabledDisabledSettingValue(String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$EnterpriseEnabledDisabledSettingValue.ENABLED;
    case r'DISABLED':
      return Enum$EnterpriseEnabledDisabledSettingValue.DISABLED;
    case r'NO_POLICY':
      return Enum$EnterpriseEnabledDisabledSettingValue.NO_POLICY;
    default:
      return Enum$EnterpriseEnabledDisabledSettingValue.$unknown;
  }
}

enum Enum$EnterpriseEnabledSettingValue { ENABLED, NO_POLICY, $unknown }

String toJson$Enum$EnterpriseEnabledSettingValue(
    Enum$EnterpriseEnabledSettingValue e) {
  switch (e) {
    case Enum$EnterpriseEnabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$EnterpriseEnabledSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseEnabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseEnabledSettingValue fromJson$Enum$EnterpriseEnabledSettingValue(
    String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$EnterpriseEnabledSettingValue.ENABLED;
    case r'NO_POLICY':
      return Enum$EnterpriseEnabledSettingValue.NO_POLICY;
    default:
      return Enum$EnterpriseEnabledSettingValue.$unknown;
  }
}

enum Enum$EnterpriseMemberOrderField { LOGIN, CREATED_AT, $unknown }

String toJson$Enum$EnterpriseMemberOrderField(
    Enum$EnterpriseMemberOrderField e) {
  switch (e) {
    case Enum$EnterpriseMemberOrderField.LOGIN:
      return r'LOGIN';
    case Enum$EnterpriseMemberOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseMemberOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseMemberOrderField fromJson$Enum$EnterpriseMemberOrderField(
    String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$EnterpriseMemberOrderField.LOGIN;
    case r'CREATED_AT':
      return Enum$EnterpriseMemberOrderField.CREATED_AT;
    default:
      return Enum$EnterpriseMemberOrderField.$unknown;
  }
}

enum Enum$EnterpriseMembersCanCreateRepositoriesSettingValue {
  NO_POLICY,
  ALL,
  PUBLIC,
  PRIVATE,
  DISABLED,
  $unknown
}

String toJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue e) {
  switch (e) {
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.ALL:
      return r'ALL';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PUBLIC:
      return r'PUBLIC';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PRIVATE:
      return r'PRIVATE';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseMembersCanCreateRepositoriesSettingValue
    fromJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
        String value) {
  switch (value) {
    case r'NO_POLICY':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.NO_POLICY;
    case r'ALL':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.ALL;
    case r'PUBLIC':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PUBLIC;
    case r'PRIVATE':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PRIVATE;
    case r'DISABLED':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.DISABLED;
    default:
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.$unknown;
  }
}

enum Enum$EnterpriseMembersCanMakePurchasesSettingValue {
  ENABLED,
  DISABLED,
  $unknown
}

String toJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(
    Enum$EnterpriseMembersCanMakePurchasesSettingValue e) {
  switch (e) {
    case Enum$EnterpriseMembersCanMakePurchasesSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$EnterpriseMembersCanMakePurchasesSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$EnterpriseMembersCanMakePurchasesSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseMembersCanMakePurchasesSettingValue
    fromJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$EnterpriseMembersCanMakePurchasesSettingValue.ENABLED;
    case r'DISABLED':
      return Enum$EnterpriseMembersCanMakePurchasesSettingValue.DISABLED;
    default:
      return Enum$EnterpriseMembersCanMakePurchasesSettingValue.$unknown;
  }
}

enum Enum$EnterpriseServerInstallationOrderField {
  HOST_NAME,
  CUSTOMER_NAME,
  CREATED_AT,
  $unknown
}

String toJson$Enum$EnterpriseServerInstallationOrderField(
    Enum$EnterpriseServerInstallationOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerInstallationOrderField.HOST_NAME:
      return r'HOST_NAME';
    case Enum$EnterpriseServerInstallationOrderField.CUSTOMER_NAME:
      return r'CUSTOMER_NAME';
    case Enum$EnterpriseServerInstallationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseServerInstallationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerInstallationOrderField
    fromJson$Enum$EnterpriseServerInstallationOrderField(String value) {
  switch (value) {
    case r'HOST_NAME':
      return Enum$EnterpriseServerInstallationOrderField.HOST_NAME;
    case r'CUSTOMER_NAME':
      return Enum$EnterpriseServerInstallationOrderField.CUSTOMER_NAME;
    case r'CREATED_AT':
      return Enum$EnterpriseServerInstallationOrderField.CREATED_AT;
    default:
      return Enum$EnterpriseServerInstallationOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountEmailOrderField { EMAIL, $unknown }

String toJson$Enum$EnterpriseServerUserAccountEmailOrderField(
    Enum$EnterpriseServerUserAccountEmailOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountEmailOrderField.EMAIL:
      return r'EMAIL';
    case Enum$EnterpriseServerUserAccountEmailOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountEmailOrderField
    fromJson$Enum$EnterpriseServerUserAccountEmailOrderField(String value) {
  switch (value) {
    case r'EMAIL':
      return Enum$EnterpriseServerUserAccountEmailOrderField.EMAIL;
    default:
      return Enum$EnterpriseServerUserAccountEmailOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountOrderField {
  LOGIN,
  REMOTE_CREATED_AT,
  $unknown
}

String toJson$Enum$EnterpriseServerUserAccountOrderField(
    Enum$EnterpriseServerUserAccountOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountOrderField.LOGIN:
      return r'LOGIN';
    case Enum$EnterpriseServerUserAccountOrderField.REMOTE_CREATED_AT:
      return r'REMOTE_CREATED_AT';
    case Enum$EnterpriseServerUserAccountOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountOrderField
    fromJson$Enum$EnterpriseServerUserAccountOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$EnterpriseServerUserAccountOrderField.LOGIN;
    case r'REMOTE_CREATED_AT':
      return Enum$EnterpriseServerUserAccountOrderField.REMOTE_CREATED_AT;
    default:
      return Enum$EnterpriseServerUserAccountOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountsUploadOrderField { CREATED_AT, $unknown }

String toJson$Enum$EnterpriseServerUserAccountsUploadOrderField(
    Enum$EnterpriseServerUserAccountsUploadOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountsUploadOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseServerUserAccountsUploadOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountsUploadOrderField
    fromJson$Enum$EnterpriseServerUserAccountsUploadOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$EnterpriseServerUserAccountsUploadOrderField.CREATED_AT;
    default:
      return Enum$EnterpriseServerUserAccountsUploadOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountsUploadSyncState {
  PENDING,
  SUCCESS,
  FAILURE,
  $unknown
}

String toJson$Enum$EnterpriseServerUserAccountsUploadSyncState(
    Enum$EnterpriseServerUserAccountsUploadSyncState e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountsUploadSyncState.PENDING:
      return r'PENDING';
    case Enum$EnterpriseServerUserAccountsUploadSyncState.SUCCESS:
      return r'SUCCESS';
    case Enum$EnterpriseServerUserAccountsUploadSyncState.FAILURE:
      return r'FAILURE';
    case Enum$EnterpriseServerUserAccountsUploadSyncState.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountsUploadSyncState
    fromJson$Enum$EnterpriseServerUserAccountsUploadSyncState(String value) {
  switch (value) {
    case r'PENDING':
      return Enum$EnterpriseServerUserAccountsUploadSyncState.PENDING;
    case r'SUCCESS':
      return Enum$EnterpriseServerUserAccountsUploadSyncState.SUCCESS;
    case r'FAILURE':
      return Enum$EnterpriseServerUserAccountsUploadSyncState.FAILURE;
    default:
      return Enum$EnterpriseServerUserAccountsUploadSyncState.$unknown;
  }
}

enum Enum$EnterpriseUserAccountMembershipRole {
  MEMBER,
  OWNER,
  UNAFFILIATED,
  $unknown
}

String toJson$Enum$EnterpriseUserAccountMembershipRole(
    Enum$EnterpriseUserAccountMembershipRole e) {
  switch (e) {
    case Enum$EnterpriseUserAccountMembershipRole.MEMBER:
      return r'MEMBER';
    case Enum$EnterpriseUserAccountMembershipRole.OWNER:
      return r'OWNER';
    case Enum$EnterpriseUserAccountMembershipRole.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$EnterpriseUserAccountMembershipRole.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseUserAccountMembershipRole
    fromJson$Enum$EnterpriseUserAccountMembershipRole(String value) {
  switch (value) {
    case r'MEMBER':
      return Enum$EnterpriseUserAccountMembershipRole.MEMBER;
    case r'OWNER':
      return Enum$EnterpriseUserAccountMembershipRole.OWNER;
    case r'UNAFFILIATED':
      return Enum$EnterpriseUserAccountMembershipRole.UNAFFILIATED;
    default:
      return Enum$EnterpriseUserAccountMembershipRole.$unknown;
  }
}

enum Enum$EnterpriseUserDeployment { CLOUD, SERVER, $unknown }

String toJson$Enum$EnterpriseUserDeployment(Enum$EnterpriseUserDeployment e) {
  switch (e) {
    case Enum$EnterpriseUserDeployment.CLOUD:
      return r'CLOUD';
    case Enum$EnterpriseUserDeployment.SERVER:
      return r'SERVER';
    case Enum$EnterpriseUserDeployment.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseUserDeployment fromJson$Enum$EnterpriseUserDeployment(
    String value) {
  switch (value) {
    case r'CLOUD':
      return Enum$EnterpriseUserDeployment.CLOUD;
    case r'SERVER':
      return Enum$EnterpriseUserDeployment.SERVER;
    default:
      return Enum$EnterpriseUserDeployment.$unknown;
  }
}

enum Enum$FileViewedState { DISMISSED, VIEWED, UNVIEWED, $unknown }

String toJson$Enum$FileViewedState(Enum$FileViewedState e) {
  switch (e) {
    case Enum$FileViewedState.DISMISSED:
      return r'DISMISSED';
    case Enum$FileViewedState.VIEWED:
      return r'VIEWED';
    case Enum$FileViewedState.UNVIEWED:
      return r'UNVIEWED';
    case Enum$FileViewedState.$unknown:
      return r'$unknown';
  }
}

Enum$FileViewedState fromJson$Enum$FileViewedState(String value) {
  switch (value) {
    case r'DISMISSED':
      return Enum$FileViewedState.DISMISSED;
    case r'VIEWED':
      return Enum$FileViewedState.VIEWED;
    case r'UNVIEWED':
      return Enum$FileViewedState.UNVIEWED;
    default:
      return Enum$FileViewedState.$unknown;
  }
}

enum Enum$FundingPlatform {
  GITHUB,
  PATREON,
  OPEN_COLLECTIVE,
  KO_FI,
  TIDELIFT,
  COMMUNITY_BRIDGE,
  LIBERAPAY,
  ISSUEHUNT,
  OTECHIE,
  LFX_CROWDFUNDING,
  CUSTOM,
  $unknown
}

String toJson$Enum$FundingPlatform(Enum$FundingPlatform e) {
  switch (e) {
    case Enum$FundingPlatform.GITHUB:
      return r'GITHUB';
    case Enum$FundingPlatform.PATREON:
      return r'PATREON';
    case Enum$FundingPlatform.OPEN_COLLECTIVE:
      return r'OPEN_COLLECTIVE';
    case Enum$FundingPlatform.KO_FI:
      return r'KO_FI';
    case Enum$FundingPlatform.TIDELIFT:
      return r'TIDELIFT';
    case Enum$FundingPlatform.COMMUNITY_BRIDGE:
      return r'COMMUNITY_BRIDGE';
    case Enum$FundingPlatform.LIBERAPAY:
      return r'LIBERAPAY';
    case Enum$FundingPlatform.ISSUEHUNT:
      return r'ISSUEHUNT';
    case Enum$FundingPlatform.OTECHIE:
      return r'OTECHIE';
    case Enum$FundingPlatform.LFX_CROWDFUNDING:
      return r'LFX_CROWDFUNDING';
    case Enum$FundingPlatform.CUSTOM:
      return r'CUSTOM';
    case Enum$FundingPlatform.$unknown:
      return r'$unknown';
  }
}

Enum$FundingPlatform fromJson$Enum$FundingPlatform(String value) {
  switch (value) {
    case r'GITHUB':
      return Enum$FundingPlatform.GITHUB;
    case r'PATREON':
      return Enum$FundingPlatform.PATREON;
    case r'OPEN_COLLECTIVE':
      return Enum$FundingPlatform.OPEN_COLLECTIVE;
    case r'KO_FI':
      return Enum$FundingPlatform.KO_FI;
    case r'TIDELIFT':
      return Enum$FundingPlatform.TIDELIFT;
    case r'COMMUNITY_BRIDGE':
      return Enum$FundingPlatform.COMMUNITY_BRIDGE;
    case r'LIBERAPAY':
      return Enum$FundingPlatform.LIBERAPAY;
    case r'ISSUEHUNT':
      return Enum$FundingPlatform.ISSUEHUNT;
    case r'OTECHIE':
      return Enum$FundingPlatform.OTECHIE;
    case r'LFX_CROWDFUNDING':
      return Enum$FundingPlatform.LFX_CROWDFUNDING;
    case r'CUSTOM':
      return Enum$FundingPlatform.CUSTOM;
    default:
      return Enum$FundingPlatform.$unknown;
  }
}

enum Enum$GistOrderField { CREATED_AT, UPDATED_AT, PUSHED_AT, $unknown }

String toJson$Enum$GistOrderField(Enum$GistOrderField e) {
  switch (e) {
    case Enum$GistOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$GistOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$GistOrderField.PUSHED_AT:
      return r'PUSHED_AT';
    case Enum$GistOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$GistOrderField fromJson$Enum$GistOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$GistOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$GistOrderField.UPDATED_AT;
    case r'PUSHED_AT':
      return Enum$GistOrderField.PUSHED_AT;
    default:
      return Enum$GistOrderField.$unknown;
  }
}

enum Enum$GistPrivacy { PUBLIC, SECRET, ALL, $unknown }

String toJson$Enum$GistPrivacy(Enum$GistPrivacy e) {
  switch (e) {
    case Enum$GistPrivacy.PUBLIC:
      return r'PUBLIC';
    case Enum$GistPrivacy.SECRET:
      return r'SECRET';
    case Enum$GistPrivacy.ALL:
      return r'ALL';
    case Enum$GistPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$GistPrivacy fromJson$Enum$GistPrivacy(String value) {
  switch (value) {
    case r'PUBLIC':
      return Enum$GistPrivacy.PUBLIC;
    case r'SECRET':
      return Enum$GistPrivacy.SECRET;
    case r'ALL':
      return Enum$GistPrivacy.ALL;
    default:
      return Enum$GistPrivacy.$unknown;
  }
}

enum Enum$GitSignatureState {
  VALID,
  INVALID,
  MALFORMED_SIG,
  UNKNOWN_KEY,
  BAD_EMAIL,
  UNVERIFIED_EMAIL,
  NO_USER,
  UNKNOWN_SIG_TYPE,
  UNSIGNED,
  GPGVERIFY_UNAVAILABLE,
  GPGVERIFY_ERROR,
  NOT_SIGNING_KEY,
  EXPIRED_KEY,
  OCSP_PENDING,
  OCSP_ERROR,
  BAD_CERT,
  OCSP_REVOKED,
  $unknown
}

String toJson$Enum$GitSignatureState(Enum$GitSignatureState e) {
  switch (e) {
    case Enum$GitSignatureState.VALID:
      return r'VALID';
    case Enum$GitSignatureState.INVALID:
      return r'INVALID';
    case Enum$GitSignatureState.MALFORMED_SIG:
      return r'MALFORMED_SIG';
    case Enum$GitSignatureState.UNKNOWN_KEY:
      return r'UNKNOWN_KEY';
    case Enum$GitSignatureState.BAD_EMAIL:
      return r'BAD_EMAIL';
    case Enum$GitSignatureState.UNVERIFIED_EMAIL:
      return r'UNVERIFIED_EMAIL';
    case Enum$GitSignatureState.NO_USER:
      return r'NO_USER';
    case Enum$GitSignatureState.UNKNOWN_SIG_TYPE:
      return r'UNKNOWN_SIG_TYPE';
    case Enum$GitSignatureState.UNSIGNED:
      return r'UNSIGNED';
    case Enum$GitSignatureState.GPGVERIFY_UNAVAILABLE:
      return r'GPGVERIFY_UNAVAILABLE';
    case Enum$GitSignatureState.GPGVERIFY_ERROR:
      return r'GPGVERIFY_ERROR';
    case Enum$GitSignatureState.NOT_SIGNING_KEY:
      return r'NOT_SIGNING_KEY';
    case Enum$GitSignatureState.EXPIRED_KEY:
      return r'EXPIRED_KEY';
    case Enum$GitSignatureState.OCSP_PENDING:
      return r'OCSP_PENDING';
    case Enum$GitSignatureState.OCSP_ERROR:
      return r'OCSP_ERROR';
    case Enum$GitSignatureState.BAD_CERT:
      return r'BAD_CERT';
    case Enum$GitSignatureState.OCSP_REVOKED:
      return r'OCSP_REVOKED';
    case Enum$GitSignatureState.$unknown:
      return r'$unknown';
  }
}

Enum$GitSignatureState fromJson$Enum$GitSignatureState(String value) {
  switch (value) {
    case r'VALID':
      return Enum$GitSignatureState.VALID;
    case r'INVALID':
      return Enum$GitSignatureState.INVALID;
    case r'MALFORMED_SIG':
      return Enum$GitSignatureState.MALFORMED_SIG;
    case r'UNKNOWN_KEY':
      return Enum$GitSignatureState.UNKNOWN_KEY;
    case r'BAD_EMAIL':
      return Enum$GitSignatureState.BAD_EMAIL;
    case r'UNVERIFIED_EMAIL':
      return Enum$GitSignatureState.UNVERIFIED_EMAIL;
    case r'NO_USER':
      return Enum$GitSignatureState.NO_USER;
    case r'UNKNOWN_SIG_TYPE':
      return Enum$GitSignatureState.UNKNOWN_SIG_TYPE;
    case r'UNSIGNED':
      return Enum$GitSignatureState.UNSIGNED;
    case r'GPGVERIFY_UNAVAILABLE':
      return Enum$GitSignatureState.GPGVERIFY_UNAVAILABLE;
    case r'GPGVERIFY_ERROR':
      return Enum$GitSignatureState.GPGVERIFY_ERROR;
    case r'NOT_SIGNING_KEY':
      return Enum$GitSignatureState.NOT_SIGNING_KEY;
    case r'EXPIRED_KEY':
      return Enum$GitSignatureState.EXPIRED_KEY;
    case r'OCSP_PENDING':
      return Enum$GitSignatureState.OCSP_PENDING;
    case r'OCSP_ERROR':
      return Enum$GitSignatureState.OCSP_ERROR;
    case r'BAD_CERT':
      return Enum$GitSignatureState.BAD_CERT;
    case r'OCSP_REVOKED':
      return Enum$GitSignatureState.OCSP_REVOKED;
    default:
      return Enum$GitSignatureState.$unknown;
  }
}

enum Enum$IdentityProviderConfigurationState {
  ENFORCED,
  CONFIGURED,
  UNCONFIGURED,
  $unknown
}

String toJson$Enum$IdentityProviderConfigurationState(
    Enum$IdentityProviderConfigurationState e) {
  switch (e) {
    case Enum$IdentityProviderConfigurationState.ENFORCED:
      return r'ENFORCED';
    case Enum$IdentityProviderConfigurationState.CONFIGURED:
      return r'CONFIGURED';
    case Enum$IdentityProviderConfigurationState.UNCONFIGURED:
      return r'UNCONFIGURED';
    case Enum$IdentityProviderConfigurationState.$unknown:
      return r'$unknown';
  }
}

Enum$IdentityProviderConfigurationState
    fromJson$Enum$IdentityProviderConfigurationState(String value) {
  switch (value) {
    case r'ENFORCED':
      return Enum$IdentityProviderConfigurationState.ENFORCED;
    case r'CONFIGURED':
      return Enum$IdentityProviderConfigurationState.CONFIGURED;
    case r'UNCONFIGURED':
      return Enum$IdentityProviderConfigurationState.UNCONFIGURED;
    default:
      return Enum$IdentityProviderConfigurationState.$unknown;
  }
}

enum Enum$IpAllowListEnabledSettingValue { ENABLED, DISABLED, $unknown }

String toJson$Enum$IpAllowListEnabledSettingValue(
    Enum$IpAllowListEnabledSettingValue e) {
  switch (e) {
    case Enum$IpAllowListEnabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$IpAllowListEnabledSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$IpAllowListEnabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$IpAllowListEnabledSettingValue
    fromJson$Enum$IpAllowListEnabledSettingValue(String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$IpAllowListEnabledSettingValue.ENABLED;
    case r'DISABLED':
      return Enum$IpAllowListEnabledSettingValue.DISABLED;
    default:
      return Enum$IpAllowListEnabledSettingValue.$unknown;
  }
}

enum Enum$IpAllowListEntryOrderField { CREATED_AT, ALLOW_LIST_VALUE, $unknown }

String toJson$Enum$IpAllowListEntryOrderField(
    Enum$IpAllowListEntryOrderField e) {
  switch (e) {
    case Enum$IpAllowListEntryOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$IpAllowListEntryOrderField.ALLOW_LIST_VALUE:
      return r'ALLOW_LIST_VALUE';
    case Enum$IpAllowListEntryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$IpAllowListEntryOrderField fromJson$Enum$IpAllowListEntryOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$IpAllowListEntryOrderField.CREATED_AT;
    case r'ALLOW_LIST_VALUE':
      return Enum$IpAllowListEntryOrderField.ALLOW_LIST_VALUE;
    default:
      return Enum$IpAllowListEntryOrderField.$unknown;
  }
}

enum Enum$IpAllowListForInstalledAppsEnabledSettingValue {
  ENABLED,
  DISABLED,
  $unknown
}

String toJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(
    Enum$IpAllowListForInstalledAppsEnabledSettingValue e) {
  switch (e) {
    case Enum$IpAllowListForInstalledAppsEnabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$IpAllowListForInstalledAppsEnabledSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$IpAllowListForInstalledAppsEnabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$IpAllowListForInstalledAppsEnabledSettingValue
    fromJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$IpAllowListForInstalledAppsEnabledSettingValue.ENABLED;
    case r'DISABLED':
      return Enum$IpAllowListForInstalledAppsEnabledSettingValue.DISABLED;
    default:
      return Enum$IpAllowListForInstalledAppsEnabledSettingValue.$unknown;
  }
}

enum Enum$IssueClosedStateReason { COMPLETED, NOT_PLANNED, $unknown }

String toJson$Enum$IssueClosedStateReason(Enum$IssueClosedStateReason e) {
  switch (e) {
    case Enum$IssueClosedStateReason.COMPLETED:
      return r'COMPLETED';
    case Enum$IssueClosedStateReason.NOT_PLANNED:
      return r'NOT_PLANNED';
    case Enum$IssueClosedStateReason.$unknown:
      return r'$unknown';
  }
}

Enum$IssueClosedStateReason fromJson$Enum$IssueClosedStateReason(String value) {
  switch (value) {
    case r'COMPLETED':
      return Enum$IssueClosedStateReason.COMPLETED;
    case r'NOT_PLANNED':
      return Enum$IssueClosedStateReason.NOT_PLANNED;
    default:
      return Enum$IssueClosedStateReason.$unknown;
  }
}

enum Enum$IssueCommentOrderField { UPDATED_AT, $unknown }

String toJson$Enum$IssueCommentOrderField(Enum$IssueCommentOrderField e) {
  switch (e) {
    case Enum$IssueCommentOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$IssueCommentOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$IssueCommentOrderField fromJson$Enum$IssueCommentOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$IssueCommentOrderField.UPDATED_AT;
    default:
      return Enum$IssueCommentOrderField.$unknown;
  }
}

enum Enum$IssueOrderField { CREATED_AT, UPDATED_AT, COMMENTS, $unknown }

String toJson$Enum$IssueOrderField(Enum$IssueOrderField e) {
  switch (e) {
    case Enum$IssueOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$IssueOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$IssueOrderField.COMMENTS:
      return r'COMMENTS';
    case Enum$IssueOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$IssueOrderField fromJson$Enum$IssueOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$IssueOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$IssueOrderField.UPDATED_AT;
    case r'COMMENTS':
      return Enum$IssueOrderField.COMMENTS;
    default:
      return Enum$IssueOrderField.$unknown;
  }
}

enum Enum$IssueState { OPEN, CLOSED, $unknown }

String toJson$Enum$IssueState(Enum$IssueState e) {
  switch (e) {
    case Enum$IssueState.OPEN:
      return r'OPEN';
    case Enum$IssueState.CLOSED:
      return r'CLOSED';
    case Enum$IssueState.$unknown:
      return r'$unknown';
  }
}

Enum$IssueState fromJson$Enum$IssueState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$IssueState.OPEN;
    case r'CLOSED':
      return Enum$IssueState.CLOSED;
    default:
      return Enum$IssueState.$unknown;
  }
}

enum Enum$IssueStateReason { REOPENED, NOT_PLANNED, COMPLETED, $unknown }

String toJson$Enum$IssueStateReason(Enum$IssueStateReason e) {
  switch (e) {
    case Enum$IssueStateReason.REOPENED:
      return r'REOPENED';
    case Enum$IssueStateReason.NOT_PLANNED:
      return r'NOT_PLANNED';
    case Enum$IssueStateReason.COMPLETED:
      return r'COMPLETED';
    case Enum$IssueStateReason.$unknown:
      return r'$unknown';
  }
}

Enum$IssueStateReason fromJson$Enum$IssueStateReason(String value) {
  switch (value) {
    case r'REOPENED':
      return Enum$IssueStateReason.REOPENED;
    case r'NOT_PLANNED':
      return Enum$IssueStateReason.NOT_PLANNED;
    case r'COMPLETED':
      return Enum$IssueStateReason.COMPLETED;
    default:
      return Enum$IssueStateReason.$unknown;
  }
}

enum Enum$IssueTimelineItemsItemType {
  ISSUE_COMMENT,
  CROSS_REFERENCED_EVENT,
  ADDED_TO_PROJECT_EVENT,
  ASSIGNED_EVENT,
  CLOSED_EVENT,
  COMMENT_DELETED_EVENT,
  CONNECTED_EVENT,
  CONVERTED_NOTE_TO_ISSUE_EVENT,
  CONVERTED_TO_DISCUSSION_EVENT,
  DEMILESTONED_EVENT,
  DISCONNECTED_EVENT,
  LABELED_EVENT,
  LOCKED_EVENT,
  MARKED_AS_DUPLICATE_EVENT,
  MENTIONED_EVENT,
  MILESTONED_EVENT,
  MOVED_COLUMNS_IN_PROJECT_EVENT,
  PINNED_EVENT,
  REFERENCED_EVENT,
  REMOVED_FROM_PROJECT_EVENT,
  RENAMED_TITLE_EVENT,
  REOPENED_EVENT,
  SUBSCRIBED_EVENT,
  TRANSFERRED_EVENT,
  UNASSIGNED_EVENT,
  UNLABELED_EVENT,
  UNLOCKED_EVENT,
  USER_BLOCKED_EVENT,
  UNMARKED_AS_DUPLICATE_EVENT,
  UNPINNED_EVENT,
  UNSUBSCRIBED_EVENT,
  $unknown
}

String toJson$Enum$IssueTimelineItemsItemType(
    Enum$IssueTimelineItemsItemType e) {
  switch (e) {
    case Enum$IssueTimelineItemsItemType.ISSUE_COMMENT:
      return r'ISSUE_COMMENT';
    case Enum$IssueTimelineItemsItemType.CROSS_REFERENCED_EVENT:
      return r'CROSS_REFERENCED_EVENT';
    case Enum$IssueTimelineItemsItemType.ADDED_TO_PROJECT_EVENT:
      return r'ADDED_TO_PROJECT_EVENT';
    case Enum$IssueTimelineItemsItemType.ASSIGNED_EVENT:
      return r'ASSIGNED_EVENT';
    case Enum$IssueTimelineItemsItemType.CLOSED_EVENT:
      return r'CLOSED_EVENT';
    case Enum$IssueTimelineItemsItemType.COMMENT_DELETED_EVENT:
      return r'COMMENT_DELETED_EVENT';
    case Enum$IssueTimelineItemsItemType.CONNECTED_EVENT:
      return r'CONNECTED_EVENT';
    case Enum$IssueTimelineItemsItemType.CONVERTED_NOTE_TO_ISSUE_EVENT:
      return r'CONVERTED_NOTE_TO_ISSUE_EVENT';
    case Enum$IssueTimelineItemsItemType.CONVERTED_TO_DISCUSSION_EVENT:
      return r'CONVERTED_TO_DISCUSSION_EVENT';
    case Enum$IssueTimelineItemsItemType.DEMILESTONED_EVENT:
      return r'DEMILESTONED_EVENT';
    case Enum$IssueTimelineItemsItemType.DISCONNECTED_EVENT:
      return r'DISCONNECTED_EVENT';
    case Enum$IssueTimelineItemsItemType.LABELED_EVENT:
      return r'LABELED_EVENT';
    case Enum$IssueTimelineItemsItemType.LOCKED_EVENT:
      return r'LOCKED_EVENT';
    case Enum$IssueTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT:
      return r'MARKED_AS_DUPLICATE_EVENT';
    case Enum$IssueTimelineItemsItemType.MENTIONED_EVENT:
      return r'MENTIONED_EVENT';
    case Enum$IssueTimelineItemsItemType.MILESTONED_EVENT:
      return r'MILESTONED_EVENT';
    case Enum$IssueTimelineItemsItemType.MOVED_COLUMNS_IN_PROJECT_EVENT:
      return r'MOVED_COLUMNS_IN_PROJECT_EVENT';
    case Enum$IssueTimelineItemsItemType.PINNED_EVENT:
      return r'PINNED_EVENT';
    case Enum$IssueTimelineItemsItemType.REFERENCED_EVENT:
      return r'REFERENCED_EVENT';
    case Enum$IssueTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT:
      return r'REMOVED_FROM_PROJECT_EVENT';
    case Enum$IssueTimelineItemsItemType.RENAMED_TITLE_EVENT:
      return r'RENAMED_TITLE_EVENT';
    case Enum$IssueTimelineItemsItemType.REOPENED_EVENT:
      return r'REOPENED_EVENT';
    case Enum$IssueTimelineItemsItemType.SUBSCRIBED_EVENT:
      return r'SUBSCRIBED_EVENT';
    case Enum$IssueTimelineItemsItemType.TRANSFERRED_EVENT:
      return r'TRANSFERRED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNASSIGNED_EVENT:
      return r'UNASSIGNED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNLABELED_EVENT:
      return r'UNLABELED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNLOCKED_EVENT:
      return r'UNLOCKED_EVENT';
    case Enum$IssueTimelineItemsItemType.USER_BLOCKED_EVENT:
      return r'USER_BLOCKED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT:
      return r'UNMARKED_AS_DUPLICATE_EVENT';
    case Enum$IssueTimelineItemsItemType.UNPINNED_EVENT:
      return r'UNPINNED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNSUBSCRIBED_EVENT:
      return r'UNSUBSCRIBED_EVENT';
    case Enum$IssueTimelineItemsItemType.$unknown:
      return r'$unknown';
  }
}

Enum$IssueTimelineItemsItemType fromJson$Enum$IssueTimelineItemsItemType(
    String value) {
  switch (value) {
    case r'ISSUE_COMMENT':
      return Enum$IssueTimelineItemsItemType.ISSUE_COMMENT;
    case r'CROSS_REFERENCED_EVENT':
      return Enum$IssueTimelineItemsItemType.CROSS_REFERENCED_EVENT;
    case r'ADDED_TO_PROJECT_EVENT':
      return Enum$IssueTimelineItemsItemType.ADDED_TO_PROJECT_EVENT;
    case r'ASSIGNED_EVENT':
      return Enum$IssueTimelineItemsItemType.ASSIGNED_EVENT;
    case r'CLOSED_EVENT':
      return Enum$IssueTimelineItemsItemType.CLOSED_EVENT;
    case r'COMMENT_DELETED_EVENT':
      return Enum$IssueTimelineItemsItemType.COMMENT_DELETED_EVENT;
    case r'CONNECTED_EVENT':
      return Enum$IssueTimelineItemsItemType.CONNECTED_EVENT;
    case r'CONVERTED_NOTE_TO_ISSUE_EVENT':
      return Enum$IssueTimelineItemsItemType.CONVERTED_NOTE_TO_ISSUE_EVENT;
    case r'CONVERTED_TO_DISCUSSION_EVENT':
      return Enum$IssueTimelineItemsItemType.CONVERTED_TO_DISCUSSION_EVENT;
    case r'DEMILESTONED_EVENT':
      return Enum$IssueTimelineItemsItemType.DEMILESTONED_EVENT;
    case r'DISCONNECTED_EVENT':
      return Enum$IssueTimelineItemsItemType.DISCONNECTED_EVENT;
    case r'LABELED_EVENT':
      return Enum$IssueTimelineItemsItemType.LABELED_EVENT;
    case r'LOCKED_EVENT':
      return Enum$IssueTimelineItemsItemType.LOCKED_EVENT;
    case r'MARKED_AS_DUPLICATE_EVENT':
      return Enum$IssueTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT;
    case r'MENTIONED_EVENT':
      return Enum$IssueTimelineItemsItemType.MENTIONED_EVENT;
    case r'MILESTONED_EVENT':
      return Enum$IssueTimelineItemsItemType.MILESTONED_EVENT;
    case r'MOVED_COLUMNS_IN_PROJECT_EVENT':
      return Enum$IssueTimelineItemsItemType.MOVED_COLUMNS_IN_PROJECT_EVENT;
    case r'PINNED_EVENT':
      return Enum$IssueTimelineItemsItemType.PINNED_EVENT;
    case r'REFERENCED_EVENT':
      return Enum$IssueTimelineItemsItemType.REFERENCED_EVENT;
    case r'REMOVED_FROM_PROJECT_EVENT':
      return Enum$IssueTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT;
    case r'RENAMED_TITLE_EVENT':
      return Enum$IssueTimelineItemsItemType.RENAMED_TITLE_EVENT;
    case r'REOPENED_EVENT':
      return Enum$IssueTimelineItemsItemType.REOPENED_EVENT;
    case r'SUBSCRIBED_EVENT':
      return Enum$IssueTimelineItemsItemType.SUBSCRIBED_EVENT;
    case r'TRANSFERRED_EVENT':
      return Enum$IssueTimelineItemsItemType.TRANSFERRED_EVENT;
    case r'UNASSIGNED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNASSIGNED_EVENT;
    case r'UNLABELED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNLABELED_EVENT;
    case r'UNLOCKED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNLOCKED_EVENT;
    case r'USER_BLOCKED_EVENT':
      return Enum$IssueTimelineItemsItemType.USER_BLOCKED_EVENT;
    case r'UNMARKED_AS_DUPLICATE_EVENT':
      return Enum$IssueTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT;
    case r'UNPINNED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNPINNED_EVENT;
    case r'UNSUBSCRIBED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNSUBSCRIBED_EVENT;
    default:
      return Enum$IssueTimelineItemsItemType.$unknown;
  }
}

enum Enum$LabelOrderField { NAME, CREATED_AT, $unknown }

String toJson$Enum$LabelOrderField(Enum$LabelOrderField e) {
  switch (e) {
    case Enum$LabelOrderField.NAME:
      return r'NAME';
    case Enum$LabelOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$LabelOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$LabelOrderField fromJson$Enum$LabelOrderField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$LabelOrderField.NAME;
    case r'CREATED_AT':
      return Enum$LabelOrderField.CREATED_AT;
    default:
      return Enum$LabelOrderField.$unknown;
  }
}

enum Enum$LanguageOrderField { SIZE, $unknown }

String toJson$Enum$LanguageOrderField(Enum$LanguageOrderField e) {
  switch (e) {
    case Enum$LanguageOrderField.SIZE:
      return r'SIZE';
    case Enum$LanguageOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$LanguageOrderField fromJson$Enum$LanguageOrderField(String value) {
  switch (value) {
    case r'SIZE':
      return Enum$LanguageOrderField.SIZE;
    default:
      return Enum$LanguageOrderField.$unknown;
  }
}

enum Enum$LockReason { OFF_TOPIC, TOO_HEATED, RESOLVED, SPAM, $unknown }

String toJson$Enum$LockReason(Enum$LockReason e) {
  switch (e) {
    case Enum$LockReason.OFF_TOPIC:
      return r'OFF_TOPIC';
    case Enum$LockReason.TOO_HEATED:
      return r'TOO_HEATED';
    case Enum$LockReason.RESOLVED:
      return r'RESOLVED';
    case Enum$LockReason.SPAM:
      return r'SPAM';
    case Enum$LockReason.$unknown:
      return r'$unknown';
  }
}

Enum$LockReason fromJson$Enum$LockReason(String value) {
  switch (value) {
    case r'OFF_TOPIC':
      return Enum$LockReason.OFF_TOPIC;
    case r'TOO_HEATED':
      return Enum$LockReason.TOO_HEATED;
    case r'RESOLVED':
      return Enum$LockReason.RESOLVED;
    case r'SPAM':
      return Enum$LockReason.SPAM;
    default:
      return Enum$LockReason.$unknown;
  }
}

enum Enum$MergeableState { MERGEABLE, CONFLICTING, UNKNOWN, $unknown }

String toJson$Enum$MergeableState(Enum$MergeableState e) {
  switch (e) {
    case Enum$MergeableState.MERGEABLE:
      return r'MERGEABLE';
    case Enum$MergeableState.CONFLICTING:
      return r'CONFLICTING';
    case Enum$MergeableState.UNKNOWN:
      return r'UNKNOWN';
    case Enum$MergeableState.$unknown:
      return r'$unknown';
  }
}

Enum$MergeableState fromJson$Enum$MergeableState(String value) {
  switch (value) {
    case r'MERGEABLE':
      return Enum$MergeableState.MERGEABLE;
    case r'CONFLICTING':
      return Enum$MergeableState.CONFLICTING;
    case r'UNKNOWN':
      return Enum$MergeableState.UNKNOWN;
    default:
      return Enum$MergeableState.$unknown;
  }
}

enum Enum$MergeCommitMessage { PR_TITLE, PR_BODY, BLANK, $unknown }

String toJson$Enum$MergeCommitMessage(Enum$MergeCommitMessage e) {
  switch (e) {
    case Enum$MergeCommitMessage.PR_TITLE:
      return r'PR_TITLE';
    case Enum$MergeCommitMessage.PR_BODY:
      return r'PR_BODY';
    case Enum$MergeCommitMessage.BLANK:
      return r'BLANK';
    case Enum$MergeCommitMessage.$unknown:
      return r'$unknown';
  }
}

Enum$MergeCommitMessage fromJson$Enum$MergeCommitMessage(String value) {
  switch (value) {
    case r'PR_TITLE':
      return Enum$MergeCommitMessage.PR_TITLE;
    case r'PR_BODY':
      return Enum$MergeCommitMessage.PR_BODY;
    case r'BLANK':
      return Enum$MergeCommitMessage.BLANK;
    default:
      return Enum$MergeCommitMessage.$unknown;
  }
}

enum Enum$MergeCommitTitle { PR_TITLE, MERGE_MESSAGE, $unknown }

String toJson$Enum$MergeCommitTitle(Enum$MergeCommitTitle e) {
  switch (e) {
    case Enum$MergeCommitTitle.PR_TITLE:
      return r'PR_TITLE';
    case Enum$MergeCommitTitle.MERGE_MESSAGE:
      return r'MERGE_MESSAGE';
    case Enum$MergeCommitTitle.$unknown:
      return r'$unknown';
  }
}

Enum$MergeCommitTitle fromJson$Enum$MergeCommitTitle(String value) {
  switch (value) {
    case r'PR_TITLE':
      return Enum$MergeCommitTitle.PR_TITLE;
    case r'MERGE_MESSAGE':
      return Enum$MergeCommitTitle.MERGE_MESSAGE;
    default:
      return Enum$MergeCommitTitle.$unknown;
  }
}

enum Enum$MigrationSourceType {
  AZURE_DEVOPS,
  BITBUCKET_SERVER,
  GITHUB_ARCHIVE,
  $unknown
}

String toJson$Enum$MigrationSourceType(Enum$MigrationSourceType e) {
  switch (e) {
    case Enum$MigrationSourceType.AZURE_DEVOPS:
      return r'AZURE_DEVOPS';
    case Enum$MigrationSourceType.BITBUCKET_SERVER:
      return r'BITBUCKET_SERVER';
    case Enum$MigrationSourceType.GITHUB_ARCHIVE:
      return r'GITHUB_ARCHIVE';
    case Enum$MigrationSourceType.$unknown:
      return r'$unknown';
  }
}

Enum$MigrationSourceType fromJson$Enum$MigrationSourceType(String value) {
  switch (value) {
    case r'AZURE_DEVOPS':
      return Enum$MigrationSourceType.AZURE_DEVOPS;
    case r'BITBUCKET_SERVER':
      return Enum$MigrationSourceType.BITBUCKET_SERVER;
    case r'GITHUB_ARCHIVE':
      return Enum$MigrationSourceType.GITHUB_ARCHIVE;
    default:
      return Enum$MigrationSourceType.$unknown;
  }
}

enum Enum$MigrationState {
  NOT_STARTED,
  QUEUED,
  IN_PROGRESS,
  SUCCEEDED,
  FAILED,
  PENDING_VALIDATION,
  FAILED_VALIDATION,
  $unknown
}

String toJson$Enum$MigrationState(Enum$MigrationState e) {
  switch (e) {
    case Enum$MigrationState.NOT_STARTED:
      return r'NOT_STARTED';
    case Enum$MigrationState.QUEUED:
      return r'QUEUED';
    case Enum$MigrationState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$MigrationState.SUCCEEDED:
      return r'SUCCEEDED';
    case Enum$MigrationState.FAILED:
      return r'FAILED';
    case Enum$MigrationState.PENDING_VALIDATION:
      return r'PENDING_VALIDATION';
    case Enum$MigrationState.FAILED_VALIDATION:
      return r'FAILED_VALIDATION';
    case Enum$MigrationState.$unknown:
      return r'$unknown';
  }
}

Enum$MigrationState fromJson$Enum$MigrationState(String value) {
  switch (value) {
    case r'NOT_STARTED':
      return Enum$MigrationState.NOT_STARTED;
    case r'QUEUED':
      return Enum$MigrationState.QUEUED;
    case r'IN_PROGRESS':
      return Enum$MigrationState.IN_PROGRESS;
    case r'SUCCEEDED':
      return Enum$MigrationState.SUCCEEDED;
    case r'FAILED':
      return Enum$MigrationState.FAILED;
    case r'PENDING_VALIDATION':
      return Enum$MigrationState.PENDING_VALIDATION;
    case r'FAILED_VALIDATION':
      return Enum$MigrationState.FAILED_VALIDATION;
    default:
      return Enum$MigrationState.$unknown;
  }
}

enum Enum$MilestoneOrderField {
  DUE_DATE,
  CREATED_AT,
  UPDATED_AT,
  NUMBER,
  $unknown
}

String toJson$Enum$MilestoneOrderField(Enum$MilestoneOrderField e) {
  switch (e) {
    case Enum$MilestoneOrderField.DUE_DATE:
      return r'DUE_DATE';
    case Enum$MilestoneOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$MilestoneOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$MilestoneOrderField.NUMBER:
      return r'NUMBER';
    case Enum$MilestoneOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$MilestoneOrderField fromJson$Enum$MilestoneOrderField(String value) {
  switch (value) {
    case r'DUE_DATE':
      return Enum$MilestoneOrderField.DUE_DATE;
    case r'CREATED_AT':
      return Enum$MilestoneOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$MilestoneOrderField.UPDATED_AT;
    case r'NUMBER':
      return Enum$MilestoneOrderField.NUMBER;
    default:
      return Enum$MilestoneOrderField.$unknown;
  }
}

enum Enum$MilestoneState { OPEN, CLOSED, $unknown }

String toJson$Enum$MilestoneState(Enum$MilestoneState e) {
  switch (e) {
    case Enum$MilestoneState.OPEN:
      return r'OPEN';
    case Enum$MilestoneState.CLOSED:
      return r'CLOSED';
    case Enum$MilestoneState.$unknown:
      return r'$unknown';
  }
}

Enum$MilestoneState fromJson$Enum$MilestoneState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$MilestoneState.OPEN;
    case r'CLOSED':
      return Enum$MilestoneState.CLOSED;
    default:
      return Enum$MilestoneState.$unknown;
  }
}

enum Enum$NotificationRestrictionSettingValue { ENABLED, DISABLED, $unknown }

String toJson$Enum$NotificationRestrictionSettingValue(
    Enum$NotificationRestrictionSettingValue e) {
  switch (e) {
    case Enum$NotificationRestrictionSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$NotificationRestrictionSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$NotificationRestrictionSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$NotificationRestrictionSettingValue
    fromJson$Enum$NotificationRestrictionSettingValue(String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$NotificationRestrictionSettingValue.ENABLED;
    case r'DISABLED':
      return Enum$NotificationRestrictionSettingValue.DISABLED;
    default:
      return Enum$NotificationRestrictionSettingValue.$unknown;
  }
}

enum Enum$OauthApplicationCreateAuditEntryState {
  ACTIVE,
  SUSPENDED,
  PENDING_DELETION,
  $unknown
}

String toJson$Enum$OauthApplicationCreateAuditEntryState(
    Enum$OauthApplicationCreateAuditEntryState e) {
  switch (e) {
    case Enum$OauthApplicationCreateAuditEntryState.ACTIVE:
      return r'ACTIVE';
    case Enum$OauthApplicationCreateAuditEntryState.SUSPENDED:
      return r'SUSPENDED';
    case Enum$OauthApplicationCreateAuditEntryState.PENDING_DELETION:
      return r'PENDING_DELETION';
    case Enum$OauthApplicationCreateAuditEntryState.$unknown:
      return r'$unknown';
  }
}

Enum$OauthApplicationCreateAuditEntryState
    fromJson$Enum$OauthApplicationCreateAuditEntryState(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$OauthApplicationCreateAuditEntryState.ACTIVE;
    case r'SUSPENDED':
      return Enum$OauthApplicationCreateAuditEntryState.SUSPENDED;
    case r'PENDING_DELETION':
      return Enum$OauthApplicationCreateAuditEntryState.PENDING_DELETION;
    default:
      return Enum$OauthApplicationCreateAuditEntryState.$unknown;
  }
}

enum Enum$OIDCProviderType { AAD, $unknown }

String toJson$Enum$OIDCProviderType(Enum$OIDCProviderType e) {
  switch (e) {
    case Enum$OIDCProviderType.AAD:
      return r'AAD';
    case Enum$OIDCProviderType.$unknown:
      return r'$unknown';
  }
}

Enum$OIDCProviderType fromJson$Enum$OIDCProviderType(String value) {
  switch (value) {
    case r'AAD':
      return Enum$OIDCProviderType.AAD;
    default:
      return Enum$OIDCProviderType.$unknown;
  }
}

enum Enum$OperationType {
  ACCESS,
  AUTHENTICATION,
  CREATE,
  MODIFY,
  REMOVE,
  RESTORE,
  TRANSFER,
  $unknown
}

String toJson$Enum$OperationType(Enum$OperationType e) {
  switch (e) {
    case Enum$OperationType.ACCESS:
      return r'ACCESS';
    case Enum$OperationType.AUTHENTICATION:
      return r'AUTHENTICATION';
    case Enum$OperationType.CREATE:
      return r'CREATE';
    case Enum$OperationType.MODIFY:
      return r'MODIFY';
    case Enum$OperationType.REMOVE:
      return r'REMOVE';
    case Enum$OperationType.RESTORE:
      return r'RESTORE';
    case Enum$OperationType.TRANSFER:
      return r'TRANSFER';
    case Enum$OperationType.$unknown:
      return r'$unknown';
  }
}

Enum$OperationType fromJson$Enum$OperationType(String value) {
  switch (value) {
    case r'ACCESS':
      return Enum$OperationType.ACCESS;
    case r'AUTHENTICATION':
      return Enum$OperationType.AUTHENTICATION;
    case r'CREATE':
      return Enum$OperationType.CREATE;
    case r'MODIFY':
      return Enum$OperationType.MODIFY;
    case r'REMOVE':
      return Enum$OperationType.REMOVE;
    case r'RESTORE':
      return Enum$OperationType.RESTORE;
    case r'TRANSFER':
      return Enum$OperationType.TRANSFER;
    default:
      return Enum$OperationType.$unknown;
  }
}

enum Enum$OrderDirection { ASC, DESC, $unknown }

String toJson$Enum$OrderDirection(Enum$OrderDirection e) {
  switch (e) {
    case Enum$OrderDirection.ASC:
      return r'ASC';
    case Enum$OrderDirection.DESC:
      return r'DESC';
    case Enum$OrderDirection.$unknown:
      return r'$unknown';
  }
}

Enum$OrderDirection fromJson$Enum$OrderDirection(String value) {
  switch (value) {
    case r'ASC':
      return Enum$OrderDirection.ASC;
    case r'DESC':
      return Enum$OrderDirection.DESC;
    default:
      return Enum$OrderDirection.$unknown;
  }
}

enum Enum$OrgAddMemberAuditEntryPermission { READ, ADMIN, $unknown }

String toJson$Enum$OrgAddMemberAuditEntryPermission(
    Enum$OrgAddMemberAuditEntryPermission e) {
  switch (e) {
    case Enum$OrgAddMemberAuditEntryPermission.READ:
      return r'READ';
    case Enum$OrgAddMemberAuditEntryPermission.ADMIN:
      return r'ADMIN';
    case Enum$OrgAddMemberAuditEntryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$OrgAddMemberAuditEntryPermission
    fromJson$Enum$OrgAddMemberAuditEntryPermission(String value) {
  switch (value) {
    case r'READ':
      return Enum$OrgAddMemberAuditEntryPermission.READ;
    case r'ADMIN':
      return Enum$OrgAddMemberAuditEntryPermission.ADMIN;
    default:
      return Enum$OrgAddMemberAuditEntryPermission.$unknown;
  }
}

enum Enum$OrganizationInvitationRole {
  DIRECT_MEMBER,
  ADMIN,
  BILLING_MANAGER,
  REINSTATE,
  $unknown
}

String toJson$Enum$OrganizationInvitationRole(
    Enum$OrganizationInvitationRole e) {
  switch (e) {
    case Enum$OrganizationInvitationRole.DIRECT_MEMBER:
      return r'DIRECT_MEMBER';
    case Enum$OrganizationInvitationRole.ADMIN:
      return r'ADMIN';
    case Enum$OrganizationInvitationRole.BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$OrganizationInvitationRole.REINSTATE:
      return r'REINSTATE';
    case Enum$OrganizationInvitationRole.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationInvitationRole fromJson$Enum$OrganizationInvitationRole(
    String value) {
  switch (value) {
    case r'DIRECT_MEMBER':
      return Enum$OrganizationInvitationRole.DIRECT_MEMBER;
    case r'ADMIN':
      return Enum$OrganizationInvitationRole.ADMIN;
    case r'BILLING_MANAGER':
      return Enum$OrganizationInvitationRole.BILLING_MANAGER;
    case r'REINSTATE':
      return Enum$OrganizationInvitationRole.REINSTATE;
    default:
      return Enum$OrganizationInvitationRole.$unknown;
  }
}

enum Enum$OrganizationInvitationType { USER, EMAIL, $unknown }

String toJson$Enum$OrganizationInvitationType(
    Enum$OrganizationInvitationType e) {
  switch (e) {
    case Enum$OrganizationInvitationType.USER:
      return r'USER';
    case Enum$OrganizationInvitationType.EMAIL:
      return r'EMAIL';
    case Enum$OrganizationInvitationType.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationInvitationType fromJson$Enum$OrganizationInvitationType(
    String value) {
  switch (value) {
    case r'USER':
      return Enum$OrganizationInvitationType.USER;
    case r'EMAIL':
      return Enum$OrganizationInvitationType.EMAIL;
    default:
      return Enum$OrganizationInvitationType.$unknown;
  }
}

enum Enum$OrganizationMemberRole { MEMBER, ADMIN, $unknown }

String toJson$Enum$OrganizationMemberRole(Enum$OrganizationMemberRole e) {
  switch (e) {
    case Enum$OrganizationMemberRole.MEMBER:
      return r'MEMBER';
    case Enum$OrganizationMemberRole.ADMIN:
      return r'ADMIN';
    case Enum$OrganizationMemberRole.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationMemberRole fromJson$Enum$OrganizationMemberRole(String value) {
  switch (value) {
    case r'MEMBER':
      return Enum$OrganizationMemberRole.MEMBER;
    case r'ADMIN':
      return Enum$OrganizationMemberRole.ADMIN;
    default:
      return Enum$OrganizationMemberRole.$unknown;
  }
}

enum Enum$OrganizationMembersCanCreateRepositoriesSettingValue {
  ALL,
  PRIVATE,
  INTERNAL,
  DISABLED,
  $unknown
}

String toJson$Enum$OrganizationMembersCanCreateRepositoriesSettingValue(
    Enum$OrganizationMembersCanCreateRepositoriesSettingValue e) {
  switch (e) {
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.ALL:
      return r'ALL';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.PRIVATE:
      return r'PRIVATE';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.INTERNAL:
      return r'INTERNAL';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationMembersCanCreateRepositoriesSettingValue
    fromJson$Enum$OrganizationMembersCanCreateRepositoriesSettingValue(
        String value) {
  switch (value) {
    case r'ALL':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.ALL;
    case r'PRIVATE':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.PRIVATE;
    case r'INTERNAL':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.INTERNAL;
    case r'DISABLED':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.DISABLED;
    default:
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.$unknown;
  }
}

enum Enum$OrganizationOrderField { CREATED_AT, LOGIN, $unknown }

String toJson$Enum$OrganizationOrderField(Enum$OrganizationOrderField e) {
  switch (e) {
    case Enum$OrganizationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$OrganizationOrderField.LOGIN:
      return r'LOGIN';
    case Enum$OrganizationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationOrderField fromJson$Enum$OrganizationOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$OrganizationOrderField.CREATED_AT;
    case r'LOGIN':
      return Enum$OrganizationOrderField.LOGIN;
    default:
      return Enum$OrganizationOrderField.$unknown;
  }
}

enum Enum$OrgCreateAuditEntryBillingPlan {
  FREE,
  BUSINESS,
  BUSINESS_PLUS,
  UNLIMITED,
  TIERED_PER_SEAT,
  $unknown
}

String toJson$Enum$OrgCreateAuditEntryBillingPlan(
    Enum$OrgCreateAuditEntryBillingPlan e) {
  switch (e) {
    case Enum$OrgCreateAuditEntryBillingPlan.FREE:
      return r'FREE';
    case Enum$OrgCreateAuditEntryBillingPlan.BUSINESS:
      return r'BUSINESS';
    case Enum$OrgCreateAuditEntryBillingPlan.BUSINESS_PLUS:
      return r'BUSINESS_PLUS';
    case Enum$OrgCreateAuditEntryBillingPlan.UNLIMITED:
      return r'UNLIMITED';
    case Enum$OrgCreateAuditEntryBillingPlan.TIERED_PER_SEAT:
      return r'TIERED_PER_SEAT';
    case Enum$OrgCreateAuditEntryBillingPlan.$unknown:
      return r'$unknown';
  }
}

Enum$OrgCreateAuditEntryBillingPlan
    fromJson$Enum$OrgCreateAuditEntryBillingPlan(String value) {
  switch (value) {
    case r'FREE':
      return Enum$OrgCreateAuditEntryBillingPlan.FREE;
    case r'BUSINESS':
      return Enum$OrgCreateAuditEntryBillingPlan.BUSINESS;
    case r'BUSINESS_PLUS':
      return Enum$OrgCreateAuditEntryBillingPlan.BUSINESS_PLUS;
    case r'UNLIMITED':
      return Enum$OrgCreateAuditEntryBillingPlan.UNLIMITED;
    case r'TIERED_PER_SEAT':
      return Enum$OrgCreateAuditEntryBillingPlan.TIERED_PER_SEAT;
    default:
      return Enum$OrgCreateAuditEntryBillingPlan.$unknown;
  }
}

enum Enum$OrgEnterpriseOwnerOrderField { LOGIN, $unknown }

String toJson$Enum$OrgEnterpriseOwnerOrderField(
    Enum$OrgEnterpriseOwnerOrderField e) {
  switch (e) {
    case Enum$OrgEnterpriseOwnerOrderField.LOGIN:
      return r'LOGIN';
    case Enum$OrgEnterpriseOwnerOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$OrgEnterpriseOwnerOrderField fromJson$Enum$OrgEnterpriseOwnerOrderField(
    String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$OrgEnterpriseOwnerOrderField.LOGIN;
    default:
      return Enum$OrgEnterpriseOwnerOrderField.$unknown;
  }
}

enum Enum$OrgRemoveBillingManagerAuditEntryReason {
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE,
  SAML_EXTERNAL_IDENTITY_MISSING,
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY,
  $unknown
}

String toJson$Enum$OrgRemoveBillingManagerAuditEntryReason(
    Enum$OrgRemoveBillingManagerAuditEntryReason e) {
  switch (e) {
    case Enum$OrgRemoveBillingManagerAuditEntryReason
        .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE:
      return r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';
    case Enum$OrgRemoveBillingManagerAuditEntryReason
        .SAML_EXTERNAL_IDENTITY_MISSING:
      return r'SAML_EXTERNAL_IDENTITY_MISSING';
    case Enum$OrgRemoveBillingManagerAuditEntryReason
        .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY:
      return r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY';
    case Enum$OrgRemoveBillingManagerAuditEntryReason.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveBillingManagerAuditEntryReason
    fromJson$Enum$OrgRemoveBillingManagerAuditEntryReason(String value) {
  switch (value) {
    case r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE':
      return Enum$OrgRemoveBillingManagerAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE;
    case r'SAML_EXTERNAL_IDENTITY_MISSING':
      return Enum$OrgRemoveBillingManagerAuditEntryReason
          .SAML_EXTERNAL_IDENTITY_MISSING;
    case r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY':
      return Enum$OrgRemoveBillingManagerAuditEntryReason
          .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY;
    default:
      return Enum$OrgRemoveBillingManagerAuditEntryReason.$unknown;
  }
}

enum Enum$OrgRemoveMemberAuditEntryMembershipType {
  SUSPENDED,
  DIRECT_MEMBER,
  ADMIN,
  BILLING_MANAGER,
  UNAFFILIATED,
  OUTSIDE_COLLABORATOR,
  $unknown
}

String toJson$Enum$OrgRemoveMemberAuditEntryMembershipType(
    Enum$OrgRemoveMemberAuditEntryMembershipType e) {
  switch (e) {
    case Enum$OrgRemoveMemberAuditEntryMembershipType.SUSPENDED:
      return r'SUSPENDED';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.DIRECT_MEMBER:
      return r'DIRECT_MEMBER';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.ADMIN:
      return r'ADMIN';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.OUTSIDE_COLLABORATOR:
      return r'OUTSIDE_COLLABORATOR';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveMemberAuditEntryMembershipType
    fromJson$Enum$OrgRemoveMemberAuditEntryMembershipType(String value) {
  switch (value) {
    case r'SUSPENDED':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.SUSPENDED;
    case r'DIRECT_MEMBER':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.DIRECT_MEMBER;
    case r'ADMIN':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.ADMIN;
    case r'BILLING_MANAGER':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.BILLING_MANAGER;
    case r'UNAFFILIATED':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.UNAFFILIATED;
    case r'OUTSIDE_COLLABORATOR':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.OUTSIDE_COLLABORATOR;
    default:
      return Enum$OrgRemoveMemberAuditEntryMembershipType.$unknown;
  }
}

enum Enum$OrgRemoveMemberAuditEntryReason {
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE,
  SAML_EXTERNAL_IDENTITY_MISSING,
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY,
  USER_ACCOUNT_DELETED,
  TWO_FACTOR_ACCOUNT_RECOVERY,
  $unknown
}

String toJson$Enum$OrgRemoveMemberAuditEntryReason(
    Enum$OrgRemoveMemberAuditEntryReason e) {
  switch (e) {
    case Enum$OrgRemoveMemberAuditEntryReason
        .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE:
      return r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';
    case Enum$OrgRemoveMemberAuditEntryReason.SAML_EXTERNAL_IDENTITY_MISSING:
      return r'SAML_EXTERNAL_IDENTITY_MISSING';
    case Enum$OrgRemoveMemberAuditEntryReason
        .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY:
      return r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY';
    case Enum$OrgRemoveMemberAuditEntryReason.USER_ACCOUNT_DELETED:
      return r'USER_ACCOUNT_DELETED';
    case Enum$OrgRemoveMemberAuditEntryReason.TWO_FACTOR_ACCOUNT_RECOVERY:
      return r'TWO_FACTOR_ACCOUNT_RECOVERY';
    case Enum$OrgRemoveMemberAuditEntryReason.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveMemberAuditEntryReason
    fromJson$Enum$OrgRemoveMemberAuditEntryReason(String value) {
  switch (value) {
    case r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE':
      return Enum$OrgRemoveMemberAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE;
    case r'SAML_EXTERNAL_IDENTITY_MISSING':
      return Enum$OrgRemoveMemberAuditEntryReason
          .SAML_EXTERNAL_IDENTITY_MISSING;
    case r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY':
      return Enum$OrgRemoveMemberAuditEntryReason
          .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY;
    case r'USER_ACCOUNT_DELETED':
      return Enum$OrgRemoveMemberAuditEntryReason.USER_ACCOUNT_DELETED;
    case r'TWO_FACTOR_ACCOUNT_RECOVERY':
      return Enum$OrgRemoveMemberAuditEntryReason.TWO_FACTOR_ACCOUNT_RECOVERY;
    default:
      return Enum$OrgRemoveMemberAuditEntryReason.$unknown;
  }
}

enum Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  OUTSIDE_COLLABORATOR,
  UNAFFILIATED,
  BILLING_MANAGER,
  $unknown
}

String toJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType(
    Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType e) {
  switch (e) {
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
        .OUTSIDE_COLLABORATOR:
      return r'OUTSIDE_COLLABORATOR';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
        .BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
    fromJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType(
        String value) {
  switch (value) {
    case r'OUTSIDE_COLLABORATOR':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
          .OUTSIDE_COLLABORATOR;
    case r'UNAFFILIATED':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
          .UNAFFILIATED;
    case r'BILLING_MANAGER':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
          .BILLING_MANAGER;
    default:
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType.$unknown;
  }
}

enum Enum$OrgRemoveOutsideCollaboratorAuditEntryReason {
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE,
  SAML_EXTERNAL_IDENTITY_MISSING,
  $unknown
}

String toJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryReason(
    Enum$OrgRemoveOutsideCollaboratorAuditEntryReason e) {
  switch (e) {
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
        .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE:
      return r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
        .SAML_EXTERNAL_IDENTITY_MISSING:
      return r'SAML_EXTERNAL_IDENTITY_MISSING';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryReason.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
    fromJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryReason(String value) {
  switch (value) {
    case r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE;
    case r'SAML_EXTERNAL_IDENTITY_MISSING':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
          .SAML_EXTERNAL_IDENTITY_MISSING;
    default:
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryReason.$unknown;
  }
}

enum Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  READ,
  WRITE,
  ADMIN,
  NONE,
  $unknown
}

String toJson$Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission(
    Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission e) {
  switch (e) {
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.READ:
      return r'READ';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.WRITE:
      return r'WRITE';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.ADMIN:
      return r'ADMIN';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.NONE:
      return r'NONE';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
    fromJson$Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission(
        String value) {
  switch (value) {
    case r'READ':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.READ;
    case r'WRITE':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
          .WRITE;
    case r'ADMIN':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
          .ADMIN;
    case r'NONE':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.NONE;
    default:
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
          .$unknown;
  }
}

enum Enum$OrgUpdateMemberAuditEntryPermission { READ, ADMIN, $unknown }

String toJson$Enum$OrgUpdateMemberAuditEntryPermission(
    Enum$OrgUpdateMemberAuditEntryPermission e) {
  switch (e) {
    case Enum$OrgUpdateMemberAuditEntryPermission.READ:
      return r'READ';
    case Enum$OrgUpdateMemberAuditEntryPermission.ADMIN:
      return r'ADMIN';
    case Enum$OrgUpdateMemberAuditEntryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$OrgUpdateMemberAuditEntryPermission
    fromJson$Enum$OrgUpdateMemberAuditEntryPermission(String value) {
  switch (value) {
    case r'READ':
      return Enum$OrgUpdateMemberAuditEntryPermission.READ;
    case r'ADMIN':
      return Enum$OrgUpdateMemberAuditEntryPermission.ADMIN;
    default:
      return Enum$OrgUpdateMemberAuditEntryPermission.$unknown;
  }
}

enum Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  ALL,
  PUBLIC,
  NONE,
  PRIVATE,
  INTERNAL,
  PUBLIC_INTERNAL,
  PRIVATE_INTERNAL,
  PUBLIC_PRIVATE,
  $unknown
}

String
    toJson$Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility(
        Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
            e) {
  switch (e) {
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .ALL:
      return r'ALL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .PUBLIC:
      return r'PUBLIC';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .NONE:
      return r'NONE';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .PRIVATE:
      return r'PRIVATE';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .INTERNAL:
      return r'INTERNAL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .PUBLIC_INTERNAL:
      return r'PUBLIC_INTERNAL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .PRIVATE_INTERNAL:
      return r'PRIVATE_INTERNAL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .PUBLIC_PRIVATE:
      return r'PUBLIC_PRIVATE';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .$unknown:
      return r'$unknown';
  }
}

Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
    fromJson$Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility(
        String value) {
  switch (value) {
    case r'ALL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .ALL;
    case r'PUBLIC':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC;
    case r'NONE':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .NONE;
    case r'PRIVATE':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PRIVATE;
    case r'INTERNAL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .INTERNAL;
    case r'PUBLIC_INTERNAL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC_INTERNAL;
    case r'PRIVATE_INTERNAL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PRIVATE_INTERNAL;
    case r'PUBLIC_PRIVATE':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC_PRIVATE;
    default:
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .$unknown;
  }
}

enum Enum$PackageFileOrderField { CREATED_AT, $unknown }

String toJson$Enum$PackageFileOrderField(Enum$PackageFileOrderField e) {
  switch (e) {
    case Enum$PackageFileOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PackageFileOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PackageFileOrderField fromJson$Enum$PackageFileOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PackageFileOrderField.CREATED_AT;
    default:
      return Enum$PackageFileOrderField.$unknown;
  }
}

enum Enum$PackageOrderField { CREATED_AT, $unknown }

String toJson$Enum$PackageOrderField(Enum$PackageOrderField e) {
  switch (e) {
    case Enum$PackageOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PackageOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PackageOrderField fromJson$Enum$PackageOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PackageOrderField.CREATED_AT;
    default:
      return Enum$PackageOrderField.$unknown;
  }
}

enum Enum$PackageType {
  NPM,
  RUBYGEMS,
  MAVEN,
  DOCKER,
  DEBIAN,
  NUGET,
  PYPI,
  $unknown
}

String toJson$Enum$PackageType(Enum$PackageType e) {
  switch (e) {
    case Enum$PackageType.NPM:
      return r'NPM';
    case Enum$PackageType.RUBYGEMS:
      return r'RUBYGEMS';
    case Enum$PackageType.MAVEN:
      return r'MAVEN';
    case Enum$PackageType.DOCKER:
      return r'DOCKER';
    case Enum$PackageType.DEBIAN:
      return r'DEBIAN';
    case Enum$PackageType.NUGET:
      return r'NUGET';
    case Enum$PackageType.PYPI:
      return r'PYPI';
    case Enum$PackageType.$unknown:
      return r'$unknown';
  }
}

Enum$PackageType fromJson$Enum$PackageType(String value) {
  switch (value) {
    case r'NPM':
      return Enum$PackageType.NPM;
    case r'RUBYGEMS':
      return Enum$PackageType.RUBYGEMS;
    case r'MAVEN':
      return Enum$PackageType.MAVEN;
    case r'DOCKER':
      return Enum$PackageType.DOCKER;
    case r'DEBIAN':
      return Enum$PackageType.DEBIAN;
    case r'NUGET':
      return Enum$PackageType.NUGET;
    case r'PYPI':
      return Enum$PackageType.PYPI;
    default:
      return Enum$PackageType.$unknown;
  }
}

enum Enum$PackageVersionOrderField { CREATED_AT, $unknown }

String toJson$Enum$PackageVersionOrderField(Enum$PackageVersionOrderField e) {
  switch (e) {
    case Enum$PackageVersionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PackageVersionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PackageVersionOrderField fromJson$Enum$PackageVersionOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PackageVersionOrderField.CREATED_AT;
    default:
      return Enum$PackageVersionOrderField.$unknown;
  }
}

enum Enum$PatchStatus {
  ADDED,
  DELETED,
  RENAMED,
  COPIED,
  MODIFIED,
  CHANGED,
  $unknown
}

String toJson$Enum$PatchStatus(Enum$PatchStatus e) {
  switch (e) {
    case Enum$PatchStatus.ADDED:
      return r'ADDED';
    case Enum$PatchStatus.DELETED:
      return r'DELETED';
    case Enum$PatchStatus.RENAMED:
      return r'RENAMED';
    case Enum$PatchStatus.COPIED:
      return r'COPIED';
    case Enum$PatchStatus.MODIFIED:
      return r'MODIFIED';
    case Enum$PatchStatus.CHANGED:
      return r'CHANGED';
    case Enum$PatchStatus.$unknown:
      return r'$unknown';
  }
}

Enum$PatchStatus fromJson$Enum$PatchStatus(String value) {
  switch (value) {
    case r'ADDED':
      return Enum$PatchStatus.ADDED;
    case r'DELETED':
      return Enum$PatchStatus.DELETED;
    case r'RENAMED':
      return Enum$PatchStatus.RENAMED;
    case r'COPIED':
      return Enum$PatchStatus.COPIED;
    case r'MODIFIED':
      return Enum$PatchStatus.MODIFIED;
    case r'CHANGED':
      return Enum$PatchStatus.CHANGED;
    default:
      return Enum$PatchStatus.$unknown;
  }
}

enum Enum$PinnableItemType {
  REPOSITORY,
  GIST,
  ISSUE,
  PROJECT,
  PULL_REQUEST,
  USER,
  ORGANIZATION,
  TEAM,
  $unknown
}

String toJson$Enum$PinnableItemType(Enum$PinnableItemType e) {
  switch (e) {
    case Enum$PinnableItemType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$PinnableItemType.GIST:
      return r'GIST';
    case Enum$PinnableItemType.ISSUE:
      return r'ISSUE';
    case Enum$PinnableItemType.PROJECT:
      return r'PROJECT';
    case Enum$PinnableItemType.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$PinnableItemType.USER:
      return r'USER';
    case Enum$PinnableItemType.ORGANIZATION:
      return r'ORGANIZATION';
    case Enum$PinnableItemType.TEAM:
      return r'TEAM';
    case Enum$PinnableItemType.$unknown:
      return r'$unknown';
  }
}

Enum$PinnableItemType fromJson$Enum$PinnableItemType(String value) {
  switch (value) {
    case r'REPOSITORY':
      return Enum$PinnableItemType.REPOSITORY;
    case r'GIST':
      return Enum$PinnableItemType.GIST;
    case r'ISSUE':
      return Enum$PinnableItemType.ISSUE;
    case r'PROJECT':
      return Enum$PinnableItemType.PROJECT;
    case r'PULL_REQUEST':
      return Enum$PinnableItemType.PULL_REQUEST;
    case r'USER':
      return Enum$PinnableItemType.USER;
    case r'ORGANIZATION':
      return Enum$PinnableItemType.ORGANIZATION;
    case r'TEAM':
      return Enum$PinnableItemType.TEAM;
    default:
      return Enum$PinnableItemType.$unknown;
  }
}

enum Enum$PinnedDiscussionGradient {
  RED_ORANGE,
  BLUE_MINT,
  BLUE_PURPLE,
  PINK_BLUE,
  PURPLE_CORAL,
  $unknown
}

String toJson$Enum$PinnedDiscussionGradient(Enum$PinnedDiscussionGradient e) {
  switch (e) {
    case Enum$PinnedDiscussionGradient.RED_ORANGE:
      return r'RED_ORANGE';
    case Enum$PinnedDiscussionGradient.BLUE_MINT:
      return r'BLUE_MINT';
    case Enum$PinnedDiscussionGradient.BLUE_PURPLE:
      return r'BLUE_PURPLE';
    case Enum$PinnedDiscussionGradient.PINK_BLUE:
      return r'PINK_BLUE';
    case Enum$PinnedDiscussionGradient.PURPLE_CORAL:
      return r'PURPLE_CORAL';
    case Enum$PinnedDiscussionGradient.$unknown:
      return r'$unknown';
  }
}

Enum$PinnedDiscussionGradient fromJson$Enum$PinnedDiscussionGradient(
    String value) {
  switch (value) {
    case r'RED_ORANGE':
      return Enum$PinnedDiscussionGradient.RED_ORANGE;
    case r'BLUE_MINT':
      return Enum$PinnedDiscussionGradient.BLUE_MINT;
    case r'BLUE_PURPLE':
      return Enum$PinnedDiscussionGradient.BLUE_PURPLE;
    case r'PINK_BLUE':
      return Enum$PinnedDiscussionGradient.PINK_BLUE;
    case r'PURPLE_CORAL':
      return Enum$PinnedDiscussionGradient.PURPLE_CORAL;
    default:
      return Enum$PinnedDiscussionGradient.$unknown;
  }
}

enum Enum$PinnedDiscussionPattern {
  DOT_FILL,
  PLUS,
  ZAP,
  CHEVRON_UP,
  DOT,
  HEART_FILL,
  $unknown
}

String toJson$Enum$PinnedDiscussionPattern(Enum$PinnedDiscussionPattern e) {
  switch (e) {
    case Enum$PinnedDiscussionPattern.DOT_FILL:
      return r'DOT_FILL';
    case Enum$PinnedDiscussionPattern.PLUS:
      return r'PLUS';
    case Enum$PinnedDiscussionPattern.ZAP:
      return r'ZAP';
    case Enum$PinnedDiscussionPattern.CHEVRON_UP:
      return r'CHEVRON_UP';
    case Enum$PinnedDiscussionPattern.DOT:
      return r'DOT';
    case Enum$PinnedDiscussionPattern.HEART_FILL:
      return r'HEART_FILL';
    case Enum$PinnedDiscussionPattern.$unknown:
      return r'$unknown';
  }
}

Enum$PinnedDiscussionPattern fromJson$Enum$PinnedDiscussionPattern(
    String value) {
  switch (value) {
    case r'DOT_FILL':
      return Enum$PinnedDiscussionPattern.DOT_FILL;
    case r'PLUS':
      return Enum$PinnedDiscussionPattern.PLUS;
    case r'ZAP':
      return Enum$PinnedDiscussionPattern.ZAP;
    case r'CHEVRON_UP':
      return Enum$PinnedDiscussionPattern.CHEVRON_UP;
    case r'DOT':
      return Enum$PinnedDiscussionPattern.DOT;
    case r'HEART_FILL':
      return Enum$PinnedDiscussionPattern.HEART_FILL;
    default:
      return Enum$PinnedDiscussionPattern.$unknown;
  }
}

enum Enum$ProjectCardArchivedState { ARCHIVED, NOT_ARCHIVED, $unknown }

String toJson$Enum$ProjectCardArchivedState(Enum$ProjectCardArchivedState e) {
  switch (e) {
    case Enum$ProjectCardArchivedState.ARCHIVED:
      return r'ARCHIVED';
    case Enum$ProjectCardArchivedState.NOT_ARCHIVED:
      return r'NOT_ARCHIVED';
    case Enum$ProjectCardArchivedState.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectCardArchivedState fromJson$Enum$ProjectCardArchivedState(
    String value) {
  switch (value) {
    case r'ARCHIVED':
      return Enum$ProjectCardArchivedState.ARCHIVED;
    case r'NOT_ARCHIVED':
      return Enum$ProjectCardArchivedState.NOT_ARCHIVED;
    default:
      return Enum$ProjectCardArchivedState.$unknown;
  }
}

enum Enum$ProjectCardState { CONTENT_ONLY, NOTE_ONLY, REDACTED, $unknown }

String toJson$Enum$ProjectCardState(Enum$ProjectCardState e) {
  switch (e) {
    case Enum$ProjectCardState.CONTENT_ONLY:
      return r'CONTENT_ONLY';
    case Enum$ProjectCardState.NOTE_ONLY:
      return r'NOTE_ONLY';
    case Enum$ProjectCardState.REDACTED:
      return r'REDACTED';
    case Enum$ProjectCardState.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectCardState fromJson$Enum$ProjectCardState(String value) {
  switch (value) {
    case r'CONTENT_ONLY':
      return Enum$ProjectCardState.CONTENT_ONLY;
    case r'NOTE_ONLY':
      return Enum$ProjectCardState.NOTE_ONLY;
    case r'REDACTED':
      return Enum$ProjectCardState.REDACTED;
    default:
      return Enum$ProjectCardState.$unknown;
  }
}

enum Enum$ProjectColumnPurpose { TODO, IN_PROGRESS, DONE, $unknown }

String toJson$Enum$ProjectColumnPurpose(Enum$ProjectColumnPurpose e) {
  switch (e) {
    case Enum$ProjectColumnPurpose.TODO:
      return r'TODO';
    case Enum$ProjectColumnPurpose.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$ProjectColumnPurpose.DONE:
      return r'DONE';
    case Enum$ProjectColumnPurpose.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectColumnPurpose fromJson$Enum$ProjectColumnPurpose(String value) {
  switch (value) {
    case r'TODO':
      return Enum$ProjectColumnPurpose.TODO;
    case r'IN_PROGRESS':
      return Enum$ProjectColumnPurpose.IN_PROGRESS;
    case r'DONE':
      return Enum$ProjectColumnPurpose.DONE;
    default:
      return Enum$ProjectColumnPurpose.$unknown;
  }
}

enum Enum$ProjectItemType {
  ISSUE,
  PULL_REQUEST,
  DRAFT_ISSUE,
  REDACTED,
  $unknown
}

String toJson$Enum$ProjectItemType(Enum$ProjectItemType e) {
  switch (e) {
    case Enum$ProjectItemType.ISSUE:
      return r'ISSUE';
    case Enum$ProjectItemType.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$ProjectItemType.DRAFT_ISSUE:
      return r'DRAFT_ISSUE';
    case Enum$ProjectItemType.REDACTED:
      return r'REDACTED';
    case Enum$ProjectItemType.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectItemType fromJson$Enum$ProjectItemType(String value) {
  switch (value) {
    case r'ISSUE':
      return Enum$ProjectItemType.ISSUE;
    case r'PULL_REQUEST':
      return Enum$ProjectItemType.PULL_REQUEST;
    case r'DRAFT_ISSUE':
      return Enum$ProjectItemType.DRAFT_ISSUE;
    case r'REDACTED':
      return Enum$ProjectItemType.REDACTED;
    default:
      return Enum$ProjectItemType.$unknown;
  }
}

enum Enum$ProjectNextFieldType {
  ASSIGNEES,
  LINKED_PULL_REQUESTS,
  REVIEWERS,
  LABELS,
  MILESTONE,
  REPOSITORY,
  TITLE,
  TEXT,
  SINGLE_SELECT,
  NUMBER,
  DATE,
  ITERATION,
  TRACKS,
  TRACKED_BY,
  $unknown
}

String toJson$Enum$ProjectNextFieldType(Enum$ProjectNextFieldType e) {
  switch (e) {
    case Enum$ProjectNextFieldType.ASSIGNEES:
      return r'ASSIGNEES';
    case Enum$ProjectNextFieldType.LINKED_PULL_REQUESTS:
      return r'LINKED_PULL_REQUESTS';
    case Enum$ProjectNextFieldType.REVIEWERS:
      return r'REVIEWERS';
    case Enum$ProjectNextFieldType.LABELS:
      return r'LABELS';
    case Enum$ProjectNextFieldType.MILESTONE:
      return r'MILESTONE';
    case Enum$ProjectNextFieldType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$ProjectNextFieldType.TITLE:
      return r'TITLE';
    case Enum$ProjectNextFieldType.TEXT:
      return r'TEXT';
    case Enum$ProjectNextFieldType.SINGLE_SELECT:
      return r'SINGLE_SELECT';
    case Enum$ProjectNextFieldType.NUMBER:
      return r'NUMBER';
    case Enum$ProjectNextFieldType.DATE:
      return r'DATE';
    case Enum$ProjectNextFieldType.ITERATION:
      return r'ITERATION';
    case Enum$ProjectNextFieldType.TRACKS:
      return r'TRACKS';
    case Enum$ProjectNextFieldType.TRACKED_BY:
      return r'TRACKED_BY';
    case Enum$ProjectNextFieldType.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectNextFieldType fromJson$Enum$ProjectNextFieldType(String value) {
  switch (value) {
    case r'ASSIGNEES':
      return Enum$ProjectNextFieldType.ASSIGNEES;
    case r'LINKED_PULL_REQUESTS':
      return Enum$ProjectNextFieldType.LINKED_PULL_REQUESTS;
    case r'REVIEWERS':
      return Enum$ProjectNextFieldType.REVIEWERS;
    case r'LABELS':
      return Enum$ProjectNextFieldType.LABELS;
    case r'MILESTONE':
      return Enum$ProjectNextFieldType.MILESTONE;
    case r'REPOSITORY':
      return Enum$ProjectNextFieldType.REPOSITORY;
    case r'TITLE':
      return Enum$ProjectNextFieldType.TITLE;
    case r'TEXT':
      return Enum$ProjectNextFieldType.TEXT;
    case r'SINGLE_SELECT':
      return Enum$ProjectNextFieldType.SINGLE_SELECT;
    case r'NUMBER':
      return Enum$ProjectNextFieldType.NUMBER;
    case r'DATE':
      return Enum$ProjectNextFieldType.DATE;
    case r'ITERATION':
      return Enum$ProjectNextFieldType.ITERATION;
    case r'TRACKS':
      return Enum$ProjectNextFieldType.TRACKS;
    case r'TRACKED_BY':
      return Enum$ProjectNextFieldType.TRACKED_BY;
    default:
      return Enum$ProjectNextFieldType.$unknown;
  }
}

enum Enum$ProjectNextOrderField {
  TITLE,
  NUMBER,
  UPDATED_AT,
  CREATED_AT,
  $unknown
}

String toJson$Enum$ProjectNextOrderField(Enum$ProjectNextOrderField e) {
  switch (e) {
    case Enum$ProjectNextOrderField.TITLE:
      return r'TITLE';
    case Enum$ProjectNextOrderField.NUMBER:
      return r'NUMBER';
    case Enum$ProjectNextOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$ProjectNextOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectNextOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectNextOrderField fromJson$Enum$ProjectNextOrderField(String value) {
  switch (value) {
    case r'TITLE':
      return Enum$ProjectNextOrderField.TITLE;
    case r'NUMBER':
      return Enum$ProjectNextOrderField.NUMBER;
    case r'UPDATED_AT':
      return Enum$ProjectNextOrderField.UPDATED_AT;
    case r'CREATED_AT':
      return Enum$ProjectNextOrderField.CREATED_AT;
    default:
      return Enum$ProjectNextOrderField.$unknown;
  }
}

enum Enum$ProjectOrderField { CREATED_AT, UPDATED_AT, NAME, $unknown }

String toJson$Enum$ProjectOrderField(Enum$ProjectOrderField e) {
  switch (e) {
    case Enum$ProjectOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$ProjectOrderField.NAME:
      return r'NAME';
    case Enum$ProjectOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectOrderField fromJson$Enum$ProjectOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ProjectOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$ProjectOrderField.UPDATED_AT;
    case r'NAME':
      return Enum$ProjectOrderField.NAME;
    default:
      return Enum$ProjectOrderField.$unknown;
  }
}

enum Enum$ProjectState { OPEN, CLOSED, $unknown }

String toJson$Enum$ProjectState(Enum$ProjectState e) {
  switch (e) {
    case Enum$ProjectState.OPEN:
      return r'OPEN';
    case Enum$ProjectState.CLOSED:
      return r'CLOSED';
    case Enum$ProjectState.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectState fromJson$Enum$ProjectState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$ProjectState.OPEN;
    case r'CLOSED':
      return Enum$ProjectState.CLOSED;
    default:
      return Enum$ProjectState.$unknown;
  }
}

enum Enum$ProjectTemplate {
  BASIC_KANBAN,
  AUTOMATED_KANBAN_V2,
  AUTOMATED_REVIEWS_KANBAN,
  BUG_TRIAGE,
  $unknown
}

String toJson$Enum$ProjectTemplate(Enum$ProjectTemplate e) {
  switch (e) {
    case Enum$ProjectTemplate.BASIC_KANBAN:
      return r'BASIC_KANBAN';
    case Enum$ProjectTemplate.AUTOMATED_KANBAN_V2:
      return r'AUTOMATED_KANBAN_V2';
    case Enum$ProjectTemplate.AUTOMATED_REVIEWS_KANBAN:
      return r'AUTOMATED_REVIEWS_KANBAN';
    case Enum$ProjectTemplate.BUG_TRIAGE:
      return r'BUG_TRIAGE';
    case Enum$ProjectTemplate.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectTemplate fromJson$Enum$ProjectTemplate(String value) {
  switch (value) {
    case r'BASIC_KANBAN':
      return Enum$ProjectTemplate.BASIC_KANBAN;
    case r'AUTOMATED_KANBAN_V2':
      return Enum$ProjectTemplate.AUTOMATED_KANBAN_V2;
    case r'AUTOMATED_REVIEWS_KANBAN':
      return Enum$ProjectTemplate.AUTOMATED_REVIEWS_KANBAN;
    case r'BUG_TRIAGE':
      return Enum$ProjectTemplate.BUG_TRIAGE;
    default:
      return Enum$ProjectTemplate.$unknown;
  }
}

enum Enum$ProjectV2FieldOrderField { POSITION, CREATED_AT, NAME, $unknown }

String toJson$Enum$ProjectV2FieldOrderField(Enum$ProjectV2FieldOrderField e) {
  switch (e) {
    case Enum$ProjectV2FieldOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2FieldOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2FieldOrderField.NAME:
      return r'NAME';
    case Enum$ProjectV2FieldOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2FieldOrderField fromJson$Enum$ProjectV2FieldOrderField(
    String value) {
  switch (value) {
    case r'POSITION':
      return Enum$ProjectV2FieldOrderField.POSITION;
    case r'CREATED_AT':
      return Enum$ProjectV2FieldOrderField.CREATED_AT;
    case r'NAME':
      return Enum$ProjectV2FieldOrderField.NAME;
    default:
      return Enum$ProjectV2FieldOrderField.$unknown;
  }
}

enum Enum$ProjectV2FieldType {
  ASSIGNEES,
  LINKED_PULL_REQUESTS,
  REVIEWERS,
  LABELS,
  MILESTONE,
  REPOSITORY,
  TITLE,
  TEXT,
  SINGLE_SELECT,
  NUMBER,
  DATE,
  ITERATION,
  TRACKS,
  TRACKED_BY,
  $unknown
}

String toJson$Enum$ProjectV2FieldType(Enum$ProjectV2FieldType e) {
  switch (e) {
    case Enum$ProjectV2FieldType.ASSIGNEES:
      return r'ASSIGNEES';
    case Enum$ProjectV2FieldType.LINKED_PULL_REQUESTS:
      return r'LINKED_PULL_REQUESTS';
    case Enum$ProjectV2FieldType.REVIEWERS:
      return r'REVIEWERS';
    case Enum$ProjectV2FieldType.LABELS:
      return r'LABELS';
    case Enum$ProjectV2FieldType.MILESTONE:
      return r'MILESTONE';
    case Enum$ProjectV2FieldType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$ProjectV2FieldType.TITLE:
      return r'TITLE';
    case Enum$ProjectV2FieldType.TEXT:
      return r'TEXT';
    case Enum$ProjectV2FieldType.SINGLE_SELECT:
      return r'SINGLE_SELECT';
    case Enum$ProjectV2FieldType.NUMBER:
      return r'NUMBER';
    case Enum$ProjectV2FieldType.DATE:
      return r'DATE';
    case Enum$ProjectV2FieldType.ITERATION:
      return r'ITERATION';
    case Enum$ProjectV2FieldType.TRACKS:
      return r'TRACKS';
    case Enum$ProjectV2FieldType.TRACKED_BY:
      return r'TRACKED_BY';
    case Enum$ProjectV2FieldType.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2FieldType fromJson$Enum$ProjectV2FieldType(String value) {
  switch (value) {
    case r'ASSIGNEES':
      return Enum$ProjectV2FieldType.ASSIGNEES;
    case r'LINKED_PULL_REQUESTS':
      return Enum$ProjectV2FieldType.LINKED_PULL_REQUESTS;
    case r'REVIEWERS':
      return Enum$ProjectV2FieldType.REVIEWERS;
    case r'LABELS':
      return Enum$ProjectV2FieldType.LABELS;
    case r'MILESTONE':
      return Enum$ProjectV2FieldType.MILESTONE;
    case r'REPOSITORY':
      return Enum$ProjectV2FieldType.REPOSITORY;
    case r'TITLE':
      return Enum$ProjectV2FieldType.TITLE;
    case r'TEXT':
      return Enum$ProjectV2FieldType.TEXT;
    case r'SINGLE_SELECT':
      return Enum$ProjectV2FieldType.SINGLE_SELECT;
    case r'NUMBER':
      return Enum$ProjectV2FieldType.NUMBER;
    case r'DATE':
      return Enum$ProjectV2FieldType.DATE;
    case r'ITERATION':
      return Enum$ProjectV2FieldType.ITERATION;
    case r'TRACKS':
      return Enum$ProjectV2FieldType.TRACKS;
    case r'TRACKED_BY':
      return Enum$ProjectV2FieldType.TRACKED_BY;
    default:
      return Enum$ProjectV2FieldType.$unknown;
  }
}

enum Enum$ProjectV2ItemFieldValueOrderField { POSITION, $unknown }

String toJson$Enum$ProjectV2ItemFieldValueOrderField(
    Enum$ProjectV2ItemFieldValueOrderField e) {
  switch (e) {
    case Enum$ProjectV2ItemFieldValueOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2ItemFieldValueOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ItemFieldValueOrderField
    fromJson$Enum$ProjectV2ItemFieldValueOrderField(String value) {
  switch (value) {
    case r'POSITION':
      return Enum$ProjectV2ItemFieldValueOrderField.POSITION;
    default:
      return Enum$ProjectV2ItemFieldValueOrderField.$unknown;
  }
}

enum Enum$ProjectV2ItemOrderField { POSITION, $unknown }

String toJson$Enum$ProjectV2ItemOrderField(Enum$ProjectV2ItemOrderField e) {
  switch (e) {
    case Enum$ProjectV2ItemOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2ItemOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ItemOrderField fromJson$Enum$ProjectV2ItemOrderField(
    String value) {
  switch (value) {
    case r'POSITION':
      return Enum$ProjectV2ItemOrderField.POSITION;
    default:
      return Enum$ProjectV2ItemOrderField.$unknown;
  }
}

enum Enum$ProjectV2ItemType {
  ISSUE,
  PULL_REQUEST,
  DRAFT_ISSUE,
  REDACTED,
  $unknown
}

String toJson$Enum$ProjectV2ItemType(Enum$ProjectV2ItemType e) {
  switch (e) {
    case Enum$ProjectV2ItemType.ISSUE:
      return r'ISSUE';
    case Enum$ProjectV2ItemType.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$ProjectV2ItemType.DRAFT_ISSUE:
      return r'DRAFT_ISSUE';
    case Enum$ProjectV2ItemType.REDACTED:
      return r'REDACTED';
    case Enum$ProjectV2ItemType.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ItemType fromJson$Enum$ProjectV2ItemType(String value) {
  switch (value) {
    case r'ISSUE':
      return Enum$ProjectV2ItemType.ISSUE;
    case r'PULL_REQUEST':
      return Enum$ProjectV2ItemType.PULL_REQUEST;
    case r'DRAFT_ISSUE':
      return Enum$ProjectV2ItemType.DRAFT_ISSUE;
    case r'REDACTED':
      return Enum$ProjectV2ItemType.REDACTED;
    default:
      return Enum$ProjectV2ItemType.$unknown;
  }
}

enum Enum$ProjectV2OrderField {
  TITLE,
  NUMBER,
  UPDATED_AT,
  CREATED_AT,
  $unknown
}

String toJson$Enum$ProjectV2OrderField(Enum$ProjectV2OrderField e) {
  switch (e) {
    case Enum$ProjectV2OrderField.TITLE:
      return r'TITLE';
    case Enum$ProjectV2OrderField.NUMBER:
      return r'NUMBER';
    case Enum$ProjectV2OrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$ProjectV2OrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2OrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2OrderField fromJson$Enum$ProjectV2OrderField(String value) {
  switch (value) {
    case r'TITLE':
      return Enum$ProjectV2OrderField.TITLE;
    case r'NUMBER':
      return Enum$ProjectV2OrderField.NUMBER;
    case r'UPDATED_AT':
      return Enum$ProjectV2OrderField.UPDATED_AT;
    case r'CREATED_AT':
      return Enum$ProjectV2OrderField.CREATED_AT;
    default:
      return Enum$ProjectV2OrderField.$unknown;
  }
}

enum Enum$ProjectV2State { OPEN, CLOSED, $unknown }

String toJson$Enum$ProjectV2State(Enum$ProjectV2State e) {
  switch (e) {
    case Enum$ProjectV2State.OPEN:
      return r'OPEN';
    case Enum$ProjectV2State.CLOSED:
      return r'CLOSED';
    case Enum$ProjectV2State.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2State fromJson$Enum$ProjectV2State(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$ProjectV2State.OPEN;
    case r'CLOSED':
      return Enum$ProjectV2State.CLOSED;
    default:
      return Enum$ProjectV2State.$unknown;
  }
}

enum Enum$ProjectV2ViewLayout { BOARD_LAYOUT, TABLE_LAYOUT, $unknown }

String toJson$Enum$ProjectV2ViewLayout(Enum$ProjectV2ViewLayout e) {
  switch (e) {
    case Enum$ProjectV2ViewLayout.BOARD_LAYOUT:
      return r'BOARD_LAYOUT';
    case Enum$ProjectV2ViewLayout.TABLE_LAYOUT:
      return r'TABLE_LAYOUT';
    case Enum$ProjectV2ViewLayout.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ViewLayout fromJson$Enum$ProjectV2ViewLayout(String value) {
  switch (value) {
    case r'BOARD_LAYOUT':
      return Enum$ProjectV2ViewLayout.BOARD_LAYOUT;
    case r'TABLE_LAYOUT':
      return Enum$ProjectV2ViewLayout.TABLE_LAYOUT;
    default:
      return Enum$ProjectV2ViewLayout.$unknown;
  }
}

enum Enum$ProjectV2ViewOrderField { POSITION, CREATED_AT, NAME, $unknown }

String toJson$Enum$ProjectV2ViewOrderField(Enum$ProjectV2ViewOrderField e) {
  switch (e) {
    case Enum$ProjectV2ViewOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2ViewOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2ViewOrderField.NAME:
      return r'NAME';
    case Enum$ProjectV2ViewOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ViewOrderField fromJson$Enum$ProjectV2ViewOrderField(
    String value) {
  switch (value) {
    case r'POSITION':
      return Enum$ProjectV2ViewOrderField.POSITION;
    case r'CREATED_AT':
      return Enum$ProjectV2ViewOrderField.CREATED_AT;
    case r'NAME':
      return Enum$ProjectV2ViewOrderField.NAME;
    default:
      return Enum$ProjectV2ViewOrderField.$unknown;
  }
}

enum Enum$ProjectViewLayout { BOARD_LAYOUT, TABLE_LAYOUT, $unknown }

String toJson$Enum$ProjectViewLayout(Enum$ProjectViewLayout e) {
  switch (e) {
    case Enum$ProjectViewLayout.BOARD_LAYOUT:
      return r'BOARD_LAYOUT';
    case Enum$ProjectViewLayout.TABLE_LAYOUT:
      return r'TABLE_LAYOUT';
    case Enum$ProjectViewLayout.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectViewLayout fromJson$Enum$ProjectViewLayout(String value) {
  switch (value) {
    case r'BOARD_LAYOUT':
      return Enum$ProjectViewLayout.BOARD_LAYOUT;
    case r'TABLE_LAYOUT':
      return Enum$ProjectViewLayout.TABLE_LAYOUT;
    default:
      return Enum$ProjectViewLayout.$unknown;
  }
}

enum Enum$PullRequestMergeMethod { MERGE, SQUASH, REBASE, $unknown }

String toJson$Enum$PullRequestMergeMethod(Enum$PullRequestMergeMethod e) {
  switch (e) {
    case Enum$PullRequestMergeMethod.MERGE:
      return r'MERGE';
    case Enum$PullRequestMergeMethod.SQUASH:
      return r'SQUASH';
    case Enum$PullRequestMergeMethod.REBASE:
      return r'REBASE';
    case Enum$PullRequestMergeMethod.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestMergeMethod fromJson$Enum$PullRequestMergeMethod(String value) {
  switch (value) {
    case r'MERGE':
      return Enum$PullRequestMergeMethod.MERGE;
    case r'SQUASH':
      return Enum$PullRequestMergeMethod.SQUASH;
    case r'REBASE':
      return Enum$PullRequestMergeMethod.REBASE;
    default:
      return Enum$PullRequestMergeMethod.$unknown;
  }
}

enum Enum$PullRequestOrderField { CREATED_AT, UPDATED_AT, $unknown }

String toJson$Enum$PullRequestOrderField(Enum$PullRequestOrderField e) {
  switch (e) {
    case Enum$PullRequestOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PullRequestOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$PullRequestOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestOrderField fromJson$Enum$PullRequestOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PullRequestOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$PullRequestOrderField.UPDATED_AT;
    default:
      return Enum$PullRequestOrderField.$unknown;
  }
}

enum Enum$PullRequestReviewCommentState { PENDING, SUBMITTED, $unknown }

String toJson$Enum$PullRequestReviewCommentState(
    Enum$PullRequestReviewCommentState e) {
  switch (e) {
    case Enum$PullRequestReviewCommentState.PENDING:
      return r'PENDING';
    case Enum$PullRequestReviewCommentState.SUBMITTED:
      return r'SUBMITTED';
    case Enum$PullRequestReviewCommentState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewCommentState fromJson$Enum$PullRequestReviewCommentState(
    String value) {
  switch (value) {
    case r'PENDING':
      return Enum$PullRequestReviewCommentState.PENDING;
    case r'SUBMITTED':
      return Enum$PullRequestReviewCommentState.SUBMITTED;
    default:
      return Enum$PullRequestReviewCommentState.$unknown;
  }
}

enum Enum$PullRequestReviewDecision {
  CHANGES_REQUESTED,
  APPROVED,
  REVIEW_REQUIRED,
  $unknown
}

String toJson$Enum$PullRequestReviewDecision(Enum$PullRequestReviewDecision e) {
  switch (e) {
    case Enum$PullRequestReviewDecision.CHANGES_REQUESTED:
      return r'CHANGES_REQUESTED';
    case Enum$PullRequestReviewDecision.APPROVED:
      return r'APPROVED';
    case Enum$PullRequestReviewDecision.REVIEW_REQUIRED:
      return r'REVIEW_REQUIRED';
    case Enum$PullRequestReviewDecision.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewDecision fromJson$Enum$PullRequestReviewDecision(
    String value) {
  switch (value) {
    case r'CHANGES_REQUESTED':
      return Enum$PullRequestReviewDecision.CHANGES_REQUESTED;
    case r'APPROVED':
      return Enum$PullRequestReviewDecision.APPROVED;
    case r'REVIEW_REQUIRED':
      return Enum$PullRequestReviewDecision.REVIEW_REQUIRED;
    default:
      return Enum$PullRequestReviewDecision.$unknown;
  }
}

enum Enum$PullRequestReviewEvent {
  COMMENT,
  APPROVE,
  REQUEST_CHANGES,
  DISMISS,
  $unknown
}

String toJson$Enum$PullRequestReviewEvent(Enum$PullRequestReviewEvent e) {
  switch (e) {
    case Enum$PullRequestReviewEvent.COMMENT:
      return r'COMMENT';
    case Enum$PullRequestReviewEvent.APPROVE:
      return r'APPROVE';
    case Enum$PullRequestReviewEvent.REQUEST_CHANGES:
      return r'REQUEST_CHANGES';
    case Enum$PullRequestReviewEvent.DISMISS:
      return r'DISMISS';
    case Enum$PullRequestReviewEvent.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewEvent fromJson$Enum$PullRequestReviewEvent(String value) {
  switch (value) {
    case r'COMMENT':
      return Enum$PullRequestReviewEvent.COMMENT;
    case r'APPROVE':
      return Enum$PullRequestReviewEvent.APPROVE;
    case r'REQUEST_CHANGES':
      return Enum$PullRequestReviewEvent.REQUEST_CHANGES;
    case r'DISMISS':
      return Enum$PullRequestReviewEvent.DISMISS;
    default:
      return Enum$PullRequestReviewEvent.$unknown;
  }
}

enum Enum$PullRequestReviewState {
  PENDING,
  COMMENTED,
  APPROVED,
  CHANGES_REQUESTED,
  DISMISSED,
  $unknown
}

String toJson$Enum$PullRequestReviewState(Enum$PullRequestReviewState e) {
  switch (e) {
    case Enum$PullRequestReviewState.PENDING:
      return r'PENDING';
    case Enum$PullRequestReviewState.COMMENTED:
      return r'COMMENTED';
    case Enum$PullRequestReviewState.APPROVED:
      return r'APPROVED';
    case Enum$PullRequestReviewState.CHANGES_REQUESTED:
      return r'CHANGES_REQUESTED';
    case Enum$PullRequestReviewState.DISMISSED:
      return r'DISMISSED';
    case Enum$PullRequestReviewState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewState fromJson$Enum$PullRequestReviewState(String value) {
  switch (value) {
    case r'PENDING':
      return Enum$PullRequestReviewState.PENDING;
    case r'COMMENTED':
      return Enum$PullRequestReviewState.COMMENTED;
    case r'APPROVED':
      return Enum$PullRequestReviewState.APPROVED;
    case r'CHANGES_REQUESTED':
      return Enum$PullRequestReviewState.CHANGES_REQUESTED;
    case r'DISMISSED':
      return Enum$PullRequestReviewState.DISMISSED;
    default:
      return Enum$PullRequestReviewState.$unknown;
  }
}

enum Enum$PullRequestState { OPEN, CLOSED, MERGED, $unknown }

String toJson$Enum$PullRequestState(Enum$PullRequestState e) {
  switch (e) {
    case Enum$PullRequestState.OPEN:
      return r'OPEN';
    case Enum$PullRequestState.CLOSED:
      return r'CLOSED';
    case Enum$PullRequestState.MERGED:
      return r'MERGED';
    case Enum$PullRequestState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestState fromJson$Enum$PullRequestState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$PullRequestState.OPEN;
    case r'CLOSED':
      return Enum$PullRequestState.CLOSED;
    case r'MERGED':
      return Enum$PullRequestState.MERGED;
    default:
      return Enum$PullRequestState.$unknown;
  }
}

enum Enum$PullRequestTimelineItemsItemType {
  PULL_REQUEST_COMMIT,
  PULL_REQUEST_COMMIT_COMMENT_THREAD,
  PULL_REQUEST_REVIEW,
  PULL_REQUEST_REVIEW_THREAD,
  PULL_REQUEST_REVISION_MARKER,
  AUTOMATIC_BASE_CHANGE_FAILED_EVENT,
  AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT,
  AUTO_MERGE_DISABLED_EVENT,
  AUTO_MERGE_ENABLED_EVENT,
  AUTO_REBASE_ENABLED_EVENT,
  AUTO_SQUASH_ENABLED_EVENT,
  BASE_REF_CHANGED_EVENT,
  BASE_REF_FORCE_PUSHED_EVENT,
  BASE_REF_DELETED_EVENT,
  DEPLOYED_EVENT,
  DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT,
  HEAD_REF_DELETED_EVENT,
  HEAD_REF_FORCE_PUSHED_EVENT,
  HEAD_REF_RESTORED_EVENT,
  MERGED_EVENT,
  REVIEW_DISMISSED_EVENT,
  REVIEW_REQUESTED_EVENT,
  REVIEW_REQUEST_REMOVED_EVENT,
  READY_FOR_REVIEW_EVENT,
  CONVERT_TO_DRAFT_EVENT,
  ADDED_TO_MERGE_QUEUE_EVENT,
  REMOVED_FROM_MERGE_QUEUE_EVENT,
  ISSUE_COMMENT,
  CROSS_REFERENCED_EVENT,
  ADDED_TO_PROJECT_EVENT,
  ASSIGNED_EVENT,
  CLOSED_EVENT,
  COMMENT_DELETED_EVENT,
  CONNECTED_EVENT,
  CONVERTED_NOTE_TO_ISSUE_EVENT,
  CONVERTED_TO_DISCUSSION_EVENT,
  DEMILESTONED_EVENT,
  DISCONNECTED_EVENT,
  LABELED_EVENT,
  LOCKED_EVENT,
  MARKED_AS_DUPLICATE_EVENT,
  MENTIONED_EVENT,
  MILESTONED_EVENT,
  MOVED_COLUMNS_IN_PROJECT_EVENT,
  PINNED_EVENT,
  REFERENCED_EVENT,
  REMOVED_FROM_PROJECT_EVENT,
  RENAMED_TITLE_EVENT,
  REOPENED_EVENT,
  SUBSCRIBED_EVENT,
  TRANSFERRED_EVENT,
  UNASSIGNED_EVENT,
  UNLABELED_EVENT,
  UNLOCKED_EVENT,
  USER_BLOCKED_EVENT,
  UNMARKED_AS_DUPLICATE_EVENT,
  UNPINNED_EVENT,
  UNSUBSCRIBED_EVENT,
  $unknown
}

String toJson$Enum$PullRequestTimelineItemsItemType(
    Enum$PullRequestTimelineItemsItemType e) {
  switch (e) {
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_COMMIT:
      return r'PULL_REQUEST_COMMIT';
    case Enum$PullRequestTimelineItemsItemType
        .PULL_REQUEST_COMMIT_COMMENT_THREAD:
      return r'PULL_REQUEST_COMMIT_COMMENT_THREAD';
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW:
      return r'PULL_REQUEST_REVIEW';
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW_THREAD:
      return r'PULL_REQUEST_REVIEW_THREAD';
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVISION_MARKER:
      return r'PULL_REQUEST_REVISION_MARKER';
    case Enum$PullRequestTimelineItemsItemType
        .AUTOMATIC_BASE_CHANGE_FAILED_EVENT:
      return r'AUTOMATIC_BASE_CHANGE_FAILED_EVENT';
    case Enum$PullRequestTimelineItemsItemType
        .AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT:
      return r'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_DISABLED_EVENT:
      return r'AUTO_MERGE_DISABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_ENABLED_EVENT:
      return r'AUTO_MERGE_ENABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_REBASE_ENABLED_EVENT:
      return r'AUTO_REBASE_ENABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_SQUASH_ENABLED_EVENT:
      return r'AUTO_SQUASH_ENABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BASE_REF_CHANGED_EVENT:
      return r'BASE_REF_CHANGED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BASE_REF_FORCE_PUSHED_EVENT:
      return r'BASE_REF_FORCE_PUSHED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BASE_REF_DELETED_EVENT:
      return r'BASE_REF_DELETED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.DEPLOYED_EVENT:
      return r'DEPLOYED_EVENT';
    case Enum$PullRequestTimelineItemsItemType
        .DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT:
      return r'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.HEAD_REF_DELETED_EVENT:
      return r'HEAD_REF_DELETED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.HEAD_REF_FORCE_PUSHED_EVENT:
      return r'HEAD_REF_FORCE_PUSHED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.HEAD_REF_RESTORED_EVENT:
      return r'HEAD_REF_RESTORED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MERGED_EVENT:
      return r'MERGED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REVIEW_DISMISSED_EVENT:
      return r'REVIEW_DISMISSED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REVIEW_REQUESTED_EVENT:
      return r'REVIEW_REQUESTED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REVIEW_REQUEST_REMOVED_EVENT:
      return r'REVIEW_REQUEST_REMOVED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.READY_FOR_REVIEW_EVENT:
      return r'READY_FOR_REVIEW_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONVERT_TO_DRAFT_EVENT:
      return r'CONVERT_TO_DRAFT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ADDED_TO_MERGE_QUEUE_EVENT:
      return r'ADDED_TO_MERGE_QUEUE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REMOVED_FROM_MERGE_QUEUE_EVENT:
      return r'REMOVED_FROM_MERGE_QUEUE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ISSUE_COMMENT:
      return r'ISSUE_COMMENT';
    case Enum$PullRequestTimelineItemsItemType.CROSS_REFERENCED_EVENT:
      return r'CROSS_REFERENCED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ADDED_TO_PROJECT_EVENT:
      return r'ADDED_TO_PROJECT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ASSIGNED_EVENT:
      return r'ASSIGNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CLOSED_EVENT:
      return r'CLOSED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.COMMENT_DELETED_EVENT:
      return r'COMMENT_DELETED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONNECTED_EVENT:
      return r'CONNECTED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONVERTED_NOTE_TO_ISSUE_EVENT:
      return r'CONVERTED_NOTE_TO_ISSUE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONVERTED_TO_DISCUSSION_EVENT:
      return r'CONVERTED_TO_DISCUSSION_EVENT';
    case Enum$PullRequestTimelineItemsItemType.DEMILESTONED_EVENT:
      return r'DEMILESTONED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.DISCONNECTED_EVENT:
      return r'DISCONNECTED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.LABELED_EVENT:
      return r'LABELED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.LOCKED_EVENT:
      return r'LOCKED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT:
      return r'MARKED_AS_DUPLICATE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MENTIONED_EVENT:
      return r'MENTIONED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MILESTONED_EVENT:
      return r'MILESTONED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MOVED_COLUMNS_IN_PROJECT_EVENT:
      return r'MOVED_COLUMNS_IN_PROJECT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.PINNED_EVENT:
      return r'PINNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REFERENCED_EVENT:
      return r'REFERENCED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT:
      return r'REMOVED_FROM_PROJECT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.RENAMED_TITLE_EVENT:
      return r'RENAMED_TITLE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REOPENED_EVENT:
      return r'REOPENED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.SUBSCRIBED_EVENT:
      return r'SUBSCRIBED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.TRANSFERRED_EVENT:
      return r'TRANSFERRED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNASSIGNED_EVENT:
      return r'UNASSIGNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNLABELED_EVENT:
      return r'UNLABELED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNLOCKED_EVENT:
      return r'UNLOCKED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.USER_BLOCKED_EVENT:
      return r'USER_BLOCKED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT:
      return r'UNMARKED_AS_DUPLICATE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNPINNED_EVENT:
      return r'UNPINNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNSUBSCRIBED_EVENT:
      return r'UNSUBSCRIBED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestTimelineItemsItemType
    fromJson$Enum$PullRequestTimelineItemsItemType(String value) {
  switch (value) {
    case r'PULL_REQUEST_COMMIT':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_COMMIT;
    case r'PULL_REQUEST_COMMIT_COMMENT_THREAD':
      return Enum$PullRequestTimelineItemsItemType
          .PULL_REQUEST_COMMIT_COMMENT_THREAD;
    case r'PULL_REQUEST_REVIEW':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW;
    case r'PULL_REQUEST_REVIEW_THREAD':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW_THREAD;
    case r'PULL_REQUEST_REVISION_MARKER':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVISION_MARKER;
    case r'AUTOMATIC_BASE_CHANGE_FAILED_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .AUTOMATIC_BASE_CHANGE_FAILED_EVENT;
    case r'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT;
    case r'AUTO_MERGE_DISABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_DISABLED_EVENT;
    case r'AUTO_MERGE_ENABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_ENABLED_EVENT;
    case r'AUTO_REBASE_ENABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_REBASE_ENABLED_EVENT;
    case r'AUTO_SQUASH_ENABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_SQUASH_ENABLED_EVENT;
    case r'BASE_REF_CHANGED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BASE_REF_CHANGED_EVENT;
    case r'BASE_REF_FORCE_PUSHED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BASE_REF_FORCE_PUSHED_EVENT;
    case r'BASE_REF_DELETED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BASE_REF_DELETED_EVENT;
    case r'DEPLOYED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.DEPLOYED_EVENT;
    case r'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT;
    case r'HEAD_REF_DELETED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.HEAD_REF_DELETED_EVENT;
    case r'HEAD_REF_FORCE_PUSHED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.HEAD_REF_FORCE_PUSHED_EVENT;
    case r'HEAD_REF_RESTORED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.HEAD_REF_RESTORED_EVENT;
    case r'MERGED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MERGED_EVENT;
    case r'REVIEW_DISMISSED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REVIEW_DISMISSED_EVENT;
    case r'REVIEW_REQUESTED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REVIEW_REQUESTED_EVENT;
    case r'REVIEW_REQUEST_REMOVED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REVIEW_REQUEST_REMOVED_EVENT;
    case r'READY_FOR_REVIEW_EVENT':
      return Enum$PullRequestTimelineItemsItemType.READY_FOR_REVIEW_EVENT;
    case r'CONVERT_TO_DRAFT_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CONVERT_TO_DRAFT_EVENT;
    case r'ADDED_TO_MERGE_QUEUE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ADDED_TO_MERGE_QUEUE_EVENT;
    case r'REMOVED_FROM_MERGE_QUEUE_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .REMOVED_FROM_MERGE_QUEUE_EVENT;
    case r'ISSUE_COMMENT':
      return Enum$PullRequestTimelineItemsItemType.ISSUE_COMMENT;
    case r'CROSS_REFERENCED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CROSS_REFERENCED_EVENT;
    case r'ADDED_TO_PROJECT_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ADDED_TO_PROJECT_EVENT;
    case r'ASSIGNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ASSIGNED_EVENT;
    case r'CLOSED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CLOSED_EVENT;
    case r'COMMENT_DELETED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.COMMENT_DELETED_EVENT;
    case r'CONNECTED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CONNECTED_EVENT;
    case r'CONVERTED_NOTE_TO_ISSUE_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .CONVERTED_NOTE_TO_ISSUE_EVENT;
    case r'CONVERTED_TO_DISCUSSION_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .CONVERTED_TO_DISCUSSION_EVENT;
    case r'DEMILESTONED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.DEMILESTONED_EVENT;
    case r'DISCONNECTED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.DISCONNECTED_EVENT;
    case r'LABELED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.LABELED_EVENT;
    case r'LOCKED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.LOCKED_EVENT;
    case r'MARKED_AS_DUPLICATE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT;
    case r'MENTIONED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MENTIONED_EVENT;
    case r'MILESTONED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MILESTONED_EVENT;
    case r'MOVED_COLUMNS_IN_PROJECT_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .MOVED_COLUMNS_IN_PROJECT_EVENT;
    case r'PINNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.PINNED_EVENT;
    case r'REFERENCED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REFERENCED_EVENT;
    case r'REMOVED_FROM_PROJECT_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT;
    case r'RENAMED_TITLE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.RENAMED_TITLE_EVENT;
    case r'REOPENED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REOPENED_EVENT;
    case r'SUBSCRIBED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.SUBSCRIBED_EVENT;
    case r'TRANSFERRED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.TRANSFERRED_EVENT;
    case r'UNASSIGNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNASSIGNED_EVENT;
    case r'UNLABELED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNLABELED_EVENT;
    case r'UNLOCKED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNLOCKED_EVENT;
    case r'USER_BLOCKED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.USER_BLOCKED_EVENT;
    case r'UNMARKED_AS_DUPLICATE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT;
    case r'UNPINNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNPINNED_EVENT;
    case r'UNSUBSCRIBED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNSUBSCRIBED_EVENT;
    default:
      return Enum$PullRequestTimelineItemsItemType.$unknown;
  }
}

enum Enum$PullRequestUpdateState { OPEN, CLOSED, $unknown }

String toJson$Enum$PullRequestUpdateState(Enum$PullRequestUpdateState e) {
  switch (e) {
    case Enum$PullRequestUpdateState.OPEN:
      return r'OPEN';
    case Enum$PullRequestUpdateState.CLOSED:
      return r'CLOSED';
    case Enum$PullRequestUpdateState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestUpdateState fromJson$Enum$PullRequestUpdateState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$PullRequestUpdateState.OPEN;
    case r'CLOSED':
      return Enum$PullRequestUpdateState.CLOSED;
    default:
      return Enum$PullRequestUpdateState.$unknown;
  }
}

enum Enum$ReactionContent {
  THUMBS_UP,
  THUMBS_DOWN,
  LAUGH,
  HOORAY,
  CONFUSED,
  HEART,
  ROCKET,
  EYES,
  $unknown
}

String toJson$Enum$ReactionContent(Enum$ReactionContent e) {
  switch (e) {
    case Enum$ReactionContent.THUMBS_UP:
      return r'THUMBS_UP';
    case Enum$ReactionContent.THUMBS_DOWN:
      return r'THUMBS_DOWN';
    case Enum$ReactionContent.LAUGH:
      return r'LAUGH';
    case Enum$ReactionContent.HOORAY:
      return r'HOORAY';
    case Enum$ReactionContent.CONFUSED:
      return r'CONFUSED';
    case Enum$ReactionContent.HEART:
      return r'HEART';
    case Enum$ReactionContent.ROCKET:
      return r'ROCKET';
    case Enum$ReactionContent.EYES:
      return r'EYES';
    case Enum$ReactionContent.$unknown:
      return r'$unknown';
  }
}

Enum$ReactionContent fromJson$Enum$ReactionContent(String value) {
  switch (value) {
    case r'THUMBS_UP':
      return Enum$ReactionContent.THUMBS_UP;
    case r'THUMBS_DOWN':
      return Enum$ReactionContent.THUMBS_DOWN;
    case r'LAUGH':
      return Enum$ReactionContent.LAUGH;
    case r'HOORAY':
      return Enum$ReactionContent.HOORAY;
    case r'CONFUSED':
      return Enum$ReactionContent.CONFUSED;
    case r'HEART':
      return Enum$ReactionContent.HEART;
    case r'ROCKET':
      return Enum$ReactionContent.ROCKET;
    case r'EYES':
      return Enum$ReactionContent.EYES;
    default:
      return Enum$ReactionContent.$unknown;
  }
}

enum Enum$ReactionOrderField { CREATED_AT, $unknown }

String toJson$Enum$ReactionOrderField(Enum$ReactionOrderField e) {
  switch (e) {
    case Enum$ReactionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ReactionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ReactionOrderField fromJson$Enum$ReactionOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ReactionOrderField.CREATED_AT;
    default:
      return Enum$ReactionOrderField.$unknown;
  }
}

enum Enum$RefOrderField { TAG_COMMIT_DATE, ALPHABETICAL, $unknown }

String toJson$Enum$RefOrderField(Enum$RefOrderField e) {
  switch (e) {
    case Enum$RefOrderField.TAG_COMMIT_DATE:
      return r'TAG_COMMIT_DATE';
    case Enum$RefOrderField.ALPHABETICAL:
      return r'ALPHABETICAL';
    case Enum$RefOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RefOrderField fromJson$Enum$RefOrderField(String value) {
  switch (value) {
    case r'TAG_COMMIT_DATE':
      return Enum$RefOrderField.TAG_COMMIT_DATE;
    case r'ALPHABETICAL':
      return Enum$RefOrderField.ALPHABETICAL;
    default:
      return Enum$RefOrderField.$unknown;
  }
}

enum Enum$ReleaseOrderField { CREATED_AT, NAME, $unknown }

String toJson$Enum$ReleaseOrderField(Enum$ReleaseOrderField e) {
  switch (e) {
    case Enum$ReleaseOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ReleaseOrderField.NAME:
      return r'NAME';
    case Enum$ReleaseOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ReleaseOrderField fromJson$Enum$ReleaseOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ReleaseOrderField.CREATED_AT;
    case r'NAME':
      return Enum$ReleaseOrderField.NAME;
    default:
      return Enum$ReleaseOrderField.$unknown;
  }
}

enum Enum$RepoAccessAuditEntryVisibility { INTERNAL, PRIVATE, PUBLIC, $unknown }

String toJson$Enum$RepoAccessAuditEntryVisibility(
    Enum$RepoAccessAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoAccessAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoAccessAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoAccessAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoAccessAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoAccessAuditEntryVisibility
    fromJson$Enum$RepoAccessAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoAccessAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoAccessAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoAccessAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoAccessAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoAddMemberAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown
}

String toJson$Enum$RepoAddMemberAuditEntryVisibility(
    Enum$RepoAddMemberAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoAddMemberAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoAddMemberAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoAddMemberAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoAddMemberAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoAddMemberAuditEntryVisibility
    fromJson$Enum$RepoAddMemberAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoAddMemberAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoAddMemberAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoAddMemberAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoAddMemberAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoArchivedAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown
}

String toJson$Enum$RepoArchivedAuditEntryVisibility(
    Enum$RepoArchivedAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoArchivedAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoArchivedAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoArchivedAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoArchivedAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoArchivedAuditEntryVisibility
    fromJson$Enum$RepoArchivedAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoArchivedAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoArchivedAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoArchivedAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoArchivedAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoChangeMergeSettingAuditEntryMergeType {
  MERGE,
  REBASE,
  SQUASH,
  $unknown
}

String toJson$Enum$RepoChangeMergeSettingAuditEntryMergeType(
    Enum$RepoChangeMergeSettingAuditEntryMergeType e) {
  switch (e) {
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.MERGE:
      return r'MERGE';
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.REBASE:
      return r'REBASE';
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.SQUASH:
      return r'SQUASH';
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.$unknown:
      return r'$unknown';
  }
}

Enum$RepoChangeMergeSettingAuditEntryMergeType
    fromJson$Enum$RepoChangeMergeSettingAuditEntryMergeType(String value) {
  switch (value) {
    case r'MERGE':
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.MERGE;
    case r'REBASE':
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.REBASE;
    case r'SQUASH':
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.SQUASH;
    default:
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.$unknown;
  }
}

enum Enum$RepoCreateAuditEntryVisibility { INTERNAL, PRIVATE, PUBLIC, $unknown }

String toJson$Enum$RepoCreateAuditEntryVisibility(
    Enum$RepoCreateAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoCreateAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoCreateAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoCreateAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoCreateAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoCreateAuditEntryVisibility
    fromJson$Enum$RepoCreateAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoCreateAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoCreateAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoCreateAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoCreateAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoDestroyAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown
}

String toJson$Enum$RepoDestroyAuditEntryVisibility(
    Enum$RepoDestroyAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoDestroyAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoDestroyAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoDestroyAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoDestroyAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoDestroyAuditEntryVisibility
    fromJson$Enum$RepoDestroyAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoDestroyAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoDestroyAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoDestroyAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoDestroyAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoRemoveMemberAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown
}

String toJson$Enum$RepoRemoveMemberAuditEntryVisibility(
    Enum$RepoRemoveMemberAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoRemoveMemberAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoRemoveMemberAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoRemoveMemberAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoRemoveMemberAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoRemoveMemberAuditEntryVisibility
    fromJson$Enum$RepoRemoveMemberAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoRemoveMemberAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoRemoveMemberAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoRemoveMemberAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoRemoveMemberAuditEntryVisibility.$unknown;
  }
}

enum Enum$ReportedContentClassifiers {
  SPAM,
  ABUSE,
  OFF_TOPIC,
  OUTDATED,
  DUPLICATE,
  RESOLVED,
  $unknown
}

String toJson$Enum$ReportedContentClassifiers(
    Enum$ReportedContentClassifiers e) {
  switch (e) {
    case Enum$ReportedContentClassifiers.SPAM:
      return r'SPAM';
    case Enum$ReportedContentClassifiers.ABUSE:
      return r'ABUSE';
    case Enum$ReportedContentClassifiers.OFF_TOPIC:
      return r'OFF_TOPIC';
    case Enum$ReportedContentClassifiers.OUTDATED:
      return r'OUTDATED';
    case Enum$ReportedContentClassifiers.DUPLICATE:
      return r'DUPLICATE';
    case Enum$ReportedContentClassifiers.RESOLVED:
      return r'RESOLVED';
    case Enum$ReportedContentClassifiers.$unknown:
      return r'$unknown';
  }
}

Enum$ReportedContentClassifiers fromJson$Enum$ReportedContentClassifiers(
    String value) {
  switch (value) {
    case r'SPAM':
      return Enum$ReportedContentClassifiers.SPAM;
    case r'ABUSE':
      return Enum$ReportedContentClassifiers.ABUSE;
    case r'OFF_TOPIC':
      return Enum$ReportedContentClassifiers.OFF_TOPIC;
    case r'OUTDATED':
      return Enum$ReportedContentClassifiers.OUTDATED;
    case r'DUPLICATE':
      return Enum$ReportedContentClassifiers.DUPLICATE;
    case r'RESOLVED':
      return Enum$ReportedContentClassifiers.RESOLVED;
    default:
      return Enum$ReportedContentClassifiers.$unknown;
  }
}

enum Enum$RepositoryAffiliation {
  OWNER,
  COLLABORATOR,
  ORGANIZATION_MEMBER,
  $unknown
}

String toJson$Enum$RepositoryAffiliation(Enum$RepositoryAffiliation e) {
  switch (e) {
    case Enum$RepositoryAffiliation.OWNER:
      return r'OWNER';
    case Enum$RepositoryAffiliation.COLLABORATOR:
      return r'COLLABORATOR';
    case Enum$RepositoryAffiliation.ORGANIZATION_MEMBER:
      return r'ORGANIZATION_MEMBER';
    case Enum$RepositoryAffiliation.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryAffiliation fromJson$Enum$RepositoryAffiliation(String value) {
  switch (value) {
    case r'OWNER':
      return Enum$RepositoryAffiliation.OWNER;
    case r'COLLABORATOR':
      return Enum$RepositoryAffiliation.COLLABORATOR;
    case r'ORGANIZATION_MEMBER':
      return Enum$RepositoryAffiliation.ORGANIZATION_MEMBER;
    default:
      return Enum$RepositoryAffiliation.$unknown;
  }
}

enum Enum$RepositoryContributionType {
  COMMIT,
  ISSUE,
  PULL_REQUEST,
  REPOSITORY,
  PULL_REQUEST_REVIEW,
  $unknown
}

String toJson$Enum$RepositoryContributionType(
    Enum$RepositoryContributionType e) {
  switch (e) {
    case Enum$RepositoryContributionType.COMMIT:
      return r'COMMIT';
    case Enum$RepositoryContributionType.ISSUE:
      return r'ISSUE';
    case Enum$RepositoryContributionType.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$RepositoryContributionType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$RepositoryContributionType.PULL_REQUEST_REVIEW:
      return r'PULL_REQUEST_REVIEW';
    case Enum$RepositoryContributionType.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryContributionType fromJson$Enum$RepositoryContributionType(
    String value) {
  switch (value) {
    case r'COMMIT':
      return Enum$RepositoryContributionType.COMMIT;
    case r'ISSUE':
      return Enum$RepositoryContributionType.ISSUE;
    case r'PULL_REQUEST':
      return Enum$RepositoryContributionType.PULL_REQUEST;
    case r'REPOSITORY':
      return Enum$RepositoryContributionType.REPOSITORY;
    case r'PULL_REQUEST_REVIEW':
      return Enum$RepositoryContributionType.PULL_REQUEST_REVIEW;
    default:
      return Enum$RepositoryContributionType.$unknown;
  }
}

enum Enum$RepositoryInteractionLimit {
  EXISTING_USERS,
  CONTRIBUTORS_ONLY,
  COLLABORATORS_ONLY,
  NO_LIMIT,
  $unknown
}

String toJson$Enum$RepositoryInteractionLimit(
    Enum$RepositoryInteractionLimit e) {
  switch (e) {
    case Enum$RepositoryInteractionLimit.EXISTING_USERS:
      return r'EXISTING_USERS';
    case Enum$RepositoryInteractionLimit.CONTRIBUTORS_ONLY:
      return r'CONTRIBUTORS_ONLY';
    case Enum$RepositoryInteractionLimit.COLLABORATORS_ONLY:
      return r'COLLABORATORS_ONLY';
    case Enum$RepositoryInteractionLimit.NO_LIMIT:
      return r'NO_LIMIT';
    case Enum$RepositoryInteractionLimit.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInteractionLimit fromJson$Enum$RepositoryInteractionLimit(
    String value) {
  switch (value) {
    case r'EXISTING_USERS':
      return Enum$RepositoryInteractionLimit.EXISTING_USERS;
    case r'CONTRIBUTORS_ONLY':
      return Enum$RepositoryInteractionLimit.CONTRIBUTORS_ONLY;
    case r'COLLABORATORS_ONLY':
      return Enum$RepositoryInteractionLimit.COLLABORATORS_ONLY;
    case r'NO_LIMIT':
      return Enum$RepositoryInteractionLimit.NO_LIMIT;
    default:
      return Enum$RepositoryInteractionLimit.$unknown;
  }
}

enum Enum$RepositoryInteractionLimitExpiry {
  ONE_DAY,
  THREE_DAYS,
  ONE_WEEK,
  ONE_MONTH,
  SIX_MONTHS,
  $unknown
}

String toJson$Enum$RepositoryInteractionLimitExpiry(
    Enum$RepositoryInteractionLimitExpiry e) {
  switch (e) {
    case Enum$RepositoryInteractionLimitExpiry.ONE_DAY:
      return r'ONE_DAY';
    case Enum$RepositoryInteractionLimitExpiry.THREE_DAYS:
      return r'THREE_DAYS';
    case Enum$RepositoryInteractionLimitExpiry.ONE_WEEK:
      return r'ONE_WEEK';
    case Enum$RepositoryInteractionLimitExpiry.ONE_MONTH:
      return r'ONE_MONTH';
    case Enum$RepositoryInteractionLimitExpiry.SIX_MONTHS:
      return r'SIX_MONTHS';
    case Enum$RepositoryInteractionLimitExpiry.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInteractionLimitExpiry
    fromJson$Enum$RepositoryInteractionLimitExpiry(String value) {
  switch (value) {
    case r'ONE_DAY':
      return Enum$RepositoryInteractionLimitExpiry.ONE_DAY;
    case r'THREE_DAYS':
      return Enum$RepositoryInteractionLimitExpiry.THREE_DAYS;
    case r'ONE_WEEK':
      return Enum$RepositoryInteractionLimitExpiry.ONE_WEEK;
    case r'ONE_MONTH':
      return Enum$RepositoryInteractionLimitExpiry.ONE_MONTH;
    case r'SIX_MONTHS':
      return Enum$RepositoryInteractionLimitExpiry.SIX_MONTHS;
    default:
      return Enum$RepositoryInteractionLimitExpiry.$unknown;
  }
}

enum Enum$RepositoryInteractionLimitOrigin {
  REPOSITORY,
  ORGANIZATION,
  USER,
  $unknown
}

String toJson$Enum$RepositoryInteractionLimitOrigin(
    Enum$RepositoryInteractionLimitOrigin e) {
  switch (e) {
    case Enum$RepositoryInteractionLimitOrigin.REPOSITORY:
      return r'REPOSITORY';
    case Enum$RepositoryInteractionLimitOrigin.ORGANIZATION:
      return r'ORGANIZATION';
    case Enum$RepositoryInteractionLimitOrigin.USER:
      return r'USER';
    case Enum$RepositoryInteractionLimitOrigin.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInteractionLimitOrigin
    fromJson$Enum$RepositoryInteractionLimitOrigin(String value) {
  switch (value) {
    case r'REPOSITORY':
      return Enum$RepositoryInteractionLimitOrigin.REPOSITORY;
    case r'ORGANIZATION':
      return Enum$RepositoryInteractionLimitOrigin.ORGANIZATION;
    case r'USER':
      return Enum$RepositoryInteractionLimitOrigin.USER;
    default:
      return Enum$RepositoryInteractionLimitOrigin.$unknown;
  }
}

enum Enum$RepositoryInvitationOrderField { CREATED_AT, $unknown }

String toJson$Enum$RepositoryInvitationOrderField(
    Enum$RepositoryInvitationOrderField e) {
  switch (e) {
    case Enum$RepositoryInvitationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$RepositoryInvitationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInvitationOrderField
    fromJson$Enum$RepositoryInvitationOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$RepositoryInvitationOrderField.CREATED_AT;
    default:
      return Enum$RepositoryInvitationOrderField.$unknown;
  }
}

enum Enum$RepositoryLockReason { MOVING, BILLING, RENAME, MIGRATING, $unknown }

String toJson$Enum$RepositoryLockReason(Enum$RepositoryLockReason e) {
  switch (e) {
    case Enum$RepositoryLockReason.MOVING:
      return r'MOVING';
    case Enum$RepositoryLockReason.BILLING:
      return r'BILLING';
    case Enum$RepositoryLockReason.RENAME:
      return r'RENAME';
    case Enum$RepositoryLockReason.MIGRATING:
      return r'MIGRATING';
    case Enum$RepositoryLockReason.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryLockReason fromJson$Enum$RepositoryLockReason(String value) {
  switch (value) {
    case r'MOVING':
      return Enum$RepositoryLockReason.MOVING;
    case r'BILLING':
      return Enum$RepositoryLockReason.BILLING;
    case r'RENAME':
      return Enum$RepositoryLockReason.RENAME;
    case r'MIGRATING':
      return Enum$RepositoryLockReason.MIGRATING;
    default:
      return Enum$RepositoryLockReason.$unknown;
  }
}

enum Enum$RepositoryMigrationOrderDirection { ASC, DESC, $unknown }

String toJson$Enum$RepositoryMigrationOrderDirection(
    Enum$RepositoryMigrationOrderDirection e) {
  switch (e) {
    case Enum$RepositoryMigrationOrderDirection.ASC:
      return r'ASC';
    case Enum$RepositoryMigrationOrderDirection.DESC:
      return r'DESC';
    case Enum$RepositoryMigrationOrderDirection.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryMigrationOrderDirection
    fromJson$Enum$RepositoryMigrationOrderDirection(String value) {
  switch (value) {
    case r'ASC':
      return Enum$RepositoryMigrationOrderDirection.ASC;
    case r'DESC':
      return Enum$RepositoryMigrationOrderDirection.DESC;
    default:
      return Enum$RepositoryMigrationOrderDirection.$unknown;
  }
}

enum Enum$RepositoryMigrationOrderField { CREATED_AT, $unknown }

String toJson$Enum$RepositoryMigrationOrderField(
    Enum$RepositoryMigrationOrderField e) {
  switch (e) {
    case Enum$RepositoryMigrationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$RepositoryMigrationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryMigrationOrderField fromJson$Enum$RepositoryMigrationOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$RepositoryMigrationOrderField.CREATED_AT;
    default:
      return Enum$RepositoryMigrationOrderField.$unknown;
  }
}

enum Enum$RepositoryOrderField {
  CREATED_AT,
  UPDATED_AT,
  PUSHED_AT,
  NAME,
  STARGAZERS,
  $unknown
}

String toJson$Enum$RepositoryOrderField(Enum$RepositoryOrderField e) {
  switch (e) {
    case Enum$RepositoryOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$RepositoryOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$RepositoryOrderField.PUSHED_AT:
      return r'PUSHED_AT';
    case Enum$RepositoryOrderField.NAME:
      return r'NAME';
    case Enum$RepositoryOrderField.STARGAZERS:
      return r'STARGAZERS';
    case Enum$RepositoryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryOrderField fromJson$Enum$RepositoryOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$RepositoryOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$RepositoryOrderField.UPDATED_AT;
    case r'PUSHED_AT':
      return Enum$RepositoryOrderField.PUSHED_AT;
    case r'NAME':
      return Enum$RepositoryOrderField.NAME;
    case r'STARGAZERS':
      return Enum$RepositoryOrderField.STARGAZERS;
    default:
      return Enum$RepositoryOrderField.$unknown;
  }
}

enum Enum$RepositoryPermission {
  ADMIN,
  MAINTAIN,
  WRITE,
  TRIAGE,
  READ,
  $unknown
}

String toJson$Enum$RepositoryPermission(Enum$RepositoryPermission e) {
  switch (e) {
    case Enum$RepositoryPermission.ADMIN:
      return r'ADMIN';
    case Enum$RepositoryPermission.MAINTAIN:
      return r'MAINTAIN';
    case Enum$RepositoryPermission.WRITE:
      return r'WRITE';
    case Enum$RepositoryPermission.TRIAGE:
      return r'TRIAGE';
    case Enum$RepositoryPermission.READ:
      return r'READ';
    case Enum$RepositoryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryPermission fromJson$Enum$RepositoryPermission(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$RepositoryPermission.ADMIN;
    case r'MAINTAIN':
      return Enum$RepositoryPermission.MAINTAIN;
    case r'WRITE':
      return Enum$RepositoryPermission.WRITE;
    case r'TRIAGE':
      return Enum$RepositoryPermission.TRIAGE;
    case r'READ':
      return Enum$RepositoryPermission.READ;
    default:
      return Enum$RepositoryPermission.$unknown;
  }
}

enum Enum$RepositoryPrivacy { PUBLIC, PRIVATE, $unknown }

String toJson$Enum$RepositoryPrivacy(Enum$RepositoryPrivacy e) {
  switch (e) {
    case Enum$RepositoryPrivacy.PUBLIC:
      return r'PUBLIC';
    case Enum$RepositoryPrivacy.PRIVATE:
      return r'PRIVATE';
    case Enum$RepositoryPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryPrivacy fromJson$Enum$RepositoryPrivacy(String value) {
  switch (value) {
    case r'PUBLIC':
      return Enum$RepositoryPrivacy.PUBLIC;
    case r'PRIVATE':
      return Enum$RepositoryPrivacy.PRIVATE;
    default:
      return Enum$RepositoryPrivacy.$unknown;
  }
}

enum Enum$RepositoryVisibility { PRIVATE, PUBLIC, INTERNAL, $unknown }

String toJson$Enum$RepositoryVisibility(Enum$RepositoryVisibility e) {
  switch (e) {
    case Enum$RepositoryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepositoryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepositoryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepositoryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryVisibility fromJson$Enum$RepositoryVisibility(String value) {
  switch (value) {
    case r'PRIVATE':
      return Enum$RepositoryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepositoryVisibility.PUBLIC;
    case r'INTERNAL':
      return Enum$RepositoryVisibility.INTERNAL;
    default:
      return Enum$RepositoryVisibility.$unknown;
  }
}

enum Enum$RepositoryVulnerabilityAlertDependencyScope {
  RUNTIME,
  DEVELOPMENT,
  $unknown
}

String toJson$Enum$RepositoryVulnerabilityAlertDependencyScope(
    Enum$RepositoryVulnerabilityAlertDependencyScope e) {
  switch (e) {
    case Enum$RepositoryVulnerabilityAlertDependencyScope.RUNTIME:
      return r'RUNTIME';
    case Enum$RepositoryVulnerabilityAlertDependencyScope.DEVELOPMENT:
      return r'DEVELOPMENT';
    case Enum$RepositoryVulnerabilityAlertDependencyScope.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryVulnerabilityAlertDependencyScope
    fromJson$Enum$RepositoryVulnerabilityAlertDependencyScope(String value) {
  switch (value) {
    case r'RUNTIME':
      return Enum$RepositoryVulnerabilityAlertDependencyScope.RUNTIME;
    case r'DEVELOPMENT':
      return Enum$RepositoryVulnerabilityAlertDependencyScope.DEVELOPMENT;
    default:
      return Enum$RepositoryVulnerabilityAlertDependencyScope.$unknown;
  }
}

enum Enum$RepositoryVulnerabilityAlertState { OPEN, FIXED, DISMISSED, $unknown }

String toJson$Enum$RepositoryVulnerabilityAlertState(
    Enum$RepositoryVulnerabilityAlertState e) {
  switch (e) {
    case Enum$RepositoryVulnerabilityAlertState.OPEN:
      return r'OPEN';
    case Enum$RepositoryVulnerabilityAlertState.FIXED:
      return r'FIXED';
    case Enum$RepositoryVulnerabilityAlertState.DISMISSED:
      return r'DISMISSED';
    case Enum$RepositoryVulnerabilityAlertState.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryVulnerabilityAlertState
    fromJson$Enum$RepositoryVulnerabilityAlertState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$RepositoryVulnerabilityAlertState.OPEN;
    case r'FIXED':
      return Enum$RepositoryVulnerabilityAlertState.FIXED;
    case r'DISMISSED':
      return Enum$RepositoryVulnerabilityAlertState.DISMISSED;
    default:
      return Enum$RepositoryVulnerabilityAlertState.$unknown;
  }
}

enum Enum$RequestableCheckStatusState {
  QUEUED,
  IN_PROGRESS,
  COMPLETED,
  WAITING,
  PENDING,
  $unknown
}

String toJson$Enum$RequestableCheckStatusState(
    Enum$RequestableCheckStatusState e) {
  switch (e) {
    case Enum$RequestableCheckStatusState.QUEUED:
      return r'QUEUED';
    case Enum$RequestableCheckStatusState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$RequestableCheckStatusState.COMPLETED:
      return r'COMPLETED';
    case Enum$RequestableCheckStatusState.WAITING:
      return r'WAITING';
    case Enum$RequestableCheckStatusState.PENDING:
      return r'PENDING';
    case Enum$RequestableCheckStatusState.$unknown:
      return r'$unknown';
  }
}

Enum$RequestableCheckStatusState fromJson$Enum$RequestableCheckStatusState(
    String value) {
  switch (value) {
    case r'QUEUED':
      return Enum$RequestableCheckStatusState.QUEUED;
    case r'IN_PROGRESS':
      return Enum$RequestableCheckStatusState.IN_PROGRESS;
    case r'COMPLETED':
      return Enum$RequestableCheckStatusState.COMPLETED;
    case r'WAITING':
      return Enum$RequestableCheckStatusState.WAITING;
    case r'PENDING':
      return Enum$RequestableCheckStatusState.PENDING;
    default:
      return Enum$RequestableCheckStatusState.$unknown;
  }
}

enum Enum$RoleInOrganization { OWNER, DIRECT_MEMBER, UNAFFILIATED, $unknown }

String toJson$Enum$RoleInOrganization(Enum$RoleInOrganization e) {
  switch (e) {
    case Enum$RoleInOrganization.OWNER:
      return r'OWNER';
    case Enum$RoleInOrganization.DIRECT_MEMBER:
      return r'DIRECT_MEMBER';
    case Enum$RoleInOrganization.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$RoleInOrganization.$unknown:
      return r'$unknown';
  }
}

Enum$RoleInOrganization fromJson$Enum$RoleInOrganization(String value) {
  switch (value) {
    case r'OWNER':
      return Enum$RoleInOrganization.OWNER;
    case r'DIRECT_MEMBER':
      return Enum$RoleInOrganization.DIRECT_MEMBER;
    case r'UNAFFILIATED':
      return Enum$RoleInOrganization.UNAFFILIATED;
    default:
      return Enum$RoleInOrganization.$unknown;
  }
}

enum Enum$SamlDigestAlgorithm { SHA1, SHA256, SHA384, SHA512, $unknown }

String toJson$Enum$SamlDigestAlgorithm(Enum$SamlDigestAlgorithm e) {
  switch (e) {
    case Enum$SamlDigestAlgorithm.SHA1:
      return r'SHA1';
    case Enum$SamlDigestAlgorithm.SHA256:
      return r'SHA256';
    case Enum$SamlDigestAlgorithm.SHA384:
      return r'SHA384';
    case Enum$SamlDigestAlgorithm.SHA512:
      return r'SHA512';
    case Enum$SamlDigestAlgorithm.$unknown:
      return r'$unknown';
  }
}

Enum$SamlDigestAlgorithm fromJson$Enum$SamlDigestAlgorithm(String value) {
  switch (value) {
    case r'SHA1':
      return Enum$SamlDigestAlgorithm.SHA1;
    case r'SHA256':
      return Enum$SamlDigestAlgorithm.SHA256;
    case r'SHA384':
      return Enum$SamlDigestAlgorithm.SHA384;
    case r'SHA512':
      return Enum$SamlDigestAlgorithm.SHA512;
    default:
      return Enum$SamlDigestAlgorithm.$unknown;
  }
}

enum Enum$SamlSignatureAlgorithm {
  RSA_SHA1,
  RSA_SHA256,
  RSA_SHA384,
  RSA_SHA512,
  $unknown
}

String toJson$Enum$SamlSignatureAlgorithm(Enum$SamlSignatureAlgorithm e) {
  switch (e) {
    case Enum$SamlSignatureAlgorithm.RSA_SHA1:
      return r'RSA_SHA1';
    case Enum$SamlSignatureAlgorithm.RSA_SHA256:
      return r'RSA_SHA256';
    case Enum$SamlSignatureAlgorithm.RSA_SHA384:
      return r'RSA_SHA384';
    case Enum$SamlSignatureAlgorithm.RSA_SHA512:
      return r'RSA_SHA512';
    case Enum$SamlSignatureAlgorithm.$unknown:
      return r'$unknown';
  }
}

Enum$SamlSignatureAlgorithm fromJson$Enum$SamlSignatureAlgorithm(String value) {
  switch (value) {
    case r'RSA_SHA1':
      return Enum$SamlSignatureAlgorithm.RSA_SHA1;
    case r'RSA_SHA256':
      return Enum$SamlSignatureAlgorithm.RSA_SHA256;
    case r'RSA_SHA384':
      return Enum$SamlSignatureAlgorithm.RSA_SHA384;
    case r'RSA_SHA512':
      return Enum$SamlSignatureAlgorithm.RSA_SHA512;
    default:
      return Enum$SamlSignatureAlgorithm.$unknown;
  }
}

enum Enum$SavedReplyOrderField { UPDATED_AT, $unknown }

String toJson$Enum$SavedReplyOrderField(Enum$SavedReplyOrderField e) {
  switch (e) {
    case Enum$SavedReplyOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$SavedReplyOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SavedReplyOrderField fromJson$Enum$SavedReplyOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$SavedReplyOrderField.UPDATED_AT;
    default:
      return Enum$SavedReplyOrderField.$unknown;
  }
}

enum Enum$SearchType { ISSUE, REPOSITORY, USER, DISCUSSION, $unknown }

String toJson$Enum$SearchType(Enum$SearchType e) {
  switch (e) {
    case Enum$SearchType.ISSUE:
      return r'ISSUE';
    case Enum$SearchType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$SearchType.USER:
      return r'USER';
    case Enum$SearchType.DISCUSSION:
      return r'DISCUSSION';
    case Enum$SearchType.$unknown:
      return r'$unknown';
  }
}

Enum$SearchType fromJson$Enum$SearchType(String value) {
  switch (value) {
    case r'ISSUE':
      return Enum$SearchType.ISSUE;
    case r'REPOSITORY':
      return Enum$SearchType.REPOSITORY;
    case r'USER':
      return Enum$SearchType.USER;
    case r'DISCUSSION':
      return Enum$SearchType.DISCUSSION;
    default:
      return Enum$SearchType.$unknown;
  }
}

enum Enum$SecurityAdvisoryClassification { GENERAL, MALWARE, $unknown }

String toJson$Enum$SecurityAdvisoryClassification(
    Enum$SecurityAdvisoryClassification e) {
  switch (e) {
    case Enum$SecurityAdvisoryClassification.GENERAL:
      return r'GENERAL';
    case Enum$SecurityAdvisoryClassification.MALWARE:
      return r'MALWARE';
    case Enum$SecurityAdvisoryClassification.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryClassification
    fromJson$Enum$SecurityAdvisoryClassification(String value) {
  switch (value) {
    case r'GENERAL':
      return Enum$SecurityAdvisoryClassification.GENERAL;
    case r'MALWARE':
      return Enum$SecurityAdvisoryClassification.MALWARE;
    default:
      return Enum$SecurityAdvisoryClassification.$unknown;
  }
}

enum Enum$SecurityAdvisoryEcosystem {
  COMPOSER,
  ERLANG,
  ACTIONS,
  GO,
  MAVEN,
  NPM,
  NUGET,
  PIP,
  PUB,
  RUBYGEMS,
  RUST,
  $unknown
}

String toJson$Enum$SecurityAdvisoryEcosystem(Enum$SecurityAdvisoryEcosystem e) {
  switch (e) {
    case Enum$SecurityAdvisoryEcosystem.COMPOSER:
      return r'COMPOSER';
    case Enum$SecurityAdvisoryEcosystem.ERLANG:
      return r'ERLANG';
    case Enum$SecurityAdvisoryEcosystem.ACTIONS:
      return r'ACTIONS';
    case Enum$SecurityAdvisoryEcosystem.GO:
      return r'GO';
    case Enum$SecurityAdvisoryEcosystem.MAVEN:
      return r'MAVEN';
    case Enum$SecurityAdvisoryEcosystem.NPM:
      return r'NPM';
    case Enum$SecurityAdvisoryEcosystem.NUGET:
      return r'NUGET';
    case Enum$SecurityAdvisoryEcosystem.PIP:
      return r'PIP';
    case Enum$SecurityAdvisoryEcosystem.PUB:
      return r'PUB';
    case Enum$SecurityAdvisoryEcosystem.RUBYGEMS:
      return r'RUBYGEMS';
    case Enum$SecurityAdvisoryEcosystem.RUST:
      return r'RUST';
    case Enum$SecurityAdvisoryEcosystem.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryEcosystem fromJson$Enum$SecurityAdvisoryEcosystem(
    String value) {
  switch (value) {
    case r'COMPOSER':
      return Enum$SecurityAdvisoryEcosystem.COMPOSER;
    case r'ERLANG':
      return Enum$SecurityAdvisoryEcosystem.ERLANG;
    case r'ACTIONS':
      return Enum$SecurityAdvisoryEcosystem.ACTIONS;
    case r'GO':
      return Enum$SecurityAdvisoryEcosystem.GO;
    case r'MAVEN':
      return Enum$SecurityAdvisoryEcosystem.MAVEN;
    case r'NPM':
      return Enum$SecurityAdvisoryEcosystem.NPM;
    case r'NUGET':
      return Enum$SecurityAdvisoryEcosystem.NUGET;
    case r'PIP':
      return Enum$SecurityAdvisoryEcosystem.PIP;
    case r'PUB':
      return Enum$SecurityAdvisoryEcosystem.PUB;
    case r'RUBYGEMS':
      return Enum$SecurityAdvisoryEcosystem.RUBYGEMS;
    case r'RUST':
      return Enum$SecurityAdvisoryEcosystem.RUST;
    default:
      return Enum$SecurityAdvisoryEcosystem.$unknown;
  }
}

enum Enum$SecurityAdvisoryIdentifierType { CVE, GHSA, $unknown }

String toJson$Enum$SecurityAdvisoryIdentifierType(
    Enum$SecurityAdvisoryIdentifierType e) {
  switch (e) {
    case Enum$SecurityAdvisoryIdentifierType.CVE:
      return r'CVE';
    case Enum$SecurityAdvisoryIdentifierType.GHSA:
      return r'GHSA';
    case Enum$SecurityAdvisoryIdentifierType.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryIdentifierType
    fromJson$Enum$SecurityAdvisoryIdentifierType(String value) {
  switch (value) {
    case r'CVE':
      return Enum$SecurityAdvisoryIdentifierType.CVE;
    case r'GHSA':
      return Enum$SecurityAdvisoryIdentifierType.GHSA;
    default:
      return Enum$SecurityAdvisoryIdentifierType.$unknown;
  }
}

enum Enum$SecurityAdvisoryOrderField { PUBLISHED_AT, UPDATED_AT, $unknown }

String toJson$Enum$SecurityAdvisoryOrderField(
    Enum$SecurityAdvisoryOrderField e) {
  switch (e) {
    case Enum$SecurityAdvisoryOrderField.PUBLISHED_AT:
      return r'PUBLISHED_AT';
    case Enum$SecurityAdvisoryOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$SecurityAdvisoryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryOrderField fromJson$Enum$SecurityAdvisoryOrderField(
    String value) {
  switch (value) {
    case r'PUBLISHED_AT':
      return Enum$SecurityAdvisoryOrderField.PUBLISHED_AT;
    case r'UPDATED_AT':
      return Enum$SecurityAdvisoryOrderField.UPDATED_AT;
    default:
      return Enum$SecurityAdvisoryOrderField.$unknown;
  }
}

enum Enum$SecurityAdvisorySeverity { LOW, MODERATE, HIGH, CRITICAL, $unknown }

String toJson$Enum$SecurityAdvisorySeverity(Enum$SecurityAdvisorySeverity e) {
  switch (e) {
    case Enum$SecurityAdvisorySeverity.LOW:
      return r'LOW';
    case Enum$SecurityAdvisorySeverity.MODERATE:
      return r'MODERATE';
    case Enum$SecurityAdvisorySeverity.HIGH:
      return r'HIGH';
    case Enum$SecurityAdvisorySeverity.CRITICAL:
      return r'CRITICAL';
    case Enum$SecurityAdvisorySeverity.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisorySeverity fromJson$Enum$SecurityAdvisorySeverity(
    String value) {
  switch (value) {
    case r'LOW':
      return Enum$SecurityAdvisorySeverity.LOW;
    case r'MODERATE':
      return Enum$SecurityAdvisorySeverity.MODERATE;
    case r'HIGH':
      return Enum$SecurityAdvisorySeverity.HIGH;
    case r'CRITICAL':
      return Enum$SecurityAdvisorySeverity.CRITICAL;
    default:
      return Enum$SecurityAdvisorySeverity.$unknown;
  }
}

enum Enum$SecurityVulnerabilityOrderField { UPDATED_AT, $unknown }

String toJson$Enum$SecurityVulnerabilityOrderField(
    Enum$SecurityVulnerabilityOrderField e) {
  switch (e) {
    case Enum$SecurityVulnerabilityOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$SecurityVulnerabilityOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityVulnerabilityOrderField
    fromJson$Enum$SecurityVulnerabilityOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$SecurityVulnerabilityOrderField.UPDATED_AT;
    default:
      return Enum$SecurityVulnerabilityOrderField.$unknown;
  }
}

enum Enum$SponsorableOrderField { LOGIN, $unknown }

String toJson$Enum$SponsorableOrderField(Enum$SponsorableOrderField e) {
  switch (e) {
    case Enum$SponsorableOrderField.LOGIN:
      return r'LOGIN';
    case Enum$SponsorableOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorableOrderField fromJson$Enum$SponsorableOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$SponsorableOrderField.LOGIN;
    default:
      return Enum$SponsorableOrderField.$unknown;
  }
}

enum Enum$SponsorOrderField { LOGIN, RELEVANCE, $unknown }

String toJson$Enum$SponsorOrderField(Enum$SponsorOrderField e) {
  switch (e) {
    case Enum$SponsorOrderField.LOGIN:
      return r'LOGIN';
    case Enum$SponsorOrderField.RELEVANCE:
      return r'RELEVANCE';
    case Enum$SponsorOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorOrderField fromJson$Enum$SponsorOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$SponsorOrderField.LOGIN;
    case r'RELEVANCE':
      return Enum$SponsorOrderField.RELEVANCE;
    default:
      return Enum$SponsorOrderField.$unknown;
  }
}

enum Enum$SponsorsActivityAction {
  NEW_SPONSORSHIP,
  CANCELLED_SPONSORSHIP,
  TIER_CHANGE,
  REFUND,
  PENDING_CHANGE,
  SPONSOR_MATCH_DISABLED,
  $unknown
}

String toJson$Enum$SponsorsActivityAction(Enum$SponsorsActivityAction e) {
  switch (e) {
    case Enum$SponsorsActivityAction.NEW_SPONSORSHIP:
      return r'NEW_SPONSORSHIP';
    case Enum$SponsorsActivityAction.CANCELLED_SPONSORSHIP:
      return r'CANCELLED_SPONSORSHIP';
    case Enum$SponsorsActivityAction.TIER_CHANGE:
      return r'TIER_CHANGE';
    case Enum$SponsorsActivityAction.REFUND:
      return r'REFUND';
    case Enum$SponsorsActivityAction.PENDING_CHANGE:
      return r'PENDING_CHANGE';
    case Enum$SponsorsActivityAction.SPONSOR_MATCH_DISABLED:
      return r'SPONSOR_MATCH_DISABLED';
    case Enum$SponsorsActivityAction.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsActivityAction fromJson$Enum$SponsorsActivityAction(String value) {
  switch (value) {
    case r'NEW_SPONSORSHIP':
      return Enum$SponsorsActivityAction.NEW_SPONSORSHIP;
    case r'CANCELLED_SPONSORSHIP':
      return Enum$SponsorsActivityAction.CANCELLED_SPONSORSHIP;
    case r'TIER_CHANGE':
      return Enum$SponsorsActivityAction.TIER_CHANGE;
    case r'REFUND':
      return Enum$SponsorsActivityAction.REFUND;
    case r'PENDING_CHANGE':
      return Enum$SponsorsActivityAction.PENDING_CHANGE;
    case r'SPONSOR_MATCH_DISABLED':
      return Enum$SponsorsActivityAction.SPONSOR_MATCH_DISABLED;
    default:
      return Enum$SponsorsActivityAction.$unknown;
  }
}

enum Enum$SponsorsActivityOrderField { TIMESTAMP, $unknown }

String toJson$Enum$SponsorsActivityOrderField(
    Enum$SponsorsActivityOrderField e) {
  switch (e) {
    case Enum$SponsorsActivityOrderField.TIMESTAMP:
      return r'TIMESTAMP';
    case Enum$SponsorsActivityOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsActivityOrderField fromJson$Enum$SponsorsActivityOrderField(
    String value) {
  switch (value) {
    case r'TIMESTAMP':
      return Enum$SponsorsActivityOrderField.TIMESTAMP;
    default:
      return Enum$SponsorsActivityOrderField.$unknown;
  }
}

enum Enum$SponsorsActivityPeriod { DAY, WEEK, MONTH, ALL, $unknown }

String toJson$Enum$SponsorsActivityPeriod(Enum$SponsorsActivityPeriod e) {
  switch (e) {
    case Enum$SponsorsActivityPeriod.DAY:
      return r'DAY';
    case Enum$SponsorsActivityPeriod.WEEK:
      return r'WEEK';
    case Enum$SponsorsActivityPeriod.MONTH:
      return r'MONTH';
    case Enum$SponsorsActivityPeriod.ALL:
      return r'ALL';
    case Enum$SponsorsActivityPeriod.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsActivityPeriod fromJson$Enum$SponsorsActivityPeriod(String value) {
  switch (value) {
    case r'DAY':
      return Enum$SponsorsActivityPeriod.DAY;
    case r'WEEK':
      return Enum$SponsorsActivityPeriod.WEEK;
    case r'MONTH':
      return Enum$SponsorsActivityPeriod.MONTH;
    case r'ALL':
      return Enum$SponsorsActivityPeriod.ALL;
    default:
      return Enum$SponsorsActivityPeriod.$unknown;
  }
}

enum Enum$SponsorsGoalKind {
  TOTAL_SPONSORS_COUNT,
  MONTHLY_SPONSORSHIP_AMOUNT,
  $unknown
}

String toJson$Enum$SponsorsGoalKind(Enum$SponsorsGoalKind e) {
  switch (e) {
    case Enum$SponsorsGoalKind.TOTAL_SPONSORS_COUNT:
      return r'TOTAL_SPONSORS_COUNT';
    case Enum$SponsorsGoalKind.MONTHLY_SPONSORSHIP_AMOUNT:
      return r'MONTHLY_SPONSORSHIP_AMOUNT';
    case Enum$SponsorsGoalKind.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsGoalKind fromJson$Enum$SponsorsGoalKind(String value) {
  switch (value) {
    case r'TOTAL_SPONSORS_COUNT':
      return Enum$SponsorsGoalKind.TOTAL_SPONSORS_COUNT;
    case r'MONTHLY_SPONSORSHIP_AMOUNT':
      return Enum$SponsorsGoalKind.MONTHLY_SPONSORSHIP_AMOUNT;
    default:
      return Enum$SponsorsGoalKind.$unknown;
  }
}

enum Enum$SponsorshipNewsletterOrderField { CREATED_AT, $unknown }

String toJson$Enum$SponsorshipNewsletterOrderField(
    Enum$SponsorshipNewsletterOrderField e) {
  switch (e) {
    case Enum$SponsorshipNewsletterOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$SponsorshipNewsletterOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorshipNewsletterOrderField
    fromJson$Enum$SponsorshipNewsletterOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$SponsorshipNewsletterOrderField.CREATED_AT;
    default:
      return Enum$SponsorshipNewsletterOrderField.$unknown;
  }
}

enum Enum$SponsorshipOrderField { CREATED_AT, $unknown }

String toJson$Enum$SponsorshipOrderField(Enum$SponsorshipOrderField e) {
  switch (e) {
    case Enum$SponsorshipOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$SponsorshipOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorshipOrderField fromJson$Enum$SponsorshipOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$SponsorshipOrderField.CREATED_AT;
    default:
      return Enum$SponsorshipOrderField.$unknown;
  }
}

enum Enum$SponsorshipPrivacy { PUBLIC, PRIVATE, $unknown }

String toJson$Enum$SponsorshipPrivacy(Enum$SponsorshipPrivacy e) {
  switch (e) {
    case Enum$SponsorshipPrivacy.PUBLIC:
      return r'PUBLIC';
    case Enum$SponsorshipPrivacy.PRIVATE:
      return r'PRIVATE';
    case Enum$SponsorshipPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorshipPrivacy fromJson$Enum$SponsorshipPrivacy(String value) {
  switch (value) {
    case r'PUBLIC':
      return Enum$SponsorshipPrivacy.PUBLIC;
    case r'PRIVATE':
      return Enum$SponsorshipPrivacy.PRIVATE;
    default:
      return Enum$SponsorshipPrivacy.$unknown;
  }
}

enum Enum$SponsorsListingFeaturedItemFeatureableType {
  REPOSITORY,
  USER,
  $unknown
}

String toJson$Enum$SponsorsListingFeaturedItemFeatureableType(
    Enum$SponsorsListingFeaturedItemFeatureableType e) {
  switch (e) {
    case Enum$SponsorsListingFeaturedItemFeatureableType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$SponsorsListingFeaturedItemFeatureableType.USER:
      return r'USER';
    case Enum$SponsorsListingFeaturedItemFeatureableType.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsListingFeaturedItemFeatureableType
    fromJson$Enum$SponsorsListingFeaturedItemFeatureableType(String value) {
  switch (value) {
    case r'REPOSITORY':
      return Enum$SponsorsListingFeaturedItemFeatureableType.REPOSITORY;
    case r'USER':
      return Enum$SponsorsListingFeaturedItemFeatureableType.USER;
    default:
      return Enum$SponsorsListingFeaturedItemFeatureableType.$unknown;
  }
}

enum Enum$SponsorsTierOrderField {
  CREATED_AT,
  MONTHLY_PRICE_IN_CENTS,
  $unknown
}

String toJson$Enum$SponsorsTierOrderField(Enum$SponsorsTierOrderField e) {
  switch (e) {
    case Enum$SponsorsTierOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$SponsorsTierOrderField.MONTHLY_PRICE_IN_CENTS:
      return r'MONTHLY_PRICE_IN_CENTS';
    case Enum$SponsorsTierOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsTierOrderField fromJson$Enum$SponsorsTierOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$SponsorsTierOrderField.CREATED_AT;
    case r'MONTHLY_PRICE_IN_CENTS':
      return Enum$SponsorsTierOrderField.MONTHLY_PRICE_IN_CENTS;
    default:
      return Enum$SponsorsTierOrderField.$unknown;
  }
}

enum Enum$SquashMergeCommitMessage { PR_BODY, COMMIT_MESSAGES, BLANK, $unknown }

String toJson$Enum$SquashMergeCommitMessage(Enum$SquashMergeCommitMessage e) {
  switch (e) {
    case Enum$SquashMergeCommitMessage.PR_BODY:
      return r'PR_BODY';
    case Enum$SquashMergeCommitMessage.COMMIT_MESSAGES:
      return r'COMMIT_MESSAGES';
    case Enum$SquashMergeCommitMessage.BLANK:
      return r'BLANK';
    case Enum$SquashMergeCommitMessage.$unknown:
      return r'$unknown';
  }
}

Enum$SquashMergeCommitMessage fromJson$Enum$SquashMergeCommitMessage(
    String value) {
  switch (value) {
    case r'PR_BODY':
      return Enum$SquashMergeCommitMessage.PR_BODY;
    case r'COMMIT_MESSAGES':
      return Enum$SquashMergeCommitMessage.COMMIT_MESSAGES;
    case r'BLANK':
      return Enum$SquashMergeCommitMessage.BLANK;
    default:
      return Enum$SquashMergeCommitMessage.$unknown;
  }
}

enum Enum$SquashMergeCommitTitle { PR_TITLE, COMMIT_OR_PR_TITLE, $unknown }

String toJson$Enum$SquashMergeCommitTitle(Enum$SquashMergeCommitTitle e) {
  switch (e) {
    case Enum$SquashMergeCommitTitle.PR_TITLE:
      return r'PR_TITLE';
    case Enum$SquashMergeCommitTitle.COMMIT_OR_PR_TITLE:
      return r'COMMIT_OR_PR_TITLE';
    case Enum$SquashMergeCommitTitle.$unknown:
      return r'$unknown';
  }
}

Enum$SquashMergeCommitTitle fromJson$Enum$SquashMergeCommitTitle(String value) {
  switch (value) {
    case r'PR_TITLE':
      return Enum$SquashMergeCommitTitle.PR_TITLE;
    case r'COMMIT_OR_PR_TITLE':
      return Enum$SquashMergeCommitTitle.COMMIT_OR_PR_TITLE;
    default:
      return Enum$SquashMergeCommitTitle.$unknown;
  }
}

enum Enum$StarOrderField { STARRED_AT, $unknown }

String toJson$Enum$StarOrderField(Enum$StarOrderField e) {
  switch (e) {
    case Enum$StarOrderField.STARRED_AT:
      return r'STARRED_AT';
    case Enum$StarOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$StarOrderField fromJson$Enum$StarOrderField(String value) {
  switch (value) {
    case r'STARRED_AT':
      return Enum$StarOrderField.STARRED_AT;
    default:
      return Enum$StarOrderField.$unknown;
  }
}

enum Enum$StatusState { EXPECTED, ERROR, FAILURE, PENDING, SUCCESS, $unknown }

String toJson$Enum$StatusState(Enum$StatusState e) {
  switch (e) {
    case Enum$StatusState.EXPECTED:
      return r'EXPECTED';
    case Enum$StatusState.ERROR:
      return r'ERROR';
    case Enum$StatusState.FAILURE:
      return r'FAILURE';
    case Enum$StatusState.PENDING:
      return r'PENDING';
    case Enum$StatusState.SUCCESS:
      return r'SUCCESS';
    case Enum$StatusState.$unknown:
      return r'$unknown';
  }
}

Enum$StatusState fromJson$Enum$StatusState(String value) {
  switch (value) {
    case r'EXPECTED':
      return Enum$StatusState.EXPECTED;
    case r'ERROR':
      return Enum$StatusState.ERROR;
    case r'FAILURE':
      return Enum$StatusState.FAILURE;
    case r'PENDING':
      return Enum$StatusState.PENDING;
    case r'SUCCESS':
      return Enum$StatusState.SUCCESS;
    default:
      return Enum$StatusState.$unknown;
  }
}

enum Enum$SubscriptionState { UNSUBSCRIBED, SUBSCRIBED, IGNORED, $unknown }

String toJson$Enum$SubscriptionState(Enum$SubscriptionState e) {
  switch (e) {
    case Enum$SubscriptionState.UNSUBSCRIBED:
      return r'UNSUBSCRIBED';
    case Enum$SubscriptionState.SUBSCRIBED:
      return r'SUBSCRIBED';
    case Enum$SubscriptionState.IGNORED:
      return r'IGNORED';
    case Enum$SubscriptionState.$unknown:
      return r'$unknown';
  }
}

Enum$SubscriptionState fromJson$Enum$SubscriptionState(String value) {
  switch (value) {
    case r'UNSUBSCRIBED':
      return Enum$SubscriptionState.UNSUBSCRIBED;
    case r'SUBSCRIBED':
      return Enum$SubscriptionState.SUBSCRIBED;
    case r'IGNORED':
      return Enum$SubscriptionState.IGNORED;
    default:
      return Enum$SubscriptionState.$unknown;
  }
}

enum Enum$TeamDiscussionCommentOrderField { NUMBER, $unknown }

String toJson$Enum$TeamDiscussionCommentOrderField(
    Enum$TeamDiscussionCommentOrderField e) {
  switch (e) {
    case Enum$TeamDiscussionCommentOrderField.NUMBER:
      return r'NUMBER';
    case Enum$TeamDiscussionCommentOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamDiscussionCommentOrderField
    fromJson$Enum$TeamDiscussionCommentOrderField(String value) {
  switch (value) {
    case r'NUMBER':
      return Enum$TeamDiscussionCommentOrderField.NUMBER;
    default:
      return Enum$TeamDiscussionCommentOrderField.$unknown;
  }
}

enum Enum$TeamDiscussionOrderField { CREATED_AT, $unknown }

String toJson$Enum$TeamDiscussionOrderField(Enum$TeamDiscussionOrderField e) {
  switch (e) {
    case Enum$TeamDiscussionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$TeamDiscussionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamDiscussionOrderField fromJson$Enum$TeamDiscussionOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$TeamDiscussionOrderField.CREATED_AT;
    default:
      return Enum$TeamDiscussionOrderField.$unknown;
  }
}

enum Enum$TeamMemberOrderField { LOGIN, CREATED_AT, $unknown }

String toJson$Enum$TeamMemberOrderField(Enum$TeamMemberOrderField e) {
  switch (e) {
    case Enum$TeamMemberOrderField.LOGIN:
      return r'LOGIN';
    case Enum$TeamMemberOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$TeamMemberOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamMemberOrderField fromJson$Enum$TeamMemberOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$TeamMemberOrderField.LOGIN;
    case r'CREATED_AT':
      return Enum$TeamMemberOrderField.CREATED_AT;
    default:
      return Enum$TeamMemberOrderField.$unknown;
  }
}

enum Enum$TeamMemberRole { MAINTAINER, MEMBER, $unknown }

String toJson$Enum$TeamMemberRole(Enum$TeamMemberRole e) {
  switch (e) {
    case Enum$TeamMemberRole.MAINTAINER:
      return r'MAINTAINER';
    case Enum$TeamMemberRole.MEMBER:
      return r'MEMBER';
    case Enum$TeamMemberRole.$unknown:
      return r'$unknown';
  }
}

Enum$TeamMemberRole fromJson$Enum$TeamMemberRole(String value) {
  switch (value) {
    case r'MAINTAINER':
      return Enum$TeamMemberRole.MAINTAINER;
    case r'MEMBER':
      return Enum$TeamMemberRole.MEMBER;
    default:
      return Enum$TeamMemberRole.$unknown;
  }
}

enum Enum$TeamMembershipType { IMMEDIATE, CHILD_TEAM, ALL, $unknown }

String toJson$Enum$TeamMembershipType(Enum$TeamMembershipType e) {
  switch (e) {
    case Enum$TeamMembershipType.IMMEDIATE:
      return r'IMMEDIATE';
    case Enum$TeamMembershipType.CHILD_TEAM:
      return r'CHILD_TEAM';
    case Enum$TeamMembershipType.ALL:
      return r'ALL';
    case Enum$TeamMembershipType.$unknown:
      return r'$unknown';
  }
}

Enum$TeamMembershipType fromJson$Enum$TeamMembershipType(String value) {
  switch (value) {
    case r'IMMEDIATE':
      return Enum$TeamMembershipType.IMMEDIATE;
    case r'CHILD_TEAM':
      return Enum$TeamMembershipType.CHILD_TEAM;
    case r'ALL':
      return Enum$TeamMembershipType.ALL;
    default:
      return Enum$TeamMembershipType.$unknown;
  }
}

enum Enum$TeamOrderField { NAME, $unknown }

String toJson$Enum$TeamOrderField(Enum$TeamOrderField e) {
  switch (e) {
    case Enum$TeamOrderField.NAME:
      return r'NAME';
    case Enum$TeamOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamOrderField fromJson$Enum$TeamOrderField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$TeamOrderField.NAME;
    default:
      return Enum$TeamOrderField.$unknown;
  }
}

enum Enum$TeamPrivacy { SECRET, VISIBLE, $unknown }

String toJson$Enum$TeamPrivacy(Enum$TeamPrivacy e) {
  switch (e) {
    case Enum$TeamPrivacy.SECRET:
      return r'SECRET';
    case Enum$TeamPrivacy.VISIBLE:
      return r'VISIBLE';
    case Enum$TeamPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$TeamPrivacy fromJson$Enum$TeamPrivacy(String value) {
  switch (value) {
    case r'SECRET':
      return Enum$TeamPrivacy.SECRET;
    case r'VISIBLE':
      return Enum$TeamPrivacy.VISIBLE;
    default:
      return Enum$TeamPrivacy.$unknown;
  }
}

enum Enum$TeamRepositoryOrderField {
  CREATED_AT,
  UPDATED_AT,
  PUSHED_AT,
  NAME,
  PERMISSION,
  STARGAZERS,
  $unknown
}

String toJson$Enum$TeamRepositoryOrderField(Enum$TeamRepositoryOrderField e) {
  switch (e) {
    case Enum$TeamRepositoryOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$TeamRepositoryOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$TeamRepositoryOrderField.PUSHED_AT:
      return r'PUSHED_AT';
    case Enum$TeamRepositoryOrderField.NAME:
      return r'NAME';
    case Enum$TeamRepositoryOrderField.PERMISSION:
      return r'PERMISSION';
    case Enum$TeamRepositoryOrderField.STARGAZERS:
      return r'STARGAZERS';
    case Enum$TeamRepositoryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamRepositoryOrderField fromJson$Enum$TeamRepositoryOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$TeamRepositoryOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$TeamRepositoryOrderField.UPDATED_AT;
    case r'PUSHED_AT':
      return Enum$TeamRepositoryOrderField.PUSHED_AT;
    case r'NAME':
      return Enum$TeamRepositoryOrderField.NAME;
    case r'PERMISSION':
      return Enum$TeamRepositoryOrderField.PERMISSION;
    case r'STARGAZERS':
      return Enum$TeamRepositoryOrderField.STARGAZERS;
    default:
      return Enum$TeamRepositoryOrderField.$unknown;
  }
}

enum Enum$TeamRole { ADMIN, MEMBER, $unknown }

String toJson$Enum$TeamRole(Enum$TeamRole e) {
  switch (e) {
    case Enum$TeamRole.ADMIN:
      return r'ADMIN';
    case Enum$TeamRole.MEMBER:
      return r'MEMBER';
    case Enum$TeamRole.$unknown:
      return r'$unknown';
  }
}

Enum$TeamRole fromJson$Enum$TeamRole(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$TeamRole.ADMIN;
    case r'MEMBER':
      return Enum$TeamRole.MEMBER;
    default:
      return Enum$TeamRole.$unknown;
  }
}

enum Enum$TopicSuggestionDeclineReason {
  NOT_RELEVANT,
  TOO_SPECIFIC,
  PERSONAL_PREFERENCE,
  TOO_GENERAL,
  $unknown
}

String toJson$Enum$TopicSuggestionDeclineReason(
    Enum$TopicSuggestionDeclineReason e) {
  switch (e) {
    case Enum$TopicSuggestionDeclineReason.NOT_RELEVANT:
      return r'NOT_RELEVANT';
    case Enum$TopicSuggestionDeclineReason.TOO_SPECIFIC:
      return r'TOO_SPECIFIC';
    case Enum$TopicSuggestionDeclineReason.PERSONAL_PREFERENCE:
      return r'PERSONAL_PREFERENCE';
    case Enum$TopicSuggestionDeclineReason.TOO_GENERAL:
      return r'TOO_GENERAL';
    case Enum$TopicSuggestionDeclineReason.$unknown:
      return r'$unknown';
  }
}

Enum$TopicSuggestionDeclineReason fromJson$Enum$TopicSuggestionDeclineReason(
    String value) {
  switch (value) {
    case r'NOT_RELEVANT':
      return Enum$TopicSuggestionDeclineReason.NOT_RELEVANT;
    case r'TOO_SPECIFIC':
      return Enum$TopicSuggestionDeclineReason.TOO_SPECIFIC;
    case r'PERSONAL_PREFERENCE':
      return Enum$TopicSuggestionDeclineReason.PERSONAL_PREFERENCE;
    case r'TOO_GENERAL':
      return Enum$TopicSuggestionDeclineReason.TOO_GENERAL;
    default:
      return Enum$TopicSuggestionDeclineReason.$unknown;
  }
}

enum Enum$TrackedIssueStates { OPEN, CLOSED, $unknown }

String toJson$Enum$TrackedIssueStates(Enum$TrackedIssueStates e) {
  switch (e) {
    case Enum$TrackedIssueStates.OPEN:
      return r'OPEN';
    case Enum$TrackedIssueStates.CLOSED:
      return r'CLOSED';
    case Enum$TrackedIssueStates.$unknown:
      return r'$unknown';
  }
}

Enum$TrackedIssueStates fromJson$Enum$TrackedIssueStates(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$TrackedIssueStates.OPEN;
    case r'CLOSED':
      return Enum$TrackedIssueStates.CLOSED;
    default:
      return Enum$TrackedIssueStates.$unknown;
  }
}

enum Enum$UserBlockDuration {
  ONE_DAY,
  THREE_DAYS,
  ONE_WEEK,
  ONE_MONTH,
  PERMANENT,
  $unknown
}

String toJson$Enum$UserBlockDuration(Enum$UserBlockDuration e) {
  switch (e) {
    case Enum$UserBlockDuration.ONE_DAY:
      return r'ONE_DAY';
    case Enum$UserBlockDuration.THREE_DAYS:
      return r'THREE_DAYS';
    case Enum$UserBlockDuration.ONE_WEEK:
      return r'ONE_WEEK';
    case Enum$UserBlockDuration.ONE_MONTH:
      return r'ONE_MONTH';
    case Enum$UserBlockDuration.PERMANENT:
      return r'PERMANENT';
    case Enum$UserBlockDuration.$unknown:
      return r'$unknown';
  }
}

Enum$UserBlockDuration fromJson$Enum$UserBlockDuration(String value) {
  switch (value) {
    case r'ONE_DAY':
      return Enum$UserBlockDuration.ONE_DAY;
    case r'THREE_DAYS':
      return Enum$UserBlockDuration.THREE_DAYS;
    case r'ONE_WEEK':
      return Enum$UserBlockDuration.ONE_WEEK;
    case r'ONE_MONTH':
      return Enum$UserBlockDuration.ONE_MONTH;
    case r'PERMANENT':
      return Enum$UserBlockDuration.PERMANENT;
    default:
      return Enum$UserBlockDuration.$unknown;
  }
}

enum Enum$UserStatusOrderField { UPDATED_AT, $unknown }

String toJson$Enum$UserStatusOrderField(Enum$UserStatusOrderField e) {
  switch (e) {
    case Enum$UserStatusOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$UserStatusOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$UserStatusOrderField fromJson$Enum$UserStatusOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$UserStatusOrderField.UPDATED_AT;
    default:
      return Enum$UserStatusOrderField.$unknown;
  }
}

enum Enum$VerifiableDomainOrderField { DOMAIN, CREATED_AT, $unknown }

String toJson$Enum$VerifiableDomainOrderField(
    Enum$VerifiableDomainOrderField e) {
  switch (e) {
    case Enum$VerifiableDomainOrderField.DOMAIN:
      return r'DOMAIN';
    case Enum$VerifiableDomainOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$VerifiableDomainOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$VerifiableDomainOrderField fromJson$Enum$VerifiableDomainOrderField(
    String value) {
  switch (value) {
    case r'DOMAIN':
      return Enum$VerifiableDomainOrderField.DOMAIN;
    case r'CREATED_AT':
      return Enum$VerifiableDomainOrderField.CREATED_AT;
    default:
      return Enum$VerifiableDomainOrderField.$unknown;
  }
}

enum Enum$WorkflowRunOrderField { CREATED_AT, $unknown }

String toJson$Enum$WorkflowRunOrderField(Enum$WorkflowRunOrderField e) {
  switch (e) {
    case Enum$WorkflowRunOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$WorkflowRunOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$WorkflowRunOrderField fromJson$Enum$WorkflowRunOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$WorkflowRunOrderField.CREATED_AT;
    default:
      return Enum$WorkflowRunOrderField.$unknown;
  }
}

const possibleTypesMap = {
  'Node': {
    'AddedToProjectEvent',
    'App',
    'AssignedEvent',
    'AutomaticBaseChangeFailedEvent',
    'AutomaticBaseChangeSucceededEvent',
    'AutoMergeDisabledEvent',
    'AutoMergeEnabledEvent',
    'AutoRebaseEnabledEvent',
    'AutoSquashEnabledEvent',
    'BaseRefChangedEvent',
    'BaseRefDeletedEvent',
    'BaseRefForcePushedEvent',
    'Blob',
    'Bot',
    'BranchProtectionRule',
    'BypassForcePushAllowance',
    'BypassPullRequestAllowance',
    'CheckRun',
    'CheckSuite',
    'ClosedEvent',
    'CodeOfConduct',
    'CommentDeletedEvent',
    'Commit',
    'CommitComment',
    'CommitCommentThread',
    'Comparison',
    'ConnectedEvent',
    'ConvertedNoteToIssueEvent',
    'ConvertedToDiscussionEvent',
    'ConvertToDraftEvent',
    'CrossReferencedEvent',
    'CWE',
    'DemilestonedEvent',
    'DeployedEvent',
    'DeployKey',
    'Deployment',
    'DeploymentEnvironmentChangedEvent',
    'DeploymentReview',
    'DeploymentStatus',
    'DisconnectedEvent',
    'Discussion',
    'DiscussionCategory',
    'DiscussionComment',
    'DiscussionPoll',
    'DiscussionPollOption',
    'DraftIssue',
    'Enterprise',
    'EnterpriseAdministratorInvitation',
    'EnterpriseIdentityProvider',
    'EnterpriseRepositoryInfo',
    'EnterpriseServerInstallation',
    'EnterpriseServerUserAccount',
    'EnterpriseServerUserAccountEmail',
    'EnterpriseServerUserAccountsUpload',
    'EnterpriseUserAccount',
    'Environment',
    'ExternalIdentity',
    'Gist',
    'GistComment',
    'HeadRefDeletedEvent',
    'HeadRefForcePushedEvent',
    'HeadRefRestoredEvent',
    'IpAllowListEntry',
    'Issue',
    'IssueComment',
    'Label',
    'LabeledEvent',
    'Language',
    'License',
    'LinkedBranch',
    'LockedEvent',
    'Mannequin',
    'MarkedAsDuplicateEvent',
    'MarketplaceCategory',
    'MarketplaceListing',
    'MembersCanDeleteReposClearAuditEntry',
    'MembersCanDeleteReposDisableAuditEntry',
    'MembersCanDeleteReposEnableAuditEntry',
    'MentionedEvent',
    'MergedEvent',
    'MigrationSource',
    'Milestone',
    'MilestonedEvent',
    'MovedColumnsInProjectEvent',
    'OauthApplicationCreateAuditEntry',
    'OIDCProvider',
    'OrgAddBillingManagerAuditEntry',
    'OrgAddMemberAuditEntry',
    'Organization',
    'OrganizationIdentityProvider',
    'OrganizationInvitation',
    'OrgBlockUserAuditEntry',
    'OrgConfigDisableCollaboratorsOnlyAuditEntry',
    'OrgConfigEnableCollaboratorsOnlyAuditEntry',
    'OrgCreateAuditEntry',
    'OrgDisableOauthAppRestrictionsAuditEntry',
    'OrgDisableSamlAuditEntry',
    'OrgDisableTwoFactorRequirementAuditEntry',
    'OrgEnableOauthAppRestrictionsAuditEntry',
    'OrgEnableSamlAuditEntry',
    'OrgEnableTwoFactorRequirementAuditEntry',
    'OrgInviteMemberAuditEntry',
    'OrgInviteToBusinessAuditEntry',
    'OrgOauthAppAccessApprovedAuditEntry',
    'OrgOauthAppAccessDeniedAuditEntry',
    'OrgOauthAppAccessRequestedAuditEntry',
    'OrgRemoveBillingManagerAuditEntry',
    'OrgRemoveMemberAuditEntry',
    'OrgRemoveOutsideCollaboratorAuditEntry',
    'OrgRestoreMemberAuditEntry',
    'OrgUnblockUserAuditEntry',
    'OrgUpdateDefaultRepositoryPermissionAuditEntry',
    'OrgUpdateMemberAuditEntry',
    'OrgUpdateMemberRepositoryCreationPermissionAuditEntry',
    'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry',
    'Package',
    'PackageFile',
    'PackageTag',
    'PackageVersion',
    'PinnedDiscussion',
    'PinnedEvent',
    'PinnedIssue',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'Project',
    'ProjectCard',
    'ProjectColumn',
    'ProjectNext',
    'ProjectNextField',
    'ProjectNextItem',
    'ProjectNextItemFieldValue',
    'ProjectV2',
    'ProjectV2Field',
    'ProjectV2Item',
    'ProjectV2ItemFieldDateValue',
    'ProjectV2ItemFieldIterationValue',
    'ProjectV2ItemFieldNumberValue',
    'ProjectV2ItemFieldSingleSelectValue',
    'ProjectV2ItemFieldTextValue',
    'ProjectV2IterationField',
    'ProjectV2SingleSelectField',
    'ProjectV2View',
    'ProjectView',
    'PublicKey',
    'PullRequest',
    'PullRequestCommit',
    'PullRequestCommitCommentThread',
    'PullRequestReview',
    'PullRequestReviewComment',
    'PullRequestReviewThread',
    'PullRequestThread',
    'Push',
    'PushAllowance',
    'Reaction',
    'ReadyForReviewEvent',
    'Ref',
    'ReferencedEvent',
    'Release',
    'ReleaseAsset',
    'RemovedFromProjectEvent',
    'RenamedTitleEvent',
    'ReopenedEvent',
    'RepoAccessAuditEntry',
    'RepoAddMemberAuditEntry',
    'RepoAddTopicAuditEntry',
    'RepoArchivedAuditEntry',
    'RepoChangeMergeSettingAuditEntry',
    'RepoConfigDisableAnonymousGitAccessAuditEntry',
    'RepoConfigDisableCollaboratorsOnlyAuditEntry',
    'RepoConfigDisableContributorsOnlyAuditEntry',
    'RepoConfigDisableSockpuppetDisallowedAuditEntry',
    'RepoConfigEnableAnonymousGitAccessAuditEntry',
    'RepoConfigEnableCollaboratorsOnlyAuditEntry',
    'RepoConfigEnableContributorsOnlyAuditEntry',
    'RepoConfigEnableSockpuppetDisallowedAuditEntry',
    'RepoConfigLockAnonymousGitAccessAuditEntry',
    'RepoConfigUnlockAnonymousGitAccessAuditEntry',
    'RepoCreateAuditEntry',
    'RepoDestroyAuditEntry',
    'RepoRemoveMemberAuditEntry',
    'RepoRemoveTopicAuditEntry',
    'Repository',
    'RepositoryInvitation',
    'RepositoryMigration',
    'RepositoryTopic',
    'RepositoryVisibilityChangeDisableAuditEntry',
    'RepositoryVisibilityChangeEnableAuditEntry',
    'RepositoryVulnerabilityAlert',
    'ReviewDismissalAllowance',
    'ReviewDismissedEvent',
    'ReviewRequest',
    'ReviewRequestedEvent',
    'ReviewRequestRemovedEvent',
    'SavedReply',
    'SecurityAdvisory',
    'SponsorsActivity',
    'Sponsorship',
    'SponsorshipNewsletter',
    'SponsorsListing',
    'SponsorsListingFeaturedItem',
    'SponsorsTier',
    'Status',
    'StatusCheckRollup',
    'StatusContext',
    'SubscribedEvent',
    'Tag',
    'Team',
    'TeamAddMemberAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamChangeParentTeamAuditEntry',
    'TeamDiscussion',
    'TeamDiscussionComment',
    'TeamRemoveMemberAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
    'Topic',
    'TransferredEvent',
    'Tree',
    'UnassignedEvent',
    'UnlabeledEvent',
    'UnlockedEvent',
    'UnmarkedAsDuplicateEvent',
    'UnpinnedEvent',
    'UnsubscribedEvent',
    'User',
    'UserBlockedEvent',
    'UserContentEdit',
    'UserStatus',
    'VerifiableDomain',
    'Workflow',
    'WorkflowRun',
  },
  'Assignee': {
    'Bot',
    'Mannequin',
    'Organization',
    'User',
  },
  'AuditEntryActor': {
    'Bot',
    'Organization',
    'User',
  },
  'GitObject': {
    'Blob',
    'Commit',
    'Tag',
    'Tree',
  },
  'Actor': {
    'Bot',
    'EnterpriseUserAccount',
    'Mannequin',
    'Organization',
    'User',
  },
  'UniformResourceLocatable': {
    'Bot',
    'CheckRun',
    'ClosedEvent',
    'Commit',
    'ConvertToDraftEvent',
    'CrossReferencedEvent',
    'Gist',
    'Issue',
    'Mannequin',
    'MergedEvent',
    'Milestone',
    'Organization',
    'PullRequest',
    'PullRequestCommit',
    'ReadyForReviewEvent',
    'Release',
    'Repository',
    'RepositoryTopic',
    'ReviewDismissedEvent',
    'TeamDiscussion',
    'TeamDiscussionComment',
    'User',
  },
  'BranchActorAllowanceActor': {
    'App',
    'Team',
    'User',
  },
  'RequirableByPullRequest': {
    'CheckRun',
    'StatusContext',
  },
  'Closer': {
    'Commit',
    'PullRequest',
  },
  'Subscribable': {
    'Commit',
    'Discussion',
    'Issue',
    'PullRequest',
    'Repository',
    'Team',
    'TeamDiscussion',
  },
  'Comment': {
    'CommitComment',
    'Discussion',
    'DiscussionComment',
    'GistComment',
    'Issue',
    'IssueComment',
    'PullRequest',
    'PullRequestReview',
    'PullRequestReviewComment',
    'TeamDiscussion',
    'TeamDiscussionComment',
  },
  'Deletable': {
    'CommitComment',
    'Discussion',
    'DiscussionComment',
    'GistComment',
    'IssueComment',
    'PullRequestReview',
    'PullRequestReviewComment',
    'TeamDiscussion',
    'TeamDiscussionComment',
  },
  'Minimizable': {
    'CommitComment',
    'DiscussionComment',
    'GistComment',
    'IssueComment',
    'PullRequestReviewComment',
  },
  'Updatable': {
    'CommitComment',
    'Discussion',
    'DiscussionComment',
    'GistComment',
    'Issue',
    'IssueComment',
    'Project',
    'ProjectNext',
    'ProjectV2',
    'PullRequest',
    'PullRequestReview',
    'PullRequestReviewComment',
    'TeamDiscussion',
    'TeamDiscussionComment',
  },
  'UpdatableComment': {
    'CommitComment',
    'DiscussionComment',
    'GistComment',
    'Issue',
    'IssueComment',
    'PullRequest',
    'PullRequestReview',
    'PullRequestReviewComment',
    'TeamDiscussion',
    'TeamDiscussionComment',
  },
  'Reactable': {
    'CommitComment',
    'Discussion',
    'DiscussionComment',
    'Issue',
    'IssueComment',
    'PullRequest',
    'PullRequestReview',
    'PullRequestReviewComment',
    'Release',
    'TeamDiscussion',
    'TeamDiscussionComment',
  },
  'RepositoryNode': {
    'CommitComment',
    'CommitCommentThread',
    'DependabotUpdate',
    'Discussion',
    'DiscussionCategory',
    'Issue',
    'IssueComment',
    'PinnedDiscussion',
    'PullRequest',
    'PullRequestCommitCommentThread',
    'PullRequestReview',
    'PullRequestReviewComment',
    'RepositoryVulnerabilityAlert',
  },
  'Contribution': {
    'CreatedCommitContribution',
    'CreatedIssueContribution',
    'CreatedPullRequestContribution',
    'CreatedPullRequestReviewContribution',
    'CreatedRepositoryContribution',
    'JoinedGitHubContribution',
    'RestrictedContribution',
  },
  'CreatedIssueOrRestrictedContribution': {
    'CreatedIssueContribution',
    'RestrictedContribution',
  },
  'CreatedPullRequestOrRestrictedContribution': {
    'CreatedPullRequestContribution',
    'RestrictedContribution',
  },
  'CreatedRepositoryOrRestrictedContribution': {
    'CreatedRepositoryContribution',
    'RestrictedContribution',
  },
  'DeploymentReviewer': {
    'Team',
    'User',
  },
  'Labelable': {
    'Discussion',
    'Issue',
    'PullRequest',
  },
  'Lockable': {
    'Discussion',
    'Issue',
    'PullRequest',
  },
  'Votable': {
    'Discussion',
    'DiscussionComment',
  },
  'EnterpriseMember': {
    'EnterpriseUserAccount',
    'User',
  },
  'HovercardContext': {
    'GenericHovercardContext',
    'OrganizationsHovercardContext',
    'OrganizationTeamsHovercardContext',
    'ReviewStatusHovercardContext',
    'ViewerHovercardContext',
  },
  'Starrable': {
    'Gist',
    'Repository',
    'Topic',
  },
  'GitSignature': {
    'GpgSignature',
    'SmimeSignature',
    'SshSignature',
    'UnknownSignature',
  },
  'IpAllowListOwner': {
    'App',
    'Enterprise',
    'Organization',
  },
  'Assignable': {
    'Issue',
    'PullRequest',
  },
  'Closable': {
    'Issue',
    'Milestone',
    'Project',
    'ProjectNext',
    'ProjectV2',
    'PullRequest',
  },
  'ProjectNextOwner': {
    'Issue',
    'Organization',
    'PullRequest',
    'User',
  },
  'ProjectV2Owner': {
    'Issue',
    'Organization',
    'PullRequest',
    'User',
  },
  'IssueOrPullRequest': {
    'Issue',
    'PullRequest',
  },
  'IssueTimelineItem': {
    'AssignedEvent',
    'ClosedEvent',
    'Commit',
    'CrossReferencedEvent',
    'DemilestonedEvent',
    'IssueComment',
    'LabeledEvent',
    'LockedEvent',
    'MilestonedEvent',
    'ReferencedEvent',
    'RenamedTitleEvent',
    'ReopenedEvent',
    'SubscribedEvent',
    'TransferredEvent',
    'UnassignedEvent',
    'UnlabeledEvent',
    'UnlockedEvent',
    'UnsubscribedEvent',
    'UserBlockedEvent',
  },
  'IssueTimelineItems': {
    'AddedToProjectEvent',
    'AssignedEvent',
    'ClosedEvent',
    'CommentDeletedEvent',
    'ConnectedEvent',
    'ConvertedNoteToIssueEvent',
    'ConvertedToDiscussionEvent',
    'CrossReferencedEvent',
    'DemilestonedEvent',
    'DisconnectedEvent',
    'IssueComment',
    'LabeledEvent',
    'LockedEvent',
    'MarkedAsDuplicateEvent',
    'MentionedEvent',
    'MilestonedEvent',
    'MovedColumnsInProjectEvent',
    'PinnedEvent',
    'ReferencedEvent',
    'RemovedFromProjectEvent',
    'RenamedTitleEvent',
    'ReopenedEvent',
    'SubscribedEvent',
    'TransferredEvent',
    'UnassignedEvent',
    'UnlabeledEvent',
    'UnlockedEvent',
    'UnmarkedAsDuplicateEvent',
    'UnpinnedEvent',
    'UnsubscribedEvent',
    'UserBlockedEvent',
  },
  'AuditEntry': {
    'MembersCanDeleteReposClearAuditEntry',
    'MembersCanDeleteReposDisableAuditEntry',
    'MembersCanDeleteReposEnableAuditEntry',
    'OauthApplicationCreateAuditEntry',
    'OrgAddBillingManagerAuditEntry',
    'OrgAddMemberAuditEntry',
    'OrgBlockUserAuditEntry',
    'OrgConfigDisableCollaboratorsOnlyAuditEntry',
    'OrgConfigEnableCollaboratorsOnlyAuditEntry',
    'OrgCreateAuditEntry',
    'OrgDisableOauthAppRestrictionsAuditEntry',
    'OrgDisableSamlAuditEntry',
    'OrgDisableTwoFactorRequirementAuditEntry',
    'OrgEnableOauthAppRestrictionsAuditEntry',
    'OrgEnableSamlAuditEntry',
    'OrgEnableTwoFactorRequirementAuditEntry',
    'OrgInviteMemberAuditEntry',
    'OrgInviteToBusinessAuditEntry',
    'OrgOauthAppAccessApprovedAuditEntry',
    'OrgOauthAppAccessDeniedAuditEntry',
    'OrgOauthAppAccessRequestedAuditEntry',
    'OrgRemoveBillingManagerAuditEntry',
    'OrgRemoveMemberAuditEntry',
    'OrgRemoveOutsideCollaboratorAuditEntry',
    'OrgRestoreMemberAuditEntry',
    'OrgUnblockUserAuditEntry',
    'OrgUpdateDefaultRepositoryPermissionAuditEntry',
    'OrgUpdateMemberAuditEntry',
    'OrgUpdateMemberRepositoryCreationPermissionAuditEntry',
    'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'RepoAccessAuditEntry',
    'RepoAddMemberAuditEntry',
    'RepoAddTopicAuditEntry',
    'RepoArchivedAuditEntry',
    'RepoChangeMergeSettingAuditEntry',
    'RepoConfigDisableAnonymousGitAccessAuditEntry',
    'RepoConfigDisableCollaboratorsOnlyAuditEntry',
    'RepoConfigDisableContributorsOnlyAuditEntry',
    'RepoConfigDisableSockpuppetDisallowedAuditEntry',
    'RepoConfigEnableAnonymousGitAccessAuditEntry',
    'RepoConfigEnableCollaboratorsOnlyAuditEntry',
    'RepoConfigEnableContributorsOnlyAuditEntry',
    'RepoConfigEnableSockpuppetDisallowedAuditEntry',
    'RepoConfigLockAnonymousGitAccessAuditEntry',
    'RepoConfigUnlockAnonymousGitAccessAuditEntry',
    'RepoCreateAuditEntry',
    'RepoDestroyAuditEntry',
    'RepoRemoveMemberAuditEntry',
    'RepoRemoveTopicAuditEntry',
    'RepositoryVisibilityChangeDisableAuditEntry',
    'RepositoryVisibilityChangeEnableAuditEntry',
    'TeamAddMemberAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamChangeParentTeamAuditEntry',
    'TeamRemoveMemberAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
  },
  'EnterpriseAuditEntryData': {
    'MembersCanDeleteReposClearAuditEntry',
    'MembersCanDeleteReposDisableAuditEntry',
    'MembersCanDeleteReposEnableAuditEntry',
    'OrgInviteToBusinessAuditEntry',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'RepositoryVisibilityChangeDisableAuditEntry',
    'RepositoryVisibilityChangeEnableAuditEntry',
  },
  'OrganizationAuditEntryData': {
    'MembersCanDeleteReposClearAuditEntry',
    'MembersCanDeleteReposDisableAuditEntry',
    'MembersCanDeleteReposEnableAuditEntry',
    'OauthApplicationCreateAuditEntry',
    'OrgAddBillingManagerAuditEntry',
    'OrgAddMemberAuditEntry',
    'OrgBlockUserAuditEntry',
    'OrgConfigDisableCollaboratorsOnlyAuditEntry',
    'OrgConfigEnableCollaboratorsOnlyAuditEntry',
    'OrgCreateAuditEntry',
    'OrgDisableOauthAppRestrictionsAuditEntry',
    'OrgDisableSamlAuditEntry',
    'OrgDisableTwoFactorRequirementAuditEntry',
    'OrgEnableOauthAppRestrictionsAuditEntry',
    'OrgEnableSamlAuditEntry',
    'OrgEnableTwoFactorRequirementAuditEntry',
    'OrgInviteMemberAuditEntry',
    'OrgInviteToBusinessAuditEntry',
    'OrgOauthAppAccessApprovedAuditEntry',
    'OrgOauthAppAccessDeniedAuditEntry',
    'OrgOauthAppAccessRequestedAuditEntry',
    'OrgRemoveBillingManagerAuditEntry',
    'OrgRemoveMemberAuditEntry',
    'OrgRemoveOutsideCollaboratorAuditEntry',
    'OrgRestoreMemberAuditEntry',
    'OrgRestoreMemberMembershipOrganizationAuditEntryData',
    'OrgUnblockUserAuditEntry',
    'OrgUpdateDefaultRepositoryPermissionAuditEntry',
    'OrgUpdateMemberAuditEntry',
    'OrgUpdateMemberRepositoryCreationPermissionAuditEntry',
    'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'RepoAccessAuditEntry',
    'RepoAddMemberAuditEntry',
    'RepoAddTopicAuditEntry',
    'RepoArchivedAuditEntry',
    'RepoChangeMergeSettingAuditEntry',
    'RepoConfigDisableAnonymousGitAccessAuditEntry',
    'RepoConfigDisableCollaboratorsOnlyAuditEntry',
    'RepoConfigDisableContributorsOnlyAuditEntry',
    'RepoConfigDisableSockpuppetDisallowedAuditEntry',
    'RepoConfigEnableAnonymousGitAccessAuditEntry',
    'RepoConfigEnableCollaboratorsOnlyAuditEntry',
    'RepoConfigEnableContributorsOnlyAuditEntry',
    'RepoConfigEnableSockpuppetDisallowedAuditEntry',
    'RepoConfigLockAnonymousGitAccessAuditEntry',
    'RepoConfigUnlockAnonymousGitAccessAuditEntry',
    'RepoCreateAuditEntry',
    'RepoDestroyAuditEntry',
    'RepoRemoveMemberAuditEntry',
    'RepoRemoveTopicAuditEntry',
    'RepositoryVisibilityChangeDisableAuditEntry',
    'RepositoryVisibilityChangeEnableAuditEntry',
    'TeamAddMemberAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamChangeParentTeamAuditEntry',
    'TeamRemoveMemberAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
  },
  'MilestoneItem': {
    'Issue',
    'PullRequest',
  },
  'OauthApplicationAuditEntryData': {
    'OauthApplicationCreateAuditEntry',
    'OrgOauthAppAccessApprovedAuditEntry',
    'OrgOauthAppAccessDeniedAuditEntry',
    'OrgOauthAppAccessRequestedAuditEntry',
  },
  'PackageOwner': {
    'Organization',
    'Repository',
    'User',
  },
  'ProjectOwner': {
    'Organization',
    'Repository',
    'User',
  },
  'ProjectV2Recent': {
    'Organization',
    'Repository',
    'User',
  },
  'RepositoryDiscussionAuthor': {
    'Organization',
    'User',
  },
  'RepositoryDiscussionCommentAuthor': {
    'Organization',
    'User',
  },
  'RepositoryOwner': {
    'Organization',
    'User',
  },
  'MemberStatusable': {
    'Organization',
    'Team',
  },
  'ProfileOwner': {
    'Organization',
    'User',
  },
  'Sponsorable': {
    'Organization',
    'User',
  },
  'OrganizationAuditEntry': {
    'MembersCanDeleteReposClearAuditEntry',
    'MembersCanDeleteReposDisableAuditEntry',
    'MembersCanDeleteReposEnableAuditEntry',
    'OauthApplicationCreateAuditEntry',
    'OrgAddBillingManagerAuditEntry',
    'OrgAddMemberAuditEntry',
    'OrgBlockUserAuditEntry',
    'OrgConfigDisableCollaboratorsOnlyAuditEntry',
    'OrgConfigEnableCollaboratorsOnlyAuditEntry',
    'OrgCreateAuditEntry',
    'OrgDisableOauthAppRestrictionsAuditEntry',
    'OrgDisableSamlAuditEntry',
    'OrgDisableTwoFactorRequirementAuditEntry',
    'OrgEnableOauthAppRestrictionsAuditEntry',
    'OrgEnableSamlAuditEntry',
    'OrgEnableTwoFactorRequirementAuditEntry',
    'OrgInviteMemberAuditEntry',
    'OrgInviteToBusinessAuditEntry',
    'OrgOauthAppAccessApprovedAuditEntry',
    'OrgOauthAppAccessDeniedAuditEntry',
    'OrgOauthAppAccessRequestedAuditEntry',
    'OrgRemoveBillingManagerAuditEntry',
    'OrgRemoveMemberAuditEntry',
    'OrgRemoveOutsideCollaboratorAuditEntry',
    'OrgRestoreMemberAuditEntry',
    'OrgUnblockUserAuditEntry',
    'OrgUpdateDefaultRepositoryPermissionAuditEntry',
    'OrgUpdateMemberAuditEntry',
    'OrgUpdateMemberRepositoryCreationPermissionAuditEntry',
    'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'RepoAccessAuditEntry',
    'RepoAddMemberAuditEntry',
    'RepoAddTopicAuditEntry',
    'RepoArchivedAuditEntry',
    'RepoChangeMergeSettingAuditEntry',
    'RepoConfigDisableAnonymousGitAccessAuditEntry',
    'RepoConfigDisableCollaboratorsOnlyAuditEntry',
    'RepoConfigDisableContributorsOnlyAuditEntry',
    'RepoConfigDisableSockpuppetDisallowedAuditEntry',
    'RepoConfigEnableAnonymousGitAccessAuditEntry',
    'RepoConfigEnableCollaboratorsOnlyAuditEntry',
    'RepoConfigEnableContributorsOnlyAuditEntry',
    'RepoConfigEnableSockpuppetDisallowedAuditEntry',
    'RepoConfigLockAnonymousGitAccessAuditEntry',
    'RepoConfigUnlockAnonymousGitAccessAuditEntry',
    'RepoCreateAuditEntry',
    'RepoDestroyAuditEntry',
    'RepoRemoveMemberAuditEntry',
    'RepoRemoveTopicAuditEntry',
    'RepositoryVisibilityChangeDisableAuditEntry',
    'RepositoryVisibilityChangeEnableAuditEntry',
    'TeamAddMemberAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamChangeParentTeamAuditEntry',
    'TeamRemoveMemberAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
  },
  'OrganizationOrUser': {
    'Organization',
    'User',
  },
  'OrgRestoreMemberAuditEntryMembership': {
    'OrgRestoreMemberMembershipOrganizationAuditEntryData',
    'OrgRestoreMemberMembershipRepositoryAuditEntryData',
    'OrgRestoreMemberMembershipTeamAuditEntryData',
  },
  'RepositoryAuditEntryData': {
    'OrgRestoreMemberMembershipRepositoryAuditEntryData',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'RepoAccessAuditEntry',
    'RepoAddMemberAuditEntry',
    'RepoAddTopicAuditEntry',
    'RepoArchivedAuditEntry',
    'RepoChangeMergeSettingAuditEntry',
    'RepoConfigDisableAnonymousGitAccessAuditEntry',
    'RepoConfigDisableCollaboratorsOnlyAuditEntry',
    'RepoConfigDisableContributorsOnlyAuditEntry',
    'RepoConfigDisableSockpuppetDisallowedAuditEntry',
    'RepoConfigEnableAnonymousGitAccessAuditEntry',
    'RepoConfigEnableCollaboratorsOnlyAuditEntry',
    'RepoConfigEnableContributorsOnlyAuditEntry',
    'RepoConfigEnableSockpuppetDisallowedAuditEntry',
    'RepoConfigLockAnonymousGitAccessAuditEntry',
    'RepoConfigUnlockAnonymousGitAccessAuditEntry',
    'RepoCreateAuditEntry',
    'RepoDestroyAuditEntry',
    'RepoRemoveMemberAuditEntry',
    'RepoRemoveTopicAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
  },
  'TeamAuditEntryData': {
    'OrgRestoreMemberMembershipTeamAuditEntryData',
    'TeamAddMemberAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamChangeParentTeamAuditEntry',
    'TeamRemoveMemberAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
  },
  'PermissionGranter': {
    'Organization',
    'Repository',
    'Team',
  },
  'PinnableItem': {
    'Gist',
    'Repository',
  },
  'ProjectCardItem': {
    'Issue',
    'PullRequest',
  },
  'ProjectNextFieldCommon': {'ProjectNextField'},
  'ProjectNextItemContent': {
    'DraftIssue',
    'Issue',
    'PullRequest',
  },
  'ProjectV2FieldCommon': {
    'ProjectV2Field',
    'ProjectV2IterationField',
    'ProjectV2SingleSelectField',
  },
  'ProjectV2FieldConfiguration': {
    'ProjectV2Field',
    'ProjectV2IterationField',
    'ProjectV2SingleSelectField',
  },
  'ProjectV2ItemContent': {
    'DraftIssue',
    'Issue',
    'PullRequest',
  },
  'ProjectV2ItemFieldValueCommon': {
    'ProjectV2ItemFieldDateValue',
    'ProjectV2ItemFieldIterationValue',
    'ProjectV2ItemFieldNumberValue',
    'ProjectV2ItemFieldSingleSelectValue',
    'ProjectV2ItemFieldTextValue',
  },
  'ProjectV2ItemFieldValue': {
    'ProjectV2ItemFieldDateValue',
    'ProjectV2ItemFieldIterationValue',
    'ProjectV2ItemFieldLabelValue',
    'ProjectV2ItemFieldMilestoneValue',
    'ProjectV2ItemFieldNumberValue',
    'ProjectV2ItemFieldPullRequestValue',
    'ProjectV2ItemFieldRepositoryValue',
    'ProjectV2ItemFieldReviewerValue',
    'ProjectV2ItemFieldSingleSelectValue',
    'ProjectV2ItemFieldTextValue',
    'ProjectV2ItemFieldUserValue',
  },
  'PullRequestTimelineItem': {
    'AssignedEvent',
    'BaseRefDeletedEvent',
    'BaseRefForcePushedEvent',
    'ClosedEvent',
    'Commit',
    'CommitCommentThread',
    'CrossReferencedEvent',
    'DemilestonedEvent',
    'DeployedEvent',
    'DeploymentEnvironmentChangedEvent',
    'HeadRefDeletedEvent',
    'HeadRefForcePushedEvent',
    'HeadRefRestoredEvent',
    'IssueComment',
    'LabeledEvent',
    'LockedEvent',
    'MergedEvent',
    'MilestonedEvent',
    'PullRequestReview',
    'PullRequestReviewComment',
    'PullRequestReviewThread',
    'ReferencedEvent',
    'RenamedTitleEvent',
    'ReopenedEvent',
    'ReviewDismissedEvent',
    'ReviewRequestRemovedEvent',
    'ReviewRequestedEvent',
    'SubscribedEvent',
    'UnassignedEvent',
    'UnlabeledEvent',
    'UnlockedEvent',
    'UnsubscribedEvent',
    'UserBlockedEvent',
  },
  'PullRequestTimelineItems': {
    'AddedToProjectEvent',
    'AssignedEvent',
    'AutoMergeDisabledEvent',
    'AutoMergeEnabledEvent',
    'AutoRebaseEnabledEvent',
    'AutoSquashEnabledEvent',
    'AutomaticBaseChangeFailedEvent',
    'AutomaticBaseChangeSucceededEvent',
    'BaseRefChangedEvent',
    'BaseRefDeletedEvent',
    'BaseRefForcePushedEvent',
    'ClosedEvent',
    'CommentDeletedEvent',
    'ConnectedEvent',
    'ConvertToDraftEvent',
    'ConvertedNoteToIssueEvent',
    'ConvertedToDiscussionEvent',
    'CrossReferencedEvent',
    'DemilestonedEvent',
    'DeployedEvent',
    'DeploymentEnvironmentChangedEvent',
    'DisconnectedEvent',
    'HeadRefDeletedEvent',
    'HeadRefForcePushedEvent',
    'HeadRefRestoredEvent',
    'IssueComment',
    'LabeledEvent',
    'LockedEvent',
    'MarkedAsDuplicateEvent',
    'MentionedEvent',
    'MergedEvent',
    'MilestonedEvent',
    'MovedColumnsInProjectEvent',
    'PinnedEvent',
    'PullRequestCommit',
    'PullRequestCommitCommentThread',
    'PullRequestReview',
    'PullRequestReviewThread',
    'PullRequestRevisionMarker',
    'ReadyForReviewEvent',
    'ReferencedEvent',
    'RemovedFromProjectEvent',
    'RenamedTitleEvent',
    'ReopenedEvent',
    'ReviewDismissedEvent',
    'ReviewRequestRemovedEvent',
    'ReviewRequestedEvent',
    'SubscribedEvent',
    'TransferredEvent',
    'UnassignedEvent',
    'UnlabeledEvent',
    'UnlockedEvent',
    'UnmarkedAsDuplicateEvent',
    'UnpinnedEvent',
    'UnsubscribedEvent',
    'UserBlockedEvent',
  },
  'PushAllowanceActor': {
    'App',
    'Team',
    'User',
  },
  'Reactor': {
    'Bot',
    'Mannequin',
    'Organization',
    'User',
  },
  'ReferencedSubject': {
    'Issue',
    'PullRequest',
  },
  'RenamedTitleSubject': {
    'Issue',
    'PullRequest',
  },
  'TopicAuditEntryData': {
    'RepoAddTopicAuditEntry',
    'RepoRemoveTopicAuditEntry',
  },
  'RepositoryInfo': {'Repository'},
  'Migration': {'RepositoryMigration'},
  'RequestedReviewer': {
    'Mannequin',
    'Team',
    'User',
  },
  'ReviewDismissalAllowanceActor': {
    'App',
    'Team',
    'User',
  },
  'SearchResultItem': {
    'App',
    'Discussion',
    'Issue',
    'MarketplaceListing',
    'Organization',
    'PullRequest',
    'Repository',
    'User',
  },
  'Sponsor': {
    'Organization',
    'User',
  },
  'SponsorableItem': {
    'Organization',
    'User',
  },
  'StatusCheckRollupContext': {
    'CheckRun',
    'StatusContext',
  },
  'VerifiableDomainOwner': {
    'Enterprise',
    'Organization',
  },
};
